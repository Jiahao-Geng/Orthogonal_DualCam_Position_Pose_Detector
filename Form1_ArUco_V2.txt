using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using MvCamCtrl;
using MvCamCtrl.NET;
using System.Threading;
using System.Runtime.InteropServices;
using System.Text.RegularExpressions;
using System.Drawing.Imaging;
using System.IO;
using System.Diagnostics;
using System.Collections.ObjectModel;
using OpenCvSharp;
using System.Numerics;
using OpenCvSharp.Aruco;
using Point = OpenCvSharp.Point;


namespace 海康威视图像采集及处理
{
    public partial class Form1 : Form
    {
        // DLL导入
        [DllImport("kernel32.dll", EntryPoint = "RtlMoveMemory", SetLastError = false)]
        private static extern void CopyMemory(IntPtr dest, IntPtr src, uint count);

        // 常量定义
        public const Int32 CUSTOMER_PIXEL_FORMAT = unchecked((Int32)0x80000000);

        // 相机1相关变量
        MyCamera.MV_CC_DEVICE_INFO_LIST m_stDeviceList = new MyCamera.MV_CC_DEVICE_INFO_LIST();
        private MyCamera m_MyCamera = new MyCamera();
        bool m_bGrabbing = false;
        Thread m_hReceiveThread = null;
        MyCamera.MV_FRAME_OUT_INFO_EX m_stFrameInfo = new MyCamera.MV_FRAME_OUT_INFO_EX();

        // 相机2相关变量
        MyCamera.MV_CC_DEVICE_INFO_LIST m_stDeviceList2 = new MyCamera.MV_CC_DEVICE_INFO_LIST();
        private MyCamera m_MyCamera2 = new MyCamera();
        bool m_bGrabbing2 = false;
        Thread m_hReceiveThread2 = null;
        MyCamera.MV_FRAME_OUT_INFO_EX m_stFrameInfo2 = new MyCamera.MV_FRAME_OUT_INFO_EX();

        // 相机1图像缓存相关
        UInt32 m_nBufSizeForDriver = 0;
        IntPtr m_BufForDriver = IntPtr.Zero;
        private static Object BufForDriverLock = new Object();
        Bitmap m_bitmap = null;
        PixelFormat m_bitmapPixelFormat = PixelFormat.DontCare;
        IntPtr m_ConvertDstBuf = IntPtr.Zero;
        UInt32 m_nConvertDstBufLen = 0;

        // 相机2图像缓存相关
        UInt32 m_nBufSizeForDriver2 = 0;
        IntPtr m_BufForDriver2 = IntPtr.Zero;
        private static Object BufForDriverLock2 = new Object();
        Bitmap m_bitmap2 = null;
        PixelFormat m_bitmapPixelFormat2 = PixelFormat.DontCare;
        IntPtr m_ConvertDstBuf2 = IntPtr.Zero;
        UInt32 m_nConvertDstBufLen2 = 0;

        // 图像处理相关变量
        private bool IsImageProceee = false;
        private bool IsImageProceee2 = false;
        private int frameCounter = 0;
        private int frameCounter2 = 0;
        private bool IsTrigger = false;
        Thread TriggerThread = null;
        private object syncLock = new object();

        // ArUco检测相关变量
        private Mat cameraMatrix;
        private Mat distCoeffs;


        // 立方体常量和变量
        private const float CUBE_SIZE = 35.0f;  // 立方体边长
        private const float MARKER_SIZE = 30.0f; // ArUco码边长


        // 存储立方体的当前位姿
        private (float X, float Y)?[] cubeCenters = new (float X, float Y)?[2];
        private class CubeInfo
        {   
            public (double X, double Y, double Z) Position;
            public (double Roll, double Pitch, double Yaw) Rotation;
        }
        private CubeInfo currentCubeInfo = new CubeInfo();


        // 定义Marker相对于立方体中心的变换关系
        private readonly Dictionary<int, (Vector3 offset, Vector3 rotation)> markerTransforms;

        private (float centerX, float centerY) EstimateCubeCenterFromMarker(
            int markerId,
            Point2f[] markerCorners,
            Mat rvec,
            Mat tvec)
                {
            float markerCenterX = markerCorners.Average(p => p.X);
            float markerCenterY = markerCorners.Average(p => p.Y);

            using (var rotMat = new Mat())
            {
                Cv2.Rodrigues(rvec, rotMat);

                if (!markerTransforms.TryGetValue(markerId, out var transform))
                    return (markerCenterX, markerCenterY);

                Vector3 originalOffset = transform.offset;

                double[] rotatedOffset = new double[3];
                for (int i = 0; i < 3; i++)
                {
                    rotatedOffset[i] =
                        rotMat.At<double>(i, 0) * originalOffset.X +
                        rotMat.At<double>(i, 1) * originalOffset.Y +
                        rotMat.At<double>(i, 2) * originalOffset.Z;
                }

                double fx = cameraMatrix.At<double>(0, 0);
                double fy = cameraMatrix.At<double>(1, 1);
                double Z = tvec.At<double>(2) + rotatedOffset[2];

                if (Z <= 0) return (markerCenterX, markerCenterY);

                double projectedOffsetX = (rotatedOffset[0] * fx) / Z;
                double projectedOffsetY = (rotatedOffset[1] * fy) / Z;

                return (
                    (float)(markerCenterX - projectedOffsetX),
                    (float)(markerCenterY - projectedOffsetY)
                );
            }
        }

        //计算marker面积的辅助方法
        private double CalculateMarkerArea(Point2f[] corners)
        {
            double area = 0;
            for (int i = 0; i < 4; i++)
            {
                int j = (i + 1) % 4;
                area += corners[i].X * corners[j].Y - corners[j].X * corners[i].Y;
            }
            return Math.Abs(area) / 2;
        }

        // 添加平滑滤波相关变量
        private class SmoothingFilter
        {
            private const int WINDOW_SIZE = 5;
            private Queue<(float X, float Y)> positionHistory = new Queue<(float X, float Y)>();
            private const float SMOOTHING_FACTOR = 0.5f;
            private (float X, float Y) lastSmoothedPosition = (0, 0);
            private bool hasLastPosition = false;

            public (float X, float Y) UpdateAndGetSmoothedPosition(float newX, float newY)
            {
                positionHistory.Enqueue((newX, newY));
                if (positionHistory.Count > WINDOW_SIZE)
                {
                    positionHistory.Dequeue();
                }

                float avgX = positionHistory.Average(p => p.X);
                float avgY = positionHistory.Average(p => p.Y);

                if (!hasLastPosition)
                {
                    lastSmoothedPosition = (avgX, avgY);
                    hasLastPosition = true;
                    return lastSmoothedPosition;
                }

                float smoothedX = SMOOTHING_FACTOR * lastSmoothedPosition.X + (1 - SMOOTHING_FACTOR) * avgX;
                float smoothedY = SMOOTHING_FACTOR * lastSmoothedPosition.Y + (1 - SMOOTHING_FACTOR) * avgY;

                lastSmoothedPosition = (smoothedX, smoothedY);
                return lastSmoothedPosition;
            }

            public void Reset()
            {
                positionHistory.Clear();
                hasLastPosition = false;
            }
        }

        private SmoothingFilter[] smoothingFilters = new SmoothingFilter[]
        {
        new SmoothingFilter(),
        new SmoothingFilter()
        };

        public Form1()
        {
            InitializeComponent();

            // 初始化marker变换关系

            markerTransforms = new Dictionary<int, (Vector3 offset, Vector3 rotation)>
            {
                { 1, (new Vector3(0, 0, CUBE_SIZE/2),  new Vector3(0, 0, 0)) },     // 前面
                { 3, (new Vector3(0, 0, -CUBE_SIZE/2), new Vector3(0, (float)Math.PI, 0)) }, // 后面
                { 5, (new Vector3(CUBE_SIZE/2, 0, 0),  new Vector3(0, (float)Math.PI/2, 0)) }, // 右面
                { 7, (new Vector3(-CUBE_SIZE/2, 0, 0), new Vector3(0, -(float)Math.PI/2, 0)) }, // 左面
                { 9, (new Vector3(0, -CUBE_SIZE/2, 0), new Vector3((float)Math.PI/2, 0, 0)) }   // 下面
            };

            Control.CheckForIllegalCrossThreadCalls = false;
            this.Load += new EventHandler(Form1_Load);

            // 初始化相机参数（需要根据实际标定结果修改）
            cameraMatrix = Mat.Eye(3, 3, MatType.CV_64F);
            cameraMatrix.Set<double>(0, 0, 1000.0); // fx
            cameraMatrix.Set<double>(1, 1, 1000.0); // fy
            cameraMatrix.Set<double>(0, 2, 1536 / 2.0); // cx
            cameraMatrix.Set<double>(1, 2, 1024 / 2.0); // cy

            distCoeffs = Mat.Zeros(rows: 1, cols: 5, type: MatType.CV_64F);
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            // 初始化SDK
            MyCamera.MV_CC_Initialize_NET();
            // 枚举设备
            DeviceListAcq();
            DeviceListAcq2();
        }

        // 像素类型是否为Mono格式检查
        private Boolean IsMono(UInt32 enPixelType)
        {
            switch (enPixelType)
            {
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono1p:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono2p:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono4p:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono8:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono8_Signed:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono10:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono10_Packed:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono12:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono12_Packed:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono14:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono16:
                    return true;
                default:
                    return false;
            }
        }

        // 取图前的必要操作
        private Int32 NecessaryOperBeforeGrab()
        {
            // 获取图像宽度
            MyCamera.MVCC_INTVALUE_EX stWidth = new MyCamera.MVCC_INTVALUE_EX();
            int nRet = m_MyCamera.MV_CC_GetIntValueEx_NET("Width", ref stWidth);
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Get Width Info Fail!", nRet);
                return nRet;
            }

            // 获取图像高度
            MyCamera.MVCC_INTVALUE_EX stHeight = new MyCamera.MVCC_INTVALUE_EX();
            nRet = m_MyCamera.MV_CC_GetIntValueEx_NET("Height", ref stHeight);
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Get Height Info Fail!", nRet);
                return nRet;
            }

            // 获取像素格式
            MyCamera.MVCC_ENUMVALUE stPixelFormat = new MyCamera.MVCC_ENUMVALUE();
            nRet = m_MyCamera.MV_CC_GetEnumValue_NET("PixelFormat", ref stPixelFormat);
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Get Pixel Format Fail!", nRet);
                return nRet;
            }

            // 设置bitmap像素格式，分配内存
            if ((Int32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Undefined == (Int32)stPixelFormat.nCurValue)
            {
                ShowErrorMsg("Unknown Pixel Format!", MyCamera.MV_E_UNKNOW);
                return MyCamera.MV_E_UNKNOW;
            }
            else if (IsMono(stPixelFormat.nCurValue))
            {
                m_bitmapPixelFormat = PixelFormat.Format8bppIndexed;

                if (IntPtr.Zero != m_ConvertDstBuf)
                {
                    Marshal.Release(m_ConvertDstBuf);
                    m_ConvertDstBuf = IntPtr.Zero;
                }
                m_nConvertDstBufLen = (UInt32)(stWidth.nCurValue * stHeight.nCurValue);
                m_ConvertDstBuf = Marshal.AllocHGlobal((Int32)m_nConvertDstBufLen);
            }
            else
            {
                m_bitmapPixelFormat = PixelFormat.Format24bppRgb;

                if (IntPtr.Zero != m_ConvertDstBuf)
                {
                    Marshal.FreeHGlobal(m_ConvertDstBuf);
                    m_ConvertDstBuf = IntPtr.Zero;
                }
                m_nConvertDstBufLen = (UInt32)(3 * stWidth.nCurValue * stHeight.nCurValue);
                m_ConvertDstBuf = Marshal.AllocHGlobal((Int32)m_nConvertDstBufLen);
            }

            if (null != m_bitmap)
            {
                m_bitmap.Dispose();
                m_bitmap = null;
            }
            m_bitmap = new Bitmap((Int32)stWidth.nCurValue, (Int32)stHeight.nCurValue, m_bitmapPixelFormat);

            if (PixelFormat.Format8bppIndexed == m_bitmapPixelFormat)
            {
                ColorPalette palette = m_bitmap.Palette;
                for (int i = 0; i < palette.Entries.Length; i++)
                {
                    palette.Entries[i] = Color.FromArgb(i, i, i);
                }
                m_bitmap.Palette = palette;
            }

            return MyCamera.MV_OK;
        }

        // 显示错误信息
        private void ShowErrorMsg(string csMessage, int nErrorNum)
        {
            string errorMsg;
            if (nErrorNum == 0)
            {
                errorMsg = csMessage;
            }
            else
            {
                errorMsg = csMessage + ": Error =" + String.Format("{0:X}", nErrorNum);
            }

            switch (nErrorNum)
            {
                case MyCamera.MV_E_HANDLE: errorMsg += " Error or invalid handle "; break;
                case MyCamera.MV_E_SUPPORT: errorMsg += " Not supported function "; break;
                case MyCamera.MV_E_BUFOVER: errorMsg += " Cache is full "; break;
                case MyCamera.MV_E_CALLORDER: errorMsg += " Function calling order error "; break;
                case MyCamera.MV_E_PARAMETER: errorMsg += " Incorrect parameter "; break;
                case MyCamera.MV_E_RESOURCE: errorMsg += " Applying resource failed "; break;
                case MyCamera.MV_E_NODATA: errorMsg += " No data "; break;
                case MyCamera.MV_E_PRECONDITION: errorMsg += " Precondition error, or running environment changed "; break;
                case MyCamera.MV_E_VERSION: errorMsg += " Version mismatches "; break;
                case MyCamera.MV_E_NOENOUGH_BUF: errorMsg += " Insufficient memory "; break;
                case MyCamera.MV_E_UNKNOW: errorMsg += " Unknown error "; break;
                case MyCamera.MV_E_GC_GENERIC: errorMsg += " General error "; break;
                case MyCamera.MV_E_GC_ACCESS: errorMsg += " Node accessing condition error "; break;
                case MyCamera.MV_E_ACCESS_DENIED: errorMsg += " No permission "; break;
                case MyCamera.MV_E_BUSY: errorMsg += " Device is busy, or network disconnected "; break;
                case MyCamera.MV_E_NETER: errorMsg += " Network error "; break;
            }

            MessageBox.Show(errorMsg, "PROMPT");
        }

        // 用于清理设备名称中的空字符
        private string DeleteTail(string strUserDefinedName)
        {
            strUserDefinedName = Regex.Unescape(strUserDefinedName);
            int nIndex = strUserDefinedName.IndexOf("\0");
            if (nIndex >= 0)
            {
                strUserDefinedName = strUserDefinedName.Remove(nIndex);
            }
            return strUserDefinedName;
        }

        // 取图前的必要操作2
        private Int32 NecessaryOperBeforeGrab2()
        {
            MyCamera.MVCC_INTVALUE_EX stWidth = new MyCamera.MVCC_INTVALUE_EX();
            int nRet = m_MyCamera2.MV_CC_GetIntValueEx_NET("Width", ref stWidth);
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Get Width Info Fail!", nRet);
                return nRet;
            }

            MyCamera.MVCC_INTVALUE_EX stHeight = new MyCamera.MVCC_INTVALUE_EX();
            nRet = m_MyCamera2.MV_CC_GetIntValueEx_NET("Height", ref stHeight);
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Get Height Info Fail!", nRet);
                return nRet;
            }

            MyCamera.MVCC_ENUMVALUE stPixelFormat = new MyCamera.MVCC_ENUMVALUE();
            nRet = m_MyCamera2.MV_CC_GetEnumValue_NET("PixelFormat", ref stPixelFormat);
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Get Pixel Format Fail!", nRet);
                return nRet;
            }

            if ((Int32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Undefined == (Int32)stPixelFormat.nCurValue)
            {
                ShowErrorMsg("Unknown Pixel Format!", MyCamera.MV_E_UNKNOW);
                return MyCamera.MV_E_UNKNOW;
            }
            else if (IsMono(stPixelFormat.nCurValue))
            {
                m_bitmapPixelFormat2 = PixelFormat.Format8bppIndexed;

                if (IntPtr.Zero != m_ConvertDstBuf2)
                {
                    Marshal.Release(m_ConvertDstBuf2);
                    m_ConvertDstBuf2 = IntPtr.Zero;
                }
                m_nConvertDstBufLen2 = (UInt32)(stWidth.nCurValue * stHeight.nCurValue);
                m_ConvertDstBuf2 = Marshal.AllocHGlobal((Int32)m_nConvertDstBufLen2);
            }
            else
            {
                m_bitmapPixelFormat2 = PixelFormat.Format24bppRgb;

                if (IntPtr.Zero != m_ConvertDstBuf2)
                {
                    Marshal.FreeHGlobal(m_ConvertDstBuf2);
                    m_ConvertDstBuf2 = IntPtr.Zero;
                }
                m_nConvertDstBufLen2 = (UInt32)(3 * stWidth.nCurValue * stHeight.nCurValue);
                m_ConvertDstBuf2 = Marshal.AllocHGlobal((Int32)m_nConvertDstBufLen2);
            }

            if (null != m_bitmap2)
            {
                m_bitmap2.Dispose();
                m_bitmap2 = null;
            }
            m_bitmap2 = new Bitmap((Int32)stWidth.nCurValue, (Int32)stHeight.nCurValue, m_bitmapPixelFormat2);

            if (PixelFormat.Format8bppIndexed == m_bitmapPixelFormat2)
            {
                ColorPalette palette = m_bitmap2.Palette;
                for (int i = 0; i < palette.Entries.Length; i++)
                {
                    palette.Entries[i] = Color.FromArgb(i, i, i);
                }
                m_bitmap2.Palette = palette;
            }

            return MyCamera.MV_OK;
        }

        // 设备枚举相关方法
        private void btn_Enum_Click(object sender, EventArgs e)
        {
            DeviceListAcq();
        }

        private void btn_Enum2_Click(object sender, EventArgs e)
        {
            DeviceListAcq2();
        }

        private void DeviceListAcq()
        {
            System.GC.Collect();
            cbDeviceList.Items.Clear();
            m_stDeviceList.nDeviceNum = 0;

            int nRet = MyCamera.MV_CC_EnumDevices_NET(MyCamera.MV_GIGE_DEVICE | MyCamera.MV_USB_DEVICE | MyCamera.MV_GENTL_GIGE_DEVICE
                | MyCamera.MV_GENTL_CAMERALINK_DEVICE | MyCamera.MV_GENTL_CXP_DEVICE | MyCamera.MV_GENTL_XOF_DEVICE, ref m_stDeviceList);

            if (0 != nRet)
            {
                ShowErrorMsg("Enumerate devices fail!", 0);
                return;
            }

            // 在窗体列表中显示设备名
            for (int i = 0; i < m_stDeviceList.nDeviceNum; i++)
            {
                MyCamera.MV_CC_DEVICE_INFO device = (MyCamera.MV_CC_DEVICE_INFO)Marshal.PtrToStructure(m_stDeviceList.pDeviceInfo[i], typeof(MyCamera.MV_CC_DEVICE_INFO));
                string strUserDefinedName = "";

                if (device.nTLayerType == MyCamera.MV_GIGE_DEVICE)
                {
                    MyCamera.MV_GIGE_DEVICE_INFO_EX gigeInfo = (MyCamera.MV_GIGE_DEVICE_INFO_EX)MyCamera.ByteToStruct(device.SpecialInfo.stGigEInfo, typeof(MyCamera.MV_GIGE_DEVICE_INFO_EX));

                    if ((gigeInfo.chUserDefinedName.Length > 0) && (gigeInfo.chUserDefinedName[0] != '\0'))
                    {
                        if (MyCamera.IsTextUTF8(gigeInfo.chUserDefinedName))
                            strUserDefinedName = Encoding.UTF8.GetString(gigeInfo.chUserDefinedName).TrimEnd('\0');
                        else
                            strUserDefinedName = Encoding.Default.GetString(gigeInfo.chUserDefinedName).TrimEnd('\0');
                        cbDeviceList.Items.Add("GEV: " + DeleteTail(strUserDefinedName) + " (" + gigeInfo.chSerialNumber + ")");
                    }
                    else
                    {
                        cbDeviceList.Items.Add("GEV: " + gigeInfo.chManufacturerName + " " + gigeInfo.chModelName + " (" + gigeInfo.chSerialNumber + ")");
                    }
                }
                else if (device.nTLayerType == MyCamera.MV_USB_DEVICE)
                {
                    MyCamera.MV_USB3_DEVICE_INFO_EX usbInfo = (MyCamera.MV_USB3_DEVICE_INFO_EX)MyCamera.ByteToStruct(device.SpecialInfo.stUsb3VInfo, typeof(MyCamera.MV_USB3_DEVICE_INFO_EX));

                    if ((usbInfo.chUserDefinedName.Length > 0) && (usbInfo.chUserDefinedName[0] != '\0'))
                    {
                        if (MyCamera.IsTextUTF8(usbInfo.chUserDefinedName))
                            strUserDefinedName = Encoding.UTF8.GetString(usbInfo.chUserDefinedName).TrimEnd('\0');
                        else
                            strUserDefinedName = Encoding.Default.GetString(usbInfo.chUserDefinedName).TrimEnd('\0');
                        cbDeviceList.Items.Add("U3V: " + DeleteTail(strUserDefinedName) + " (" + usbInfo.chSerialNumber + ")");
                    }
                    else
                    {
                        cbDeviceList.Items.Add("U3V: " + usbInfo.chManufacturerName + " " + usbInfo.chModelName + " (" + usbInfo.chSerialNumber + ")");
                    }
                }
            }

            if (m_stDeviceList.nDeviceNum != 0)
            {
                cbDeviceList.SelectedIndex = 0;
            }
        }

        private void DeviceListAcq2()
        {
            System.GC.Collect();
            cbDeviceList2.Items.Clear();
            m_stDeviceList2.nDeviceNum = 0;

            int nRet = MyCamera.MV_CC_EnumDevices_NET(MyCamera.MV_GIGE_DEVICE | MyCamera.MV_USB_DEVICE | MyCamera.MV_GENTL_GIGE_DEVICE
                | MyCamera.MV_GENTL_CAMERALINK_DEVICE | MyCamera.MV_GENTL_CXP_DEVICE | MyCamera.MV_GENTL_XOF_DEVICE, ref m_stDeviceList2);

            if (0 != nRet)
            {
                ShowErrorMsg("Enumerate devices fail!", 0);
                return;
            }

            // 在窗体列表中显示设备名
            for (int i = 0; i < m_stDeviceList2.nDeviceNum; i++)
            {
                MyCamera.MV_CC_DEVICE_INFO device = (MyCamera.MV_CC_DEVICE_INFO)Marshal.PtrToStructure(m_stDeviceList2.pDeviceInfo[i], typeof(MyCamera.MV_CC_DEVICE_INFO));
                string strUserDefinedName = "";

                if (device.nTLayerType == MyCamera.MV_GIGE_DEVICE)
                {
                    MyCamera.MV_GIGE_DEVICE_INFO_EX gigeInfo = (MyCamera.MV_GIGE_DEVICE_INFO_EX)MyCamera.ByteToStruct(device.SpecialInfo.stGigEInfo, typeof(MyCamera.MV_GIGE_DEVICE_INFO_EX));

                    if ((gigeInfo.chUserDefinedName.Length > 0) && (gigeInfo.chUserDefinedName[0] != '\0'))
                    {
                        if (MyCamera.IsTextUTF8(gigeInfo.chUserDefinedName))
                            strUserDefinedName = Encoding.UTF8.GetString(gigeInfo.chUserDefinedName).TrimEnd('\0');
                        else
                            strUserDefinedName = Encoding.Default.GetString(gigeInfo.chUserDefinedName).TrimEnd('\0');
                        cbDeviceList2.Items.Add("GEV: " + DeleteTail(strUserDefinedName) + " (" + gigeInfo.chSerialNumber + ")");
                    }
                    else
                    {
                        cbDeviceList2.Items.Add("GEV: " + gigeInfo.chManufacturerName + " " + gigeInfo.chModelName + " (" + gigeInfo.chSerialNumber + ")");
                    }
                }
                else if (device.nTLayerType == MyCamera.MV_USB_DEVICE)
                {
                    MyCamera.MV_USB3_DEVICE_INFO_EX usbInfo = (MyCamera.MV_USB3_DEVICE_INFO_EX)MyCamera.ByteToStruct(device.SpecialInfo.stUsb3VInfo, typeof(MyCamera.MV_USB3_DEVICE_INFO_EX));

                    if ((usbInfo.chUserDefinedName.Length > 0) && (usbInfo.chUserDefinedName[0] != '\0'))
                    {
                        if (MyCamera.IsTextUTF8(usbInfo.chUserDefinedName))
                            strUserDefinedName = Encoding.UTF8.GetString(usbInfo.chUserDefinedName).TrimEnd('\0');
                        else
                            strUserDefinedName = Encoding.Default.GetString(usbInfo.chUserDefinedName).TrimEnd('\0');
                        cbDeviceList2.Items.Add("U3V: " + DeleteTail(strUserDefinedName) + " (" + usbInfo.chSerialNumber + ")");
                    }
                    else
                    {
                        cbDeviceList2.Items.Add("U3V: " + usbInfo.chManufacturerName + " " + usbInfo.chModelName + " (" + usbInfo.chSerialNumber + ")");
                    }
                }
            }

            if (m_stDeviceList2.nDeviceNum != 0)
            {
                cbDeviceList2.SelectedIndex = 0;
            }
        }

        // 设备打开关闭相关方法
        private void btn_OpenDevice_Click(object sender, EventArgs e)
        {
            if (m_stDeviceList.nDeviceNum == 0 || cbDeviceList.SelectedIndex == -1)
            {
                ShowErrorMsg("No device, please select", 0);
                return;
            }

            MyCamera.MV_CC_DEVICE_INFO device =
                (MyCamera.MV_CC_DEVICE_INFO)Marshal.PtrToStructure(m_stDeviceList.pDeviceInfo[cbDeviceList.SelectedIndex],
                                                              typeof(MyCamera.MV_CC_DEVICE_INFO));

            if (null == m_MyCamera)
            {
                m_MyCamera = new MyCamera();
                if (null == m_MyCamera)
                {
                    ShowErrorMsg("Applying resource fail!", MyCamera.MV_E_RESOURCE);
                    return;
                }
            }

            int nRet = m_MyCamera.MV_CC_CreateDevice_NET(ref device);
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Create device fail!", nRet);
                return;
            }

            nRet = m_MyCamera.MV_CC_OpenDevice_NET();
            if (MyCamera.MV_OK != nRet)
            {
                m_MyCamera.MV_CC_DestroyDevice_NET();
                ShowErrorMsg("Device open fail!", nRet);
                return;
            }

            // 探测网络最佳包大小(只对GigE相机有效)
            if (device.nTLayerType == MyCamera.MV_GIGE_DEVICE)
            {
                int nPacketSize = m_MyCamera.MV_CC_GetOptimalPacketSize_NET();
                if (nPacketSize > 0)
                {
                    nRet = m_MyCamera.MV_CC_SetIntValueEx_NET("GevSCPSPacketSize", nPacketSize);
                    if (nRet != MyCamera.MV_OK)
                    {
                        ShowErrorMsg("Set Packet Size failed!", nRet);
                    }
                }
                else
                {
                    ShowErrorMsg("Get Packet Size failed!", nPacketSize);
                }
            }

            // 设置触发模式为off
            m_MyCamera.MV_CC_SetEnumValue_NET("TriggerMode", (uint)MyCamera.MV_CAM_TRIGGER_MODE.MV_TRIGGER_MODE_OFF);

            // 获取参数
            bnGetParam_Click(null, null);

            SetCtrlWhenOpen();
        }

        private void btn_OpenDevice2_Click(object sender, EventArgs e)
        {
            if (m_stDeviceList2.nDeviceNum == 0 || cbDeviceList2.SelectedIndex == -1)
            {
                ShowErrorMsg("No device, please select", 0);
                return;
            }

            MyCamera.MV_CC_DEVICE_INFO device2 =
                (MyCamera.MV_CC_DEVICE_INFO)Marshal.PtrToStructure(m_stDeviceList2.pDeviceInfo[cbDeviceList2.SelectedIndex],
                                                              typeof(MyCamera.MV_CC_DEVICE_INFO));

            if (null == m_MyCamera2)
            {
                m_MyCamera2 = new MyCamera();
                if (null == m_MyCamera2)
                {
                    ShowErrorMsg("Applying resource fail!", MyCamera.MV_E_RESOURCE);
                    return;
                }
            }

            int nRet = m_MyCamera2.MV_CC_CreateDevice_NET(ref device2);
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Create device fail!", nRet);
                return;
            }

            nRet = m_MyCamera2.MV_CC_OpenDevice_NET();
            if (MyCamera.MV_OK != nRet)
            {
                m_MyCamera2.MV_CC_DestroyDevice_NET();
                ShowErrorMsg("Device open fail!", nRet);
                return;
            }

            if (device2.nTLayerType == MyCamera.MV_GIGE_DEVICE)
            {
                int nPacketSize2 = m_MyCamera2.MV_CC_GetOptimalPacketSize_NET();
                if (nPacketSize2 > 0)
                {
                    nRet = m_MyCamera2.MV_CC_SetIntValueEx_NET("GevSCPSPacketSize", nPacketSize2);
                    if (nRet != MyCamera.MV_OK)
                    {
                        ShowErrorMsg("Set Packet Size failed!", nRet);
                    }
                }
                else
                {
                    ShowErrorMsg("Get Packet Size failed!", nPacketSize2);
                }
            }

            m_MyCamera2.MV_CC_SetEnumValue_NET("TriggerMode", (uint)MyCamera.MV_CAM_TRIGGER_MODE.MV_TRIGGER_MODE_OFF);

            bnGetParam2_Click(null, null);

            SetCtrlWhenOpen2();
        }

        private void btn_CloseDevice_Click(object sender, EventArgs e)
        {
            if (m_bGrabbing == true)
            {
                m_bGrabbing = false;
                m_hReceiveThread.Join();
            }

            if (m_BufForDriver != IntPtr.Zero)
            {
                Marshal.Release(m_BufForDriver);
            }

            if (m_MyCamera != null)
            {
                m_MyCamera.MV_CC_CloseDevice_NET();
                m_MyCamera.MV_CC_DestroyDevice_NET();
            }

            SetCtrlWhenClose();
        }

        private void btn_CloseDevice2_Click(object sender, EventArgs e)
        {
            if (m_bGrabbing2 == true)
            {
                m_bGrabbing2 = false;
                m_hReceiveThread2.Join();
            }

            if (m_BufForDriver2 != IntPtr.Zero)
            {
                Marshal.Release(m_BufForDriver2);
            }

            if (m_MyCamera2 != null)
            {
                m_MyCamera2.MV_CC_CloseDevice_NET();
                m_MyCamera2.MV_CC_DestroyDevice_NET();
            }

            SetCtrlWhenClose2();
        }

        // 参数设置相关方法
        private void bnGetParam_Click(object sender, EventArgs e)
        {
            MyCamera.MVCC_FLOATVALUE stParam = new MyCamera.MVCC_FLOATVALUE();
            int nRet = m_MyCamera.MV_CC_GetFloatValue_NET("ExposureTime", ref stParam);
            if (MyCamera.MV_OK == nRet)
            {
                tbExposure.Text = stParam.fCurValue.ToString("F1");
            }

            nRet = m_MyCamera.MV_CC_GetFloatValue_NET("Gain", ref stParam);
            if (MyCamera.MV_OK == nRet)
            {
                tbGain.Text = stParam.fCurValue.ToString("F1");
            }

            nRet = m_MyCamera.MV_CC_GetFloatValue_NET("ResultingFrameRate", ref stParam);
            if (MyCamera.MV_OK == nRet)
            {
                tbFrameRate.Text = stParam.fCurValue.ToString("F1");
            }
        }

        private void bnGetParam2_Click(object sender, EventArgs e)
        {
            MyCamera.MVCC_FLOATVALUE stParam = new MyCamera.MVCC_FLOATVALUE();
            int nRet = m_MyCamera2.MV_CC_GetFloatValue_NET("ExposureTime", ref stParam);
            if (MyCamera.MV_OK == nRet)
            {
                tbExposure2.Text = stParam.fCurValue.ToString("F1");
            }

            nRet = m_MyCamera2.MV_CC_GetFloatValue_NET("Gain", ref stParam);
            if (MyCamera.MV_OK == nRet)
            {
                tbGain2.Text = stParam.fCurValue.ToString("F1");
            }

            nRet = m_MyCamera2.MV_CC_GetFloatValue_NET("ResultingFrameRate", ref stParam);
            if (MyCamera.MV_OK == nRet)
            {
                tbFrameRate2.Text = stParam.fCurValue.ToString("F1");
            }
        }

        private void bnSetParam_Click(object sender, EventArgs e)
        {
            try
            {
                float.Parse(tbExposure.Text);
                float.Parse(tbGain.Text);
                float.Parse(tbFrameRate.Text);
            }
            catch
            {
                ShowErrorMsg("Please enter correct type!", 0);
                return;
            }

            m_MyCamera.MV_CC_SetEnumValue_NET("ExposureAuto", 0);
            int nRet = m_MyCamera.MV_CC_SetFloatValue_NET("ExposureTime", float.Parse(tbExposure.Text));
            if (nRet != MyCamera.MV_OK)
            {
                ShowErrorMsg("Set Exposure Time Fail!", nRet);
            }

            m_MyCamera.MV_CC_SetEnumValue_NET("GainAuto", 0);
            nRet = m_MyCamera.MV_CC_SetFloatValue_NET("Gain", float.Parse(tbGain.Text));
            if (nRet != MyCamera.MV_OK)
            {
                ShowErrorMsg("Set Gain Fail!", nRet);
            }

            nRet = m_MyCamera.MV_CC_SetFloatValue_NET("AcquisitionFrameRate", float.Parse(tbFrameRate.Text));
            if (nRet != MyCamera.MV_OK)
            {
                ShowErrorMsg("Set Frame Rate Fail!", nRet);
            }
        }

        private void bnSetParam2_Click(object sender, EventArgs e)
        {
            try
            {
                float.Parse(tbExposure2.Text);
                float.Parse(tbGain2.Text);
                float.Parse(tbFrameRate2.Text);
            }
            catch
            {
                ShowErrorMsg("Please enter correct type!", 0);
                return;
            }

            m_MyCamera2.MV_CC_SetEnumValue_NET("ExposureAuto", 0);
            int nRet = m_MyCamera2.MV_CC_SetFloatValue_NET("ExposureTime", float.Parse(tbExposure2.Text));
            if (nRet != MyCamera.MV_OK)
            {
                ShowErrorMsg("Set Exposure Time Fail!", nRet);
            }

            m_MyCamera2.MV_CC_SetEnumValue_NET("GainAuto", 0);
            nRet = m_MyCamera2.MV_CC_SetFloatValue_NET("Gain", float.Parse(tbGain2.Text));
            if (nRet != MyCamera.MV_OK)
            {
                ShowErrorMsg("Set Gain Fail!", nRet);
            }

            nRet = m_MyCamera2.MV_CC_SetFloatValue_NET("AcquisitionFrameRate", float.Parse(tbFrameRate2.Text));
            if (nRet != MyCamera.MV_OK)
            {
                ShowErrorMsg("Set Frame Rate Fail!", nRet);
            }
        }

        // 控件操作相关方法
        private void SetCtrlWhenOpen()
        {
            btn_OpenDevice.Enabled = false;
            btn_CloseDevice.Enabled = true;
            bnStartGrab.Enabled = true;
            bnStopGrab.Enabled = false;
            bnContinuesMode.Enabled = true;
            bnContinuesMode.Checked = true;
            bnTriggerMode.Enabled = true;
            cbSoftTrigger.Enabled = false;
            cbImageProcess.Enabled = true;
            bnTriggerExec.Enabled = false;

            tbExposure.Enabled = true;
            tbGain.Enabled = true;
            tbFrameRate.Enabled = true;
            bnGetParam.Enabled = true;
            bnSetParam.Enabled = true;
        }

        private void SetCtrlWhenOpen2()
        {
            btn_OpenDevice2.Enabled = false;
            btn_CloseDevice2.Enabled = true;
            bnStartGrab2.Enabled = true;
            bnStopGrab2.Enabled = false;
            bnContinuesMode2.Enabled = true;
            bnContinuesMode2.Checked = true;
            bnTriggerMode2.Enabled = true;
            cbSoftTrigger2.Enabled = false;
            cbImageProcess2.Enabled = true;
            bnTriggerExec2.Enabled = false;

            tbExposure2.Enabled = true;
            tbGain2.Enabled = true;
            tbFrameRate2.Enabled = true;
            bnGetParam2.Enabled = true;
            bnSetParam2.Enabled = true;
        }

        private void SetCtrlWhenClose()
        {
            btn_OpenDevice.Enabled = true;
            btn_CloseDevice.Enabled = false;
            bnStartGrab.Enabled = false;
            bnStopGrab.Enabled = false;
            bnContinuesMode.Enabled = false;
            bnTriggerMode.Enabled = false;
            cbSoftTrigger.Enabled = false;
            cbImageProcess.Enabled = false;
            bnTriggerExec.Enabled = false;

            tbExposure.Enabled = false;
            tbGain.Enabled = false;
            tbFrameRate.Enabled = false;
            bnGetParam.Enabled = false;
            bnSetParam.Enabled = false;
        }

        private void SetCtrlWhenClose2()
        {
            btn_OpenDevice2.Enabled = true;
            btn_CloseDevice2.Enabled = false;
            bnStartGrab2.Enabled = false;
            bnStopGrab2.Enabled = false;
            bnContinuesMode2.Enabled = false;
            bnTriggerMode2.Enabled = false;
            cbSoftTrigger2.Enabled = false;
            cbImageProcess2.Enabled = false;
            bnTriggerExec2.Enabled = false;

            tbExposure2.Enabled = false;
            tbGain2.Enabled = false;
            tbFrameRate2.Enabled = false;
            bnGetParam2.Enabled = false;
            bnSetParam2.Enabled = false;
        }

        private void SetCtrlWhenStartGrab()
        {
            bnStartGrab.Enabled = false;
            bnStopGrab.Enabled = true;

            if (bnTriggerMode.Checked && cbSoftTrigger.Checked)
            {
                bnTriggerExec.Enabled = true;
            }

            cbImageProcess.Enabled = true;
        }

        private void SetCtrlWhenStartGrab2()
        {
            bnStartGrab2.Enabled = false;
            bnStopGrab2.Enabled = true;

            if (bnTriggerMode2.Checked && cbSoftTrigger2.Checked)
            {
                bnTriggerExec2.Enabled = true;
            }

            cbImageProcess2.Enabled = true;
        }

        private void SetCtrlWhenStopGrab()
        {
            bnStartGrab.Enabled = true;
            bnStopGrab.Enabled = false;
            bnTriggerExec.Enabled = false;
        }

        private void SetCtrlWhenStopGrab2()
        {
            bnStartGrab2.Enabled = true;
            bnStopGrab2.Enabled = false;
            bnTriggerExec2.Enabled = false;
        }
        // 图像采集相关方法
        private void bnStartGrab_Click(object sender, EventArgs e)
        {
            int nRet = NecessaryOperBeforeGrab();
            if (MyCamera.MV_OK != nRet)
            {
                return;
            }

            m_bGrabbing = true;
            m_stFrameInfo.nFrameLen = 0;
            m_stFrameInfo.enPixelType = MyCamera.MvGvspPixelType.PixelType_Gvsp_Undefined;

            m_hReceiveThread = new Thread(ReceiveThreadProcess);
            m_hReceiveThread.Start();

            nRet = m_MyCamera.MV_CC_StartGrabbing_NET();
            if (MyCamera.MV_OK != nRet)
            {
                m_bGrabbing = false;
                m_hReceiveThread.Join();
                ShowErrorMsg("Start Grabbing Fail!", nRet);
                return;
            }

            SetCtrlWhenStartGrab();
        }

        private void bnStartGrab2_Click(object sender, EventArgs e)
        {
            int nRet = NecessaryOperBeforeGrab2();
            if (MyCamera.MV_OK != nRet)
            {
                return;
            }

            m_bGrabbing2 = true;
            m_stFrameInfo2.nFrameLen = 0;
            m_stFrameInfo2.enPixelType = MyCamera.MvGvspPixelType.PixelType_Gvsp_Undefined;

            m_hReceiveThread2 = new Thread(ReceiveThreadProcess2);
            m_hReceiveThread2.Start();

            nRet = m_MyCamera2.MV_CC_StartGrabbing_NET();
            if (MyCamera.MV_OK != nRet)
            {
                m_bGrabbing2 = false;
                m_hReceiveThread2.Join();
                ShowErrorMsg("Start Grabbing Fail!", nRet);
                return;
            }

            SetCtrlWhenStartGrab2();
        }

        private void bnStopGrab_Click(object sender, EventArgs e)
        {
            m_bGrabbing = false;
            m_hReceiveThread.Join();

            // 重置平滑器
            smoothingFilters[0].Reset();

            int nRet = m_MyCamera.MV_CC_StopGrabbing_NET();
            if (nRet != MyCamera.MV_OK)
            {
                ShowErrorMsg("Stop Grabbing Fail!", nRet);
            }

            SetCtrlWhenStopGrab();
        }

        private void bnStopGrab2_Click(object sender, EventArgs e)
        {
            m_bGrabbing2 = false;
            m_hReceiveThread2.Join();

            // 重置平滑器
            smoothingFilters[1].Reset();

            int nRet = m_MyCamera2.MV_CC_StopGrabbing_NET();
            if (nRet != MyCamera.MV_OK)
            {
                ShowErrorMsg("Stop Grabbing Fail!", nRet);
            }

            SetCtrlWhenStopGrab2();
        }

        // 图像接收线程
        public void ReceiveThreadProcess()
        {
            MyCamera.MV_FRAME_OUT stFrameInfo = new MyCamera.MV_FRAME_OUT();
            MyCamera.MV_DISPLAY_FRAME_INFO stDisplayInfo = new MyCamera.MV_DISPLAY_FRAME_INFO();
            MyCamera.MV_PIXEL_CONVERT_PARAM stConvertInfo = new MyCamera.MV_PIXEL_CONVERT_PARAM();
            int nRet = MyCamera.MV_OK;

            while (m_bGrabbing)
            {
                nRet = m_MyCamera.MV_CC_GetImageBuffer_NET(ref stFrameInfo, 1000);
                if (nRet == MyCamera.MV_OK)
                {
                    lock (BufForDriverLock)
                    {
                        if (m_BufForDriver == IntPtr.Zero || stFrameInfo.stFrameInfo.nFrameLen > m_nBufSizeForDriver)
                        {
                            if (m_BufForDriver != IntPtr.Zero)
                            {
                                Marshal.Release(m_BufForDriver);
                                m_BufForDriver = IntPtr.Zero;
                            }

                            m_BufForDriver = Marshal.AllocHGlobal((Int32)stFrameInfo.stFrameInfo.nFrameLen);
                            if (m_BufForDriver == IntPtr.Zero)
                            {
                                return;
                            }
                            m_nBufSizeForDriver = stFrameInfo.stFrameInfo.nFrameLen;
                        }

                        m_stFrameInfo = stFrameInfo.stFrameInfo;
                        CopyMemory(m_BufForDriver, stFrameInfo.pBufAddr, stFrameInfo.stFrameInfo.nFrameLen);

                        stConvertInfo.nWidth = stFrameInfo.stFrameInfo.nWidth;
                        stConvertInfo.nHeight = stFrameInfo.stFrameInfo.nHeight;
                        stConvertInfo.enSrcPixelType = stFrameInfo.stFrameInfo.enPixelType;
                        stConvertInfo.pSrcData = stFrameInfo.pBufAddr;
                        stConvertInfo.nSrcDataLen = stFrameInfo.stFrameInfo.nFrameLen;
                        stConvertInfo.pDstBuffer = m_ConvertDstBuf;
                        stConvertInfo.nDstBufferSize = m_nConvertDstBufLen;
                        if (PixelFormat.Format8bppIndexed == m_bitmap.PixelFormat)
                        {
                            stConvertInfo.enDstPixelType = MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono8;
                            m_MyCamera.MV_CC_ConvertPixelType_NET(ref stConvertInfo);
                        }
                        else
                        {
                            stConvertInfo.enDstPixelType = MyCamera.MvGvspPixelType.PixelType_Gvsp_BGR8_Packed;
                            m_MyCamera.MV_CC_ConvertPixelType_NET(ref stConvertInfo);
                        }

                        BitmapData bmpData = m_bitmap.LockBits(new Rectangle(0, 0, stConvertInfo.nWidth, stConvertInfo.nHeight),
                            ImageLockMode.ReadWrite, m_bitmap.PixelFormat);
                        CopyMemory(bmpData.Scan0, stConvertInfo.pDstBuffer, (UInt32)(bmpData.Stride * m_bitmap.Height));
                        m_bitmap.UnlockBits(bmpData);

                        if (IsImageProceee)
                        {
                            Mat mat = OpenCvSharp.Extensions.BitmapConverter.ToMat(m_bitmap);
                            ProcessAndDisplayImageAsync(mat);
                        }
                    }

                    stDisplayInfo.hWnd = pictureBox1.Handle;
                    stDisplayInfo.pData = stFrameInfo.pBufAddr;
                    stDisplayInfo.nDataLen = stFrameInfo.stFrameInfo.nFrameLen;
                    stDisplayInfo.nWidth = stFrameInfo.stFrameInfo.nWidth;
                    stDisplayInfo.nHeight = stFrameInfo.stFrameInfo.nHeight;
                    stDisplayInfo.enPixelType = stFrameInfo.stFrameInfo.enPixelType;
                    m_MyCamera.MV_CC_DisplayOneFrame_NET(ref stDisplayInfo);

                    m_MyCamera.MV_CC_FreeImageBuffer_NET(ref stFrameInfo);
                }
                else
                {
                    if (bnTriggerMode.Checked)
                    {
                        Thread.Sleep(5);
                    }
                }
            }
        }

        public void ReceiveThreadProcess2()
        {
            MyCamera.MV_FRAME_OUT stFrameInfo = new MyCamera.MV_FRAME_OUT();
            MyCamera.MV_DISPLAY_FRAME_INFO stDisplayInfo = new MyCamera.MV_DISPLAY_FRAME_INFO();
            MyCamera.MV_PIXEL_CONVERT_PARAM stConvertInfo = new MyCamera.MV_PIXEL_CONVERT_PARAM();
            int nRet = MyCamera.MV_OK;

            while (m_bGrabbing2)
            {
                nRet = m_MyCamera2.MV_CC_GetImageBuffer_NET(ref stFrameInfo, 1000);
                if (nRet == MyCamera.MV_OK)
                {
                    lock (BufForDriverLock2)
                    {
                        if (m_BufForDriver2 == IntPtr.Zero || stFrameInfo.stFrameInfo.nFrameLen > m_nBufSizeForDriver2)
                        {
                            if (m_BufForDriver2 != IntPtr.Zero)
                            {
                                Marshal.Release(m_BufForDriver2);
                                m_BufForDriver2 = IntPtr.Zero;
                            }

                            m_BufForDriver2 = Marshal.AllocHGlobal((Int32)stFrameInfo.stFrameInfo.nFrameLen);
                            if (m_BufForDriver2 == IntPtr.Zero)
                            {
                                return;
                            }
                            m_nBufSizeForDriver2 = stFrameInfo.stFrameInfo.nFrameLen;
                        }

                        m_stFrameInfo2 = stFrameInfo.stFrameInfo;
                        CopyMemory(m_BufForDriver2, stFrameInfo.pBufAddr, stFrameInfo.stFrameInfo.nFrameLen);

                        stConvertInfo.nWidth = stFrameInfo.stFrameInfo.nWidth;
                        stConvertInfo.nHeight = stFrameInfo.stFrameInfo.nHeight;
                        stConvertInfo.enSrcPixelType = stFrameInfo.stFrameInfo.enPixelType;
                        stConvertInfo.pSrcData = stFrameInfo.pBufAddr;
                        stConvertInfo.nSrcDataLen = stFrameInfo.stFrameInfo.nFrameLen;
                        stConvertInfo.pDstBuffer = m_ConvertDstBuf2;
                        stConvertInfo.nDstBufferSize = m_nConvertDstBufLen2;
                        if (PixelFormat.Format8bppIndexed == m_bitmap2.PixelFormat)
                        {
                            stConvertInfo.enDstPixelType = MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono8;
                            m_MyCamera2.MV_CC_ConvertPixelType_NET(ref stConvertInfo);
                        }
                        else
                        {
                            stConvertInfo.enDstPixelType = MyCamera.MvGvspPixelType.PixelType_Gvsp_BGR8_Packed;
                            m_MyCamera2.MV_CC_ConvertPixelType_NET(ref stConvertInfo);
                        }

                        BitmapData bmpData = m_bitmap2.LockBits(new Rectangle(0, 0, stConvertInfo.nWidth, stConvertInfo.nHeight),
                            ImageLockMode.ReadWrite, m_bitmap2.PixelFormat);
                        CopyMemory(bmpData.Scan0, stConvertInfo.pDstBuffer, (UInt32)(bmpData.Stride * m_bitmap2.Height));
                        m_bitmap2.UnlockBits(bmpData);

                        if (IsImageProceee2)
                        {
                            Mat mat = OpenCvSharp.Extensions.BitmapConverter.ToMat(m_bitmap2);
                            ProcessAndDisplayImageAsync2(mat);
                        }
                    }

                    stDisplayInfo.hWnd = pictureBox3.Handle;
                    stDisplayInfo.pData = stFrameInfo.pBufAddr;
                    stDisplayInfo.nDataLen = stFrameInfo.stFrameInfo.nFrameLen;
                    stDisplayInfo.nWidth = stFrameInfo.stFrameInfo.nWidth;
                    stDisplayInfo.nHeight = stFrameInfo.stFrameInfo.nHeight;
                    stDisplayInfo.enPixelType = stFrameInfo.stFrameInfo.enPixelType;
                    m_MyCamera2.MV_CC_DisplayOneFrame_NET(ref stDisplayInfo);

                    m_MyCamera2.MV_CC_FreeImageBuffer_NET(ref stFrameInfo);
                }
                else
                {
                    if (bnTriggerMode2.Checked)
                    {
                        Thread.Sleep(5);
                    }
                }
            }
        }
        
        // 由marker推算cube位姿
        private (double X, double Y, double Z, double Roll, double Pitch, double Yaw) EstimateCubePoseFromMarker(int markerId, Mat rvec, Mat tvec)
        {
            try
            {
                if (!markerTransforms.ContainsKey(markerId))
                    return (0, 0, 0, 0, 0, 0);

                // 获取marker的位姿
                using (var rotMat = new Mat())
                {
                    // 将旋转向量转换为旋转矩阵
                    Cv2.Rodrigues(rvec, rotMat);

                    // 获取平移参数
                    double x = tvec.Get<double>(0);
                    double y = tvec.Get<double>(1);
                    double z = tvec.Get<double>(2);

                    // 计算欧拉角
                    double roll = Math.Atan2(rotMat.At<double>(2, 1), rotMat.At<double>(2, 2));
                    double pitch = Math.Atan2(-rotMat.At<double>(2, 0),
                        Math.Sqrt(rotMat.At<double>(2, 1) * rotMat.At<double>(2, 1) +
                                 rotMat.At<double>(2, 2) * rotMat.At<double>(2, 2)));
                    double yaw = Math.Atan2(rotMat.At<double>(1, 0), rotMat.At<double>(0, 0));

                    // 转换为角度
                    roll = roll * 180.0 / Math.PI;
                    pitch = pitch * 180.0 / Math.PI;
                    yaw = yaw * 180.0 / Math.PI;

                    // 根据marker的ID计算补偿变换
                    switch (markerId)
                    {
                        case 1: // 前面
                                // 无需转换，与立方体坐标系一致
                            z -= CUBE_SIZE / 2;
                            break;

                        case 3: // 后面
                            x = -x;
                            z += CUBE_SIZE / 2;
                            yaw += 180;
                            break;

                        case 5: // 右面
                            double tempX = x;
                            x = z - CUBE_SIZE / 2;
                            z = -tempX;
                            yaw += 90;
                            break;

                        case 7: // 左面
                            tempX = x;
                            x = -(z - CUBE_SIZE / 2);
                            z = tempX;
                            yaw -= 90;
                            break;

                        case 9: // 下面
                            double tempY = y;
                            y = z + CUBE_SIZE / 2;
                            z = tempY;
                            roll += 90;
                            break;
                    }

                    // 标准化角度到 -180 到 180 度范围
                    roll = NormalizeAngle(roll);
                    pitch = NormalizeAngle(pitch);
                    yaw = NormalizeAngle(yaw);

                    return (x, y, z, roll, pitch, yaw);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error in EstimateCubePoseFromMarker: {ex.Message}");
                return (0, 0, 0, 0, 0, 0);
            }
        }

        // 辅助方法：将角度标准化到 -180 到 180 度范围
        private double NormalizeAngle(double angle)
        {
            angle = angle % 360;
            if (angle > 180)
                angle -= 360;
            else if (angle < -180)
                angle += 360;
            return angle;
        }


        // 新增的 ArUco 检测相关代码
        private Mat ProcessImage1(Mat image, out Mat grayImage, out float CenterX, out float CenterY,
            out float Roll, out float Pitch, out float Yaw) 
        {
            CenterX = 0;
            CenterY = 0;
            Roll = 0;    // 初始化姿态角度
            Pitch = 0;
            Yaw = 0;

            grayImage = new Mat();
            Cv2.CvtColor(image, grayImage, ColorConversionCodes.BGR2GRAY);
            Mat outputImage = image.Clone();
            try
            {
                var dictionary = CvAruco.GetPredefinedDictionary(PredefinedDictionaryName.Dict5X5_250);
                var parameters = new DetectorParameters();
                Point2f[][] rejectedCorners;
                CvAruco.DetectMarkers(
                    grayImage,
                    dictionary,
                    out Point2f[][] corners,
                    out int[] ids,
                    parameters,
                    out rejectedCorners
                );
                if (ids != null && ids.Length > 0)
                {
                    CvAruco.DrawDetectedMarkers(outputImage, corners, ids);
                    var markersWithArea = Enumerable.Range(0, ids.Length)
                        .Select(i => new
                        {
                            Id = ids[i],
                            Corners = corners[i],
                            Area = CalculateMarkerArea(corners[i])
                        })
                        .OrderByDescending(m => m.Area)
                        .ToList();

                    var bestMarker = markersWithArea[0];
                    using (var rvec = new Mat())
                    using (var tvec = new Mat())
                    {
                        Point3f[] objectPoints = new Point3f[]
                        {
                    new Point3f(-MARKER_SIZE/2, MARKER_SIZE/2, 0),
                    new Point3f(MARKER_SIZE/2, MARKER_SIZE/2, 0),
                    new Point3f(MARKER_SIZE/2, -MARKER_SIZE/2, 0),
                    new Point3f(-MARKER_SIZE/2, -MARKER_SIZE/2, 0)
                        };

                        Cv2.SolvePnP(
                            InputArray.Create(objectPoints),
                            InputArray.Create(bestMarker.Corners),
                            cameraMatrix,
                            distCoeffs,
                            rvec,
                            tvec
                        );

                        // 获取立方体位姿
                        var cubePose = EstimateCubePoseFromMarker(bestMarker.Id, rvec, tvec);

                        // 更新姿态角度
                        Roll = (float)cubePose.Roll;
                        Pitch = (float)cubePose.Pitch;
                        Yaw = (float)cubePose.Yaw;

                        var (centerX, centerY) = EstimateCubeCenterFromMarker(
                            bestMarker.Id, bestMarker.Corners, rvec, tvec);
                        CenterX = centerX;
                        CenterY = centerY;
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error in image processing: {ex.Message}");
            }
            return outputImage;
        }
        private Mat ProcessImage2(Mat image, out Mat grayImage, out float CenterX, out float CenterY,
            out float Roll, out float Pitch, out float Yaw)  // 新增三个输出参数
        {
            CenterX = 0;
            CenterY = 0;
            Roll = 0;    // 初始化姿态角度
            Pitch = 0;
            Yaw = 0;

            grayImage = new Mat();
            Cv2.CvtColor(image, grayImage, ColorConversionCodes.BGR2GRAY);
            Mat outputImage = image.Clone();
            try
            {
                var dictionary = CvAruco.GetPredefinedDictionary(PredefinedDictionaryName.Dict5X5_250);
                var parameters = new DetectorParameters();
                Point2f[][] rejectedCorners;
                CvAruco.DetectMarkers(
                    grayImage,
                    dictionary,
                    out Point2f[][] corners,
                    out int[] ids,
                    parameters,
                    out rejectedCorners
                );
                if (ids != null && ids.Length > 0)
                {
                    CvAruco.DrawDetectedMarkers(outputImage, corners, ids);
                    var markersWithArea = Enumerable.Range(0, ids.Length)
                        .Select(i => new
                        {
                            Id = ids[i],
                            Corners = corners[i],
                            Area = CalculateMarkerArea(corners[i])
                        })
                        .OrderByDescending(m => m.Area)
                        .ToList();

                    var bestMarker = markersWithArea[0];
                    using (var rvec = new Mat())
                    using (var tvec = new Mat())
                    {
                        Point3f[] objectPoints = new Point3f[]
                        {
                    new Point3f(-MARKER_SIZE/2, MARKER_SIZE/2, 0),
                    new Point3f(MARKER_SIZE/2, MARKER_SIZE/2, 0),
                    new Point3f(MARKER_SIZE/2, -MARKER_SIZE/2, 0),
                    new Point3f(-MARKER_SIZE/2, -MARKER_SIZE/2, 0)
                        };

                        Cv2.SolvePnP(
                            InputArray.Create(objectPoints),
                            InputArray.Create(bestMarker.Corners),
                            cameraMatrix,
                            distCoeffs,
                            rvec,
                            tvec
                        );

                        // 获取立方体位姿
                        var cubePose = EstimateCubePoseFromMarker(bestMarker.Id, rvec, tvec);

                        // 更新姿态角度
                        Roll = (float)cubePose.Roll;
                        Pitch = (float)cubePose.Pitch;
                        Yaw = (float)cubePose.Yaw;

                        var (centerX, centerY) = EstimateCubeCenterFromMarker(
                            bestMarker.Id, bestMarker.Corners, rvec, tvec);
                        CenterX = centerX;
                        CenterY = centerY;
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error in image processing: {ex.Message}");
            }
            return outputImage;
        }
        private void ProcessCircleCenters(float X1, float Y1, float X2, float Y2)
        {
            float X1D = (1536 - X1) / 7680;
            float X2D = (1536 - X2) / 7680;
            float Y1D = (1024 - Y1) / 7680;

            currentCubeInfo.Position = (
                ((((45 * X1D * X2D) + (45 * X2D)) / (1 + X1D * X2D)) + 12),
                (((45 - currentCubeInfo.Position.X) * X1D) + 11),
                (((45 - currentCubeInfo.Position.X) * Y1D) + 7)
            );

            string positionText =
                $"Cube Information:\n\n" +
                $"Position (mm):\n" +
                $"X = {currentCubeInfo.Position.X:F2}\n" +
                $"Y = {currentCubeInfo.Position.Y:F2}\n" +
                $"Z = {currentCubeInfo.Position.Z:F2}\n\n" +
                $"Rotation (deg):\n" +
                $"Roll = {currentCubeInfo.Rotation.Roll:F2}\n" +
                $"Pitch = {currentCubeInfo.Rotation.Pitch:F2}\n" +
                $"Yaw = {currentCubeInfo.Rotation.Yaw:F2}";

            UpdateTextBox3(positionText);
        }


        // 异步图像处理相关方法

        private void ProcessAndDisplayImageAsync(Mat mat)
        {
            Task.Run(() =>
            {
                Mat grayImage;
                float X, Y;
                float Roll, Pitch, Yaw;  // 添加姿态角度变量
                Mat processedImage = ProcessImage1(mat, out grayImage, out X, out Y,
                    out Roll, out Pitch, out Yaw);  // 更新方法调用

                // 应用平滑处理
                var smoothedPosition = smoothingFilters[0].UpdateAndGetSmoothedPosition(X, Y);
                X = smoothedPosition.X;
                Y = smoothedPosition.Y;

                lock (syncLock)
                {
                    cubeCenters[0] = (X, Y);
                    currentCubeInfo.Rotation = (Roll, Pitch, Yaw);  // 更新姿态信息

                    if (cubeCenters[0].HasValue && cubeCenters[1].HasValue)
                    {
                        var center1 = cubeCenters[0].Value;
                        var center2 = cubeCenters[1].Value;

                        ProcessCircleCenters(
                            center1.X, center1.Y,
                            center2.X, center2.Y);

                        cubeCenters[0] = null;
                        cubeCenters[1] = null;
                    }
                }

                this.Invoke((Action)(() =>
                {
                    string info = $"Marker Information:\n" +   
                                 $"Position: X={X:F2}, Y={Y:F2}\n" +
                                 $"Rotation: Roll={Roll:F2}, Pitch={Pitch:F2}, Yaw={Yaw:F2}";
                    txt_Test.Text = info; 
                    pictureBox2.Image = OpenCvSharp.Extensions.BitmapConverter.ToBitmap(processedImage);
                }));
            });
        }

        private void ProcessAndDisplayImageAsync2 (Mat mat)
        {
            Task.Run(() =>
            {
                Mat grayImage2;
                float X2, Y2;
                float Roll2, Pitch2, Yaw2;  // 添加姿态角度变量
                Mat processedImage2 = ProcessImage2(mat, out grayImage2, out X2, out Y2,
                    out Roll2, out Pitch2, out Yaw2);  // 更新方法调用

                // 应用平滑处理
                var smoothedPosition2 = smoothingFilters[0].UpdateAndGetSmoothedPosition(X2, Y2);
                X2 = smoothedPosition2.X;
                Y2 = smoothedPosition2.Y;

                lock (syncLock)
                {
                    cubeCenters[1] = (X2, Y2);
                    currentCubeInfo.Rotation = (Roll2, Pitch2, Yaw2);  // 更新姿态信息

                    if (cubeCenters[0].HasValue && cubeCenters[1].HasValue)
                    {
                        var center1 = cubeCenters[0].Value;
                        var center2 = cubeCenters[1].Value;

                        ProcessCircleCenters(
                            center1.X, center1.Y,
                            center2.X, center2.Y);

                        cubeCenters[0] = null;
                        cubeCenters[1] = null;
                    }
                }

                this.Invoke((Action)(() =>
                {
                    string info2 = $"Marker Information:\n" +
                                 $"Position: X={X2:F2}, Y={Y2:F2}\n" +
                                 $"Rotation: Roll={Roll2:F2}, Pitch={Pitch2:F2}, Yaw={Yaw2:F2}";
                    txt_Test2.Text = info2;
                    pictureBox4.Image = OpenCvSharp.Extensions.BitmapConverter.ToBitmap(processedImage2);
                }));
            });
        }



        // 触发模式相关方法
        private void bnContinuesMode_CheckedChanged(object sender, EventArgs e)
        {
            if (bnContinuesMode.Checked)
            {
                m_MyCamera.MV_CC_SetEnumValue_NET("TriggerMode", (uint)MyCamera.MV_CAM_TRIGGER_MODE.MV_TRIGGER_MODE_OFF);
                cbSoftTrigger.Enabled = false;
                bnTriggerExec.Enabled = false;
            }
        }

        private void bnTriggerMode_CheckedChanged(object sender, EventArgs e)
        {
            if (bnTriggerMode.Checked)
            {
                m_MyCamera.MV_CC_SetEnumValue_NET("TriggerMode", (uint)MyCamera.MV_CAM_TRIGGER_MODE.MV_TRIGGER_MODE_ON);

                if (cbSoftTrigger.Checked)
                {
                    m_MyCamera.MV_CC_SetEnumValue_NET("TriggerSource", (uint)MyCamera.MV_CAM_TRIGGER_SOURCE.MV_TRIGGER_SOURCE_SOFTWARE);
                    if (m_bGrabbing)
                    {
                        bnTriggerExec.Enabled = true;
                    }
                }
                else
                {
                    m_MyCamera.MV_CC_SetEnumValue_NET("TriggerSource", (uint)MyCamera.MV_CAM_TRIGGER_SOURCE.MV_TRIGGER_SOURCE_LINE0);
                }
                cbSoftTrigger.Enabled = true;
            }
        }

        // 软触发相关功能
        private void btn_Trigger_Click(object sender, EventArgs e)
        {
            int nRet = m_MyCamera.MV_CC_SetCommandValue_NET("TriggerSoftware");
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Trigger Software Fail!", nRet);
            }
            int nRet2 = m_MyCamera2.MV_CC_SetCommandValue_NET("TriggerSoftware");
            if (MyCamera.MV_OK != nRet2)
            {
                ShowErrorMsg("Trigger Software Fail!", nRet2);
            }
        }

        private void SoftTrigger()
        {
            while (IsTrigger)
            {
                int nRet = m_MyCamera.MV_CC_SetCommandValue_NET("TriggerSoftware");
                if (MyCamera.MV_OK != nRet)
                {
                    ShowErrorMsg("Trigger Software Fail!", nRet);
                }
                int nRet2 = m_MyCamera2.MV_CC_SetCommandValue_NET("TriggerSoftware");
                if (MyCamera.MV_OK != nRet2)
                {
                    ShowErrorMsg("Trigger Software Fail!", nRet2);
                }

                Thread.Sleep(100);
            }
        }

        // UI更新相关方法
        private void UpdateTextBox(string text)
        {
            if (txt_Test.InvokeRequired)
            {
                txt_Test.Invoke(new Action<string>(UpdateTextBox), text);
            }
            else
            {
                txt_Test.AppendText(text + Environment.NewLine);
                txt_Test.SelectionStart = txt_Test.Text.Length;
                txt_Test.ScrollToCaret();
            }
        }

        private void UpdateTextBox2(string text)
        {
            if (txt_Test2.InvokeRequired)
            {
                txt_Test2.Invoke(new Action<string>(UpdateTextBox2), text);
            }
            else
            {
                txt_Test2.AppendText(text + Environment.NewLine);
                txt_Test2.SelectionStart = txt_Test2.Text.Length;
                txt_Test2.ScrollToCaret();
            }
        }

        private void UpdateTextBox3(string text)
        {
            if (txt_Test3.InvokeRequired)
            {
                txt_Test3.Invoke(new Action<string>(UpdateTextBox3), text);
            }
            else
            {
                txt_Test3.AppendText(text + Environment.NewLine);
                txt_Test3.SelectionStart = txt_Test3.Text.Length;
                txt_Test3.ScrollToCaret();
            }
        }

        // 资源释放
        protected override void OnFormClosing(FormClosingEventArgs e)
        {
            base.OnFormClosing(e);

            // 释放OpenCV相关资源
            cameraMatrix?.Dispose();
            distCoeffs?.Dispose();

            // 关闭相机
            if (m_MyCamera != null)
            {
                m_MyCamera.MV_CC_CloseDevice_NET();
                m_MyCamera.MV_CC_DestroyDevice_NET();
            }

            if (m_MyCamera2 != null)
            {
                m_MyCamera2.MV_CC_CloseDevice_NET();
                m_MyCamera2.MV_CC_DestroyDevice_NET();
            }
        }

        // 图像处理标志位相关
        private void cbImageProcess_CheckedChanged(object sender, EventArgs e)
        {
            IsImageProceee = cbImageProcess.Checked;
            if (!IsImageProceee)
            {
                smoothingFilters[0].Reset();
            }
        }

        private void cbImageProcess2_CheckedChanged(object sender, EventArgs e)
        {
            IsImageProceee2 = cbImageProcess2.Checked;
            if (!IsImageProceee2)
            {
                smoothingFilters[1].Reset();
            }
        }

        // 软触发相关
        private void bnTriggerExec_Click(object sender, EventArgs e)
        {
            int nRet = m_MyCamera.MV_CC_SetCommandValue_NET("TriggerSoftware");
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("触发软件失败!", nRet);
            }
        }

        private void bnTriggerExec2_Click(object sender, EventArgs e)
        {
            int nRet = m_MyCamera2.MV_CC_SetCommandValue_NET("TriggerSoftware");
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("触发软件失败!", nRet);
            }
        }

        // 软触发选项变更
        private void cbSoftTrigger_CheckedChanged(object sender, EventArgs e)
        {
            if (cbSoftTrigger.Checked)
            {
                m_MyCamera.MV_CC_SetEnumValue_NET("TriggerSource", (uint)MyCamera.MV_CAM_TRIGGER_SOURCE.MV_TRIGGER_SOURCE_SOFTWARE);
                if (m_bGrabbing && bnTriggerMode.Checked)
                {
                    bnTriggerExec.Enabled = true;
                    btn_Trigger.Enabled = true;
                    button1.Enabled = true;
                    button2.Enabled = true;
                }
            }
            else
            {
                m_MyCamera.MV_CC_SetEnumValue_NET("TriggerSource", (uint)MyCamera.MV_CAM_TRIGGER_SOURCE.MV_TRIGGER_SOURCE_LINE0);
                bnTriggerExec.Enabled = false;
                btn_Trigger.Enabled = false;
                button1.Enabled = false;
                button2.Enabled = false;
            }
        }

        private void cbSoftTrigger2_CheckedChanged(object sender, EventArgs e)
        {
            if (cbSoftTrigger2.Checked)
            {
                m_MyCamera2.MV_CC_SetEnumValue_NET("TriggerSource", (uint)MyCamera.MV_CAM_TRIGGER_SOURCE.MV_TRIGGER_SOURCE_SOFTWARE);
                if (m_bGrabbing2 && bnTriggerMode2.Checked)
                {
                    bnTriggerExec2.Enabled = true;
                }
            }
            else
            {
                m_MyCamera2.MV_CC_SetEnumValue_NET("TriggerSource", (uint)MyCamera.MV_CAM_TRIGGER_SOURCE.MV_TRIGGER_SOURCE_LINE0);
                bnTriggerExec2.Enabled = false;
            }
        }

        // 触发模式变更
        private void bnTriggerMode2_CheckedChanged(object sender, EventArgs e)
        {
            if (bnTriggerMode2.Checked)
            {
                m_MyCamera2.MV_CC_SetEnumValue_NET("TriggerMode", (uint)MyCamera.MV_CAM_TRIGGER_MODE.MV_TRIGGER_MODE_ON);
                cbSoftTrigger2.Enabled = true;
                if (cbSoftTrigger2.Checked)
                {
                    m_MyCamera2.MV_CC_SetEnumValue_NET("TriggerSource", (uint)MyCamera.MV_CAM_TRIGGER_SOURCE.MV_TRIGGER_SOURCE_SOFTWARE);
                    if (m_bGrabbing2)
                    {
                        bnTriggerExec2.Enabled = true;
                    }
                }
            }
        }

        // 连续模式变更
        private void bnContinuesMode2_CheckedChanged(object sender, EventArgs e)
        {
            if (bnContinuesMode2.Checked)
            {
                m_MyCamera2.MV_CC_SetEnumValue_NET("TriggerMode", (uint)MyCamera.MV_CAM_TRIGGER_MODE.MV_TRIGGER_MODE_OFF);
                cbSoftTrigger2.Enabled = false;
                bnTriggerExec2.Enabled = false;
            }
        }

        // 文本框相关
        private void txt_Test_TextChanged(object sender, EventArgs e)
        {
        }

        private void txt_Test2_TextChanged(object sender, EventArgs e)
        {
        }

        // 按钮事件
        private void btn_Tset_Click(object sender, EventArgs e)
        {
            // 测试按钮功能实现  
        }

        private void button1_Click(object sender, EventArgs e)
        {
            // 开启持续软触发
            IsTrigger = true;
            TriggerThread = new Thread(SoftTrigger);
            TriggerThread.Start();
        }

        private void button2_Click(object sender, EventArgs e)
        {
            // 关闭持续软触发
            IsTrigger = false;
            TriggerThread.Join();
        }

        private void txt_Test2_TextChanged_1(object sender, EventArgs e)
        {

        }

        private void pictureBox2_Click(object sender, EventArgs e)
        {

        }

        private void pictureBox4_Click(object sender, EventArgs e)
        {

        }
    } // class Form1 结束


} // namespace 结束                                                                                                                                                                                 
