using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using MvCamCtrl;
using MvCamCtrl.NET;
using System.Threading;
using System.Runtime.InteropServices;
using System.Text.RegularExpressions;
using System.Drawing.Imaging;
using System.IO;
using System.Diagnostics;
using System.Collections.ObjectModel;
using OpenCvSharp;
using System.Numerics;
using OpenCvSharp.Aruco;
using Point = OpenCvSharp.Point;


namespace 海康威视图像采集及处理
{
    public partial class Form1 : Form
    {
        // DLL导入
        [DllImport("kernel32.dll", EntryPoint = "RtlMoveMemory", SetLastError = false)]
        private static extern void CopyMemory(IntPtr dest, IntPtr src, uint count);

        // 常量定义
        public const Int32 CUSTOMER_PIXEL_FORMAT = unchecked((Int32)0x80000000);

        // 相机1相关变量
        MyCamera.MV_CC_DEVICE_INFO_LIST m_stDeviceList = new MyCamera.MV_CC_DEVICE_INFO_LIST();
        private MyCamera m_MyCamera = new MyCamera();
        bool m_bGrabbing = false;
        Thread m_hReceiveThread = null;
        MyCamera.MV_FRAME_OUT_INFO_EX m_stFrameInfo = new MyCamera.MV_FRAME_OUT_INFO_EX();

        // 相机2相关变量
        MyCamera.MV_CC_DEVICE_INFO_LIST m_stDeviceList2 = new MyCamera.MV_CC_DEVICE_INFO_LIST();
        private MyCamera m_MyCamera2 = new MyCamera();
        bool m_bGrabbing2 = false;
        Thread m_hReceiveThread2 = null;
        MyCamera.MV_FRAME_OUT_INFO_EX m_stFrameInfo2 = new MyCamera.MV_FRAME_OUT_INFO_EX();

        // 相机1图像缓存相关
        UInt32 m_nBufSizeForDriver = 0;
        IntPtr m_BufForDriver = IntPtr.Zero;
        private static Object BufForDriverLock = new Object();
        Bitmap m_bitmap = null;
        PixelFormat m_bitmapPixelFormat = PixelFormat.DontCare;
        IntPtr m_ConvertDstBuf = IntPtr.Zero;
        UInt32 m_nConvertDstBufLen = 0;

        // 相机2图像缓存相关
        UInt32 m_nBufSizeForDriver2 = 0;
        IntPtr m_BufForDriver2 = IntPtr.Zero;
        private static Object BufForDriverLock2 = new Object();
        Bitmap m_bitmap2 = null;
        PixelFormat m_bitmapPixelFormat2 = PixelFormat.DontCare;
        IntPtr m_ConvertDstBuf2 = IntPtr.Zero;
        UInt32 m_nConvertDstBufLen2 = 0;

        // 图像处理相关变量
        private bool IsImageProceee = false;
        private bool IsImageProceee2 = false;
        private int frameCounter = 0;
        private int frameCounter2 = 0;
        private bool IsTrigger = false;
        Thread TriggerThread = null;
        private object syncLock = new object();

        // ArUco检测相关变量
        private Mat cameraMatrix;
        private Mat distCoeffs;


        // 立方体常量
        private const float CUBE_SIZE = 35.0f;  // 立方体边长
        private const float MARKER_SIZE = 30.0f; // ArUco码边长


        // 存储立方体的当前位姿
        private (float X, float Y)?[] cubeCenters = new (float X, float Y)?[2];
        private class CubeInfo
        {
            public (double X, double Y, double Z) Position;
            public (double Roll, double Pitch, double Yaw) Rotation;
        }
        private CubeInfo currentCubeInfo = new CubeInfo();

        // 修改相机姿态存储变量的定义（在类的成员变量部分）
        private (double X, double Y, double Z, double Roll, double Pitch, double Yaw)? camera1Pose = null;
        private (double X, double Y, double Z, double Roll, double Pitch, double Yaw)? camera2Pose = null;

        // 坐标系相关常量
        private const float CAMERA1_DISTANCE = 450.0f;  // 相机1到原点距离（X轴负方向）
        private const float CAMERA2_DISTANCE = 450.0f;  // 相机2到原点距离（Y轴负方向）

        // 定义Marker相对于立方体中心的变换关系
        private readonly Dictionary<int, (Vector3 offset, Vector3 rotation)> markerTransforms;

 

        //计算marker面积的辅助方法
        private double CalculateMarkerArea(Point2f[] corners)
        {
            double area = 0;
            for (int i = 0; i < 4; i++)
            {
                int j = (i + 1) % 4;
                area += corners[i].X * corners[j].Y - corners[j].X * corners[i].Y;
            }
            return Math.Abs(area) / 2;
        }

        // 添加平滑滤波相关变量
        private class SmoothingFilter
        {
            private const int WINDOW_SIZE = 5;
            private Queue<(float X, float Y)> positionHistory = new Queue<(float X, float Y)>();
            private const float SMOOTHING_FACTOR = 0.5f;
            private (float X, float Y) lastSmoothedPosition = (0, 0);
            private bool hasLastPosition = false;

            public (float X, float Y) UpdateAndGetSmoothedPosition(float newX, float newY)
            {
                positionHistory.Enqueue((newX, newY));
                if (positionHistory.Count > WINDOW_SIZE)
                {
                    positionHistory.Dequeue();
                }

                float avgX = positionHistory.Average(p => p.X);
                float avgY = positionHistory.Average(p => p.Y);

                if (!hasLastPosition)
                {
                    lastSmoothedPosition = (avgX, avgY);
                    hasLastPosition = true;
                    return lastSmoothedPosition;
                }

                float smoothedX = SMOOTHING_FACTOR * lastSmoothedPosition.X + (1 - SMOOTHING_FACTOR) * avgX;
                float smoothedY = SMOOTHING_FACTOR * lastSmoothedPosition.Y + (1 - SMOOTHING_FACTOR) * avgY;

                lastSmoothedPosition = (smoothedX, smoothedY);
                return lastSmoothedPosition;
            }

            public void Reset()
            {
                positionHistory.Clear();
                hasLastPosition = false;
            }
        }

        private SmoothingFilter[] smoothingFilters = new SmoothingFilter[]
        {
        new SmoothingFilter(),
        new SmoothingFilter()
        };

        public Form1()
        {
            InitializeComponent();

            // 初始化marker变换关系

            markerTransforms = new Dictionary<int, (Vector3 offset, Vector3 rotation)>
            {
                // 前面 Marker 1：面向+X
                { 1, (new Vector3(CUBE_SIZE/2, 0, 0),
                      new Vector3(0, 0, 0)) },
    
                // 后面 Marker 3：面向-X
                { 3, (new Vector3(-CUBE_SIZE/2, 0, 0),
                      new Vector3(0, (float)Math.PI, 0)) },
    
                // 右面 Marker 5：面向-Y
                { 5, (new Vector3(0, -CUBE_SIZE/2, 0),
                      new Vector3(0, -(float)Math.PI/2, 0)) },
    
                // 左面 Marker 7：面向+Y
                { 7, (new Vector3(0, CUBE_SIZE/2, 0),
                      new Vector3(0, (float)Math.PI/2, 0)) },
    
                // 底面 Marker 9：面向+Z
                { 9, (new Vector3(0, 0, CUBE_SIZE/2),
                      new Vector3(-(float)Math.PI/2, 0, 0)) }
            };

            Control.CheckForIllegalCrossThreadCalls = false;
            this.Load += new EventHandler(Form1_Load);

            // 初始化相机参数（需要根据实际标定结果修改）
            cameraMatrix = Mat.Eye(3, 3, MatType.CV_64F);
            cameraMatrix.Set<double>(0, 0, 1000.0); // fx
            cameraMatrix.Set<double>(1, 1, 1000.0); // fy
            cameraMatrix.Set<double>(0, 2, 1536 / 2.0); // cx
            cameraMatrix.Set<double>(1, 2, 1024 / 2.0); // cy

            distCoeffs = Mat.Zeros(rows: 1, cols: 5, type: MatType.CV_64F);
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            // 初始化SDK
            MyCamera.MV_CC_Initialize_NET();
            // 枚举设备
            DeviceListAcq();
            DeviceListAcq2();
        }

        // 像素类型是否为Mono格式检查
        private Boolean IsMono(UInt32 enPixelType)
        {
            switch (enPixelType)
            {
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono1p:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono2p:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono4p:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono8:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono8_Signed:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono10:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono10_Packed:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono12:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono12_Packed:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono14:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono16:
                    return true;
                default:
                    return false;
            }
        }

        // 取图前的必要操作
        private Int32 NecessaryOperBeforeGrab()
        {
            // 获取图像宽度
            MyCamera.MVCC_INTVALUE_EX stWidth = new MyCamera.MVCC_INTVALUE_EX();
            int nRet = m_MyCamera.MV_CC_GetIntValueEx_NET("Width", ref stWidth);
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Get Width Info Fail!", nRet);
                return nRet;
            }

            // 获取图像高度
            MyCamera.MVCC_INTVALUE_EX stHeight = new MyCamera.MVCC_INTVALUE_EX();
            nRet = m_MyCamera.MV_CC_GetIntValueEx_NET("Height", ref stHeight);
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Get Height Info Fail!", nRet);
                return nRet;
            }

            // 获取像素格式
            MyCamera.MVCC_ENUMVALUE stPixelFormat = new MyCamera.MVCC_ENUMVALUE();
            nRet = m_MyCamera.MV_CC_GetEnumValue_NET("PixelFormat", ref stPixelFormat);
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Get Pixel Format Fail!", nRet);
                return nRet;
            }

            // 设置bitmap像素格式，分配内存
            if ((Int32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Undefined == (Int32)stPixelFormat.nCurValue)
            {
                ShowErrorMsg("Unknown Pixel Format!", MyCamera.MV_E_UNKNOW);
                return MyCamera.MV_E_UNKNOW;
            }
            else if (IsMono(stPixelFormat.nCurValue))
            {
                m_bitmapPixelFormat = PixelFormat.Format8bppIndexed;

                if (IntPtr.Zero != m_ConvertDstBuf)
                {
                    Marshal.Release(m_ConvertDstBuf);
                    m_ConvertDstBuf = IntPtr.Zero;
                }
                m_nConvertDstBufLen = (UInt32)(stWidth.nCurValue * stHeight.nCurValue);
                m_ConvertDstBuf = Marshal.AllocHGlobal((Int32)m_nConvertDstBufLen);
            }
            else
            {
                m_bitmapPixelFormat = PixelFormat.Format24bppRgb;

                if (IntPtr.Zero != m_ConvertDstBuf)
                {
                    Marshal.FreeHGlobal(m_ConvertDstBuf);
                    m_ConvertDstBuf = IntPtr.Zero;
                }
                m_nConvertDstBufLen = (UInt32)(3 * stWidth.nCurValue * stHeight.nCurValue);
                m_ConvertDstBuf = Marshal.AllocHGlobal((Int32)m_nConvertDstBufLen);
            }

            if (null != m_bitmap)
            {
                m_bitmap.Dispose();
                m_bitmap = null;
            }
            m_bitmap = new Bitmap((Int32)stWidth.nCurValue, (Int32)stHeight.nCurValue, m_bitmapPixelFormat);

            if (PixelFormat.Format8bppIndexed == m_bitmapPixelFormat)
            {
                ColorPalette palette = m_bitmap.Palette;
                for (int i = 0; i < palette.Entries.Length; i++)
                {
                    palette.Entries[i] = Color.FromArgb(i, i, i);
                }
                m_bitmap.Palette = palette;
            }

            return MyCamera.MV_OK;
        }

        // 显示错误信息
        private void ShowErrorMsg(string csMessage, int nErrorNum)
        {
            string errorMsg;
            if (nErrorNum == 0)
            {
                errorMsg = csMessage;
            }
            else
            {
                errorMsg = csMessage + ": Error =" + String.Format("{0:X}", nErrorNum);
            }

            switch (nErrorNum)
            {
                case MyCamera.MV_E_HANDLE: errorMsg += " Error or invalid handle "; break;
                case MyCamera.MV_E_SUPPORT: errorMsg += " Not supported function "; break;
                case MyCamera.MV_E_BUFOVER: errorMsg += " Cache is full "; break;
                case MyCamera.MV_E_CALLORDER: errorMsg += " Function calling order error "; break;
                case MyCamera.MV_E_PARAMETER: errorMsg += " Incorrect parameter "; break;
                case MyCamera.MV_E_RESOURCE: errorMsg += " Applying resource failed "; break;
                case MyCamera.MV_E_NODATA: errorMsg += " No data "; break;
                case MyCamera.MV_E_PRECONDITION: errorMsg += " Precondition error, or running environment changed "; break;
                case MyCamera.MV_E_VERSION: errorMsg += " Version mismatches "; break;
                case MyCamera.MV_E_NOENOUGH_BUF: errorMsg += " Insufficient memory "; break;
                case MyCamera.MV_E_UNKNOW: errorMsg += " Unknown error "; break;
                case MyCamera.MV_E_GC_GENERIC: errorMsg += " General error "; break;
                case MyCamera.MV_E_GC_ACCESS: errorMsg += " Node accessing condition error "; break;
                case MyCamera.MV_E_ACCESS_DENIED: errorMsg += " No permission "; break;
                case MyCamera.MV_E_BUSY: errorMsg += " Device is busy, or network disconnected "; break;
                case MyCamera.MV_E_NETER: errorMsg += " Network error "; break;
            }

            MessageBox.Show(errorMsg, "PROMPT");
        }

        // 用于清理设备名称中的空字符
        private string DeleteTail(string strUserDefinedName)
        {
            strUserDefinedName = Regex.Unescape(strUserDefinedName);
            int nIndex = strUserDefinedName.IndexOf("\0");
            if (nIndex >= 0)
            {
                strUserDefinedName = strUserDefinedName.Remove(nIndex);
            }
            return strUserDefinedName;
        }

        // 取图前的必要操作2
        private Int32 NecessaryOperBeforeGrab2()
        {
            MyCamera.MVCC_INTVALUE_EX stWidth = new MyCamera.MVCC_INTVALUE_EX();
            int nRet = m_MyCamera2.MV_CC_GetIntValueEx_NET("Width", ref stWidth);
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Get Width Info Fail!", nRet);
                return nRet;
            }

            MyCamera.MVCC_INTVALUE_EX stHeight = new MyCamera.MVCC_INTVALUE_EX();
            nRet = m_MyCamera2.MV_CC_GetIntValueEx_NET("Height", ref stHeight);
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Get Height Info Fail!", nRet);
                return nRet;
            }

            MyCamera.MVCC_ENUMVALUE stPixelFormat = new MyCamera.MVCC_ENUMVALUE();
            nRet = m_MyCamera2.MV_CC_GetEnumValue_NET("PixelFormat", ref stPixelFormat);
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Get Pixel Format Fail!", nRet);
                return nRet;
            }

            if ((Int32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Undefined == (Int32)stPixelFormat.nCurValue)
            {
                ShowErrorMsg("Unknown Pixel Format!", MyCamera.MV_E_UNKNOW);
                return MyCamera.MV_E_UNKNOW;
            }
            else if (IsMono(stPixelFormat.nCurValue))
            {
                m_bitmapPixelFormat2 = PixelFormat.Format8bppIndexed;

                if (IntPtr.Zero != m_ConvertDstBuf2)
                {
                    Marshal.Release(m_ConvertDstBuf2);
                    m_ConvertDstBuf2 = IntPtr.Zero;
                }
                m_nConvertDstBufLen2 = (UInt32)(stWidth.nCurValue * stHeight.nCurValue);
                m_ConvertDstBuf2 = Marshal.AllocHGlobal((Int32)m_nConvertDstBufLen2);
            }
            else
            {
                m_bitmapPixelFormat2 = PixelFormat.Format24bppRgb;

                if (IntPtr.Zero != m_ConvertDstBuf2)
                {
                    Marshal.FreeHGlobal(m_ConvertDstBuf2);
                    m_ConvertDstBuf2 = IntPtr.Zero;
                }
                m_nConvertDstBufLen2 = (UInt32)(3 * stWidth.nCurValue * stHeight.nCurValue);
                m_ConvertDstBuf2 = Marshal.AllocHGlobal((Int32)m_nConvertDstBufLen2);
            }

            if (null != m_bitmap2)
            {
                m_bitmap2.Dispose();
                m_bitmap2 = null;
            }
            m_bitmap2 = new Bitmap((Int32)stWidth.nCurValue, (Int32)stHeight.nCurValue, m_bitmapPixelFormat2);

            if (PixelFormat.Format8bppIndexed == m_bitmapPixelFormat2)
            {
                ColorPalette palette = m_bitmap2.Palette;
                for (int i = 0; i < palette.Entries.Length; i++)
                {
                    palette.Entries[i] = Color.FromArgb(i, i, i);
                }
                m_bitmap2.Palette = palette;
            }

            return MyCamera.MV_OK;
        }

        // 设备枚举相关方法
        private void btn_Enum_Click(object sender, EventArgs e)
        {
            DeviceListAcq();
        }

        private void btn_Enum2_Click(object sender, EventArgs e)
        {
            DeviceListAcq2();
        }

        private void DeviceListAcq()
        {
            System.GC.Collect();
            cbDeviceList.Items.Clear();
            m_stDeviceList.nDeviceNum = 0;

            int nRet = MyCamera.MV_CC_EnumDevices_NET(MyCamera.MV_GIGE_DEVICE | MyCamera.MV_USB_DEVICE | MyCamera.MV_GENTL_GIGE_DEVICE
                | MyCamera.MV_GENTL_CAMERALINK_DEVICE | MyCamera.MV_GENTL_CXP_DEVICE | MyCamera.MV_GENTL_XOF_DEVICE, ref m_stDeviceList);

            if (0 != nRet)
            {
                ShowErrorMsg("Enumerate devices fail!", 0);
                return;
            }

            // 在窗体列表中显示设备名
            for (int i = 0; i < m_stDeviceList.nDeviceNum; i++)
            {
                MyCamera.MV_CC_DEVICE_INFO device = (MyCamera.MV_CC_DEVICE_INFO)Marshal.PtrToStructure(m_stDeviceList.pDeviceInfo[i], typeof(MyCamera.MV_CC_DEVICE_INFO));
                string strUserDefinedName = "";

                if (device.nTLayerType == MyCamera.MV_GIGE_DEVICE)
                {
                    MyCamera.MV_GIGE_DEVICE_INFO_EX gigeInfo = (MyCamera.MV_GIGE_DEVICE_INFO_EX)MyCamera.ByteToStruct(device.SpecialInfo.stGigEInfo, typeof(MyCamera.MV_GIGE_DEVICE_INFO_EX));

                    if ((gigeInfo.chUserDefinedName.Length > 0) && (gigeInfo.chUserDefinedName[0] != '\0'))
                    {
                        if (MyCamera.IsTextUTF8(gigeInfo.chUserDefinedName))
                            strUserDefinedName = Encoding.UTF8.GetString(gigeInfo.chUserDefinedName).TrimEnd('\0');
                        else
                            strUserDefinedName = Encoding.Default.GetString(gigeInfo.chUserDefinedName).TrimEnd('\0');
                        cbDeviceList.Items.Add("GEV: " + DeleteTail(strUserDefinedName) + " (" + gigeInfo.chSerialNumber + ")");
                    }
                    else
                    {
                        cbDeviceList.Items.Add("GEV: " + gigeInfo.chManufacturerName + " " + gigeInfo.chModelName + " (" + gigeInfo.chSerialNumber + ")");
                    }
                }
                else if (device.nTLayerType == MyCamera.MV_USB_DEVICE)
                {
                    MyCamera.MV_USB3_DEVICE_INFO_EX usbInfo = (MyCamera.MV_USB3_DEVICE_INFO_EX)MyCamera.ByteToStruct(device.SpecialInfo.stUsb3VInfo, typeof(MyCamera.MV_USB3_DEVICE_INFO_EX));

                    if ((usbInfo.chUserDefinedName.Length > 0) && (usbInfo.chUserDefinedName[0] != '\0'))
                    {
                        if (MyCamera.IsTextUTF8(usbInfo.chUserDefinedName))
                            strUserDefinedName = Encoding.UTF8.GetString(usbInfo.chUserDefinedName).TrimEnd('\0');
                        else
                            strUserDefinedName = Encoding.Default.GetString(usbInfo.chUserDefinedName).TrimEnd('\0');
                        cbDeviceList.Items.Add("U3V: " + DeleteTail(strUserDefinedName) + " (" + usbInfo.chSerialNumber + ")");
                    }
                    else
                    {
                        cbDeviceList.Items.Add("U3V: " + usbInfo.chManufacturerName + " " + usbInfo.chModelName + " (" + usbInfo.chSerialNumber + ")");
                    }
                }
            }

            if (m_stDeviceList.nDeviceNum != 0)
            {
                cbDeviceList.SelectedIndex = 0;
            }
        }

        private void DeviceListAcq2()
        {
            System.GC.Collect();
            cbDeviceList2.Items.Clear();
            m_stDeviceList2.nDeviceNum = 0;

            int nRet = MyCamera.MV_CC_EnumDevices_NET(MyCamera.MV_GIGE_DEVICE | MyCamera.MV_USB_DEVICE | MyCamera.MV_GENTL_GIGE_DEVICE
                | MyCamera.MV_GENTL_CAMERALINK_DEVICE | MyCamera.MV_GENTL_CXP_DEVICE | MyCamera.MV_GENTL_XOF_DEVICE, ref m_stDeviceList2);

            if (0 != nRet)
            {
                ShowErrorMsg("Enumerate devices fail!", 0);
                return;
            }

            // 在窗体列表中显示设备名
            for (int i = 0; i < m_stDeviceList2.nDeviceNum; i++)
            {
                MyCamera.MV_CC_DEVICE_INFO device = (MyCamera.MV_CC_DEVICE_INFO)Marshal.PtrToStructure(m_stDeviceList2.pDeviceInfo[i], typeof(MyCamera.MV_CC_DEVICE_INFO));
                string strUserDefinedName = "";

                if (device.nTLayerType == MyCamera.MV_GIGE_DEVICE)
                {
                    MyCamera.MV_GIGE_DEVICE_INFO_EX gigeInfo = (MyCamera.MV_GIGE_DEVICE_INFO_EX)MyCamera.ByteToStruct(device.SpecialInfo.stGigEInfo, typeof(MyCamera.MV_GIGE_DEVICE_INFO_EX));

                    if ((gigeInfo.chUserDefinedName.Length > 0) && (gigeInfo.chUserDefinedName[0] != '\0'))
                    {
                        if (MyCamera.IsTextUTF8(gigeInfo.chUserDefinedName))
                            strUserDefinedName = Encoding.UTF8.GetString(gigeInfo.chUserDefinedName).TrimEnd('\0');
                        else
                            strUserDefinedName = Encoding.Default.GetString(gigeInfo.chUserDefinedName).TrimEnd('\0');
                        cbDeviceList2.Items.Add("GEV: " + DeleteTail(strUserDefinedName) + " (" + gigeInfo.chSerialNumber + ")");
                    }
                    else
                    {
                        cbDeviceList2.Items.Add("GEV: " + gigeInfo.chManufacturerName + " " + gigeInfo.chModelName + " (" + gigeInfo.chSerialNumber + ")");
                    }
                }
                else if (device.nTLayerType == MyCamera.MV_USB_DEVICE)
                {
                    MyCamera.MV_USB3_DEVICE_INFO_EX usbInfo = (MyCamera.MV_USB3_DEVICE_INFO_EX)MyCamera.ByteToStruct(device.SpecialInfo.stUsb3VInfo, typeof(MyCamera.MV_USB3_DEVICE_INFO_EX));

                    if ((usbInfo.chUserDefinedName.Length > 0) && (usbInfo.chUserDefinedName[0] != '\0'))
                    {
                        if (MyCamera.IsTextUTF8(usbInfo.chUserDefinedName))
                            strUserDefinedName = Encoding.UTF8.GetString(usbInfo.chUserDefinedName).TrimEnd('\0');
                        else
                            strUserDefinedName = Encoding.Default.GetString(usbInfo.chUserDefinedName).TrimEnd('\0');
                        cbDeviceList2.Items.Add("U3V: " + DeleteTail(strUserDefinedName) + " (" + usbInfo.chSerialNumber + ")");
                    }
                    else
                    {
                        cbDeviceList2.Items.Add("U3V: " + usbInfo.chManufacturerName + " " + usbInfo.chModelName + " (" + usbInfo.chSerialNumber + ")");
                    }
                }
            }

            if (m_stDeviceList2.nDeviceNum != 0)
            {
                cbDeviceList2.SelectedIndex = 0;
            }
        }

        // 设备打开关闭相关方法
        private void btn_OpenDevice_Click(object sender, EventArgs e)
        {
            if (m_stDeviceList.nDeviceNum == 0 || cbDeviceList.SelectedIndex == -1)
            {
                ShowErrorMsg("No device, please select", 0);
                return;
            }

            MyCamera.MV_CC_DEVICE_INFO device =
                (MyCamera.MV_CC_DEVICE_INFO)Marshal.PtrToStructure(m_stDeviceList.pDeviceInfo[cbDeviceList.SelectedIndex],
                                                              typeof(MyCamera.MV_CC_DEVICE_INFO));

            if (null == m_MyCamera)
            {
                m_MyCamera = new MyCamera();
                if (null == m_MyCamera)
                {
                    ShowErrorMsg("Applying resource fail!", MyCamera.MV_E_RESOURCE);
                    return;
                }
            }

            int nRet = m_MyCamera.MV_CC_CreateDevice_NET(ref device);
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Create device fail!", nRet);
                return;
            }

            nRet = m_MyCamera.MV_CC_OpenDevice_NET();
            if (MyCamera.MV_OK != nRet)
            {
                m_MyCamera.MV_CC_DestroyDevice_NET();
                ShowErrorMsg("Device open fail!", nRet);
                return;
            }

            // 探测网络最佳包大小(只对GigE相机有效)
            if (device.nTLayerType == MyCamera.MV_GIGE_DEVICE)
            {
                int nPacketSize = m_MyCamera.MV_CC_GetOptimalPacketSize_NET();
                if (nPacketSize > 0)
                {
                    nRet = m_MyCamera.MV_CC_SetIntValueEx_NET("GevSCPSPacketSize", nPacketSize);
                    if (nRet != MyCamera.MV_OK)
                    {
                        ShowErrorMsg("Set Packet Size failed!", nRet);
                    }
                }
                else
                {
                    ShowErrorMsg("Get Packet Size failed!", nPacketSize);
                }
            }

            // 设置触发模式为off
            m_MyCamera.MV_CC_SetEnumValue_NET("TriggerMode", (uint)MyCamera.MV_CAM_TRIGGER_MODE.MV_TRIGGER_MODE_OFF);

            // 获取参数
            bnGetParam_Click(null, null);

            SetCtrlWhenOpen();
        }

        private void btn_OpenDevice2_Click(object sender, EventArgs e)
        {
            if (m_stDeviceList2.nDeviceNum == 0 || cbDeviceList2.SelectedIndex == -1)
            {
                ShowErrorMsg("No device, please select", 0);
                return;
            }

            MyCamera.MV_CC_DEVICE_INFO device2 =
                (MyCamera.MV_CC_DEVICE_INFO)Marshal.PtrToStructure(m_stDeviceList2.pDeviceInfo[cbDeviceList2.SelectedIndex],
                                                              typeof(MyCamera.MV_CC_DEVICE_INFO));

            if (null == m_MyCamera2)
            {
                m_MyCamera2 = new MyCamera();
                if (null == m_MyCamera2)
                {
                    ShowErrorMsg("Applying resource fail!", MyCamera.MV_E_RESOURCE);
                    return;
                }
            }

            int nRet = m_MyCamera2.MV_CC_CreateDevice_NET(ref device2);
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Create device fail!", nRet);
                return;
            }

            nRet = m_MyCamera2.MV_CC_OpenDevice_NET();
            if (MyCamera.MV_OK != nRet)
            {
                m_MyCamera2.MV_CC_DestroyDevice_NET();
                ShowErrorMsg("Device open fail!", nRet);
                return;
            }

            if (device2.nTLayerType == MyCamera.MV_GIGE_DEVICE)
            {
                int nPacketSize2 = m_MyCamera2.MV_CC_GetOptimalPacketSize_NET();
                if (nPacketSize2 > 0)
                {
                    nRet = m_MyCamera2.MV_CC_SetIntValueEx_NET("GevSCPSPacketSize", nPacketSize2);
                    if (nRet != MyCamera.MV_OK)
                    {
                        ShowErrorMsg("Set Packet Size failed!", nRet);
                    }
                }
                else
                {
                    ShowErrorMsg("Get Packet Size failed!", nPacketSize2);
                }
            }

            m_MyCamera2.MV_CC_SetEnumValue_NET("TriggerMode", (uint)MyCamera.MV_CAM_TRIGGER_MODE.MV_TRIGGER_MODE_OFF);

            bnGetParam2_Click(null, null);

            SetCtrlWhenOpen2();
        }

        private void btn_CloseDevice_Click(object sender, EventArgs e)
        {
            if (m_bGrabbing == true)
            {
                m_bGrabbing = false;
                m_hReceiveThread.Join();
            }

            if (m_BufForDriver != IntPtr.Zero)
            {
                Marshal.Release(m_BufForDriver);
            }

            if (m_MyCamera != null)
            {
                m_MyCamera.MV_CC_CloseDevice_NET();
                m_MyCamera.MV_CC_DestroyDevice_NET();
            }

            SetCtrlWhenClose();
        }

        private void btn_CloseDevice2_Click(object sender, EventArgs e)
        {
            if (m_bGrabbing2 == true)
            {
                m_bGrabbing2 = false;
                m_hReceiveThread2.Join();
            }

            if (m_BufForDriver2 != IntPtr.Zero)
            {
                Marshal.Release(m_BufForDriver2);
            }

            if (m_MyCamera2 != null)
            {
                m_MyCamera2.MV_CC_CloseDevice_NET();
                m_MyCamera2.MV_CC_DestroyDevice_NET();
            }

            SetCtrlWhenClose2();
        }

        // 参数设置相关方法
        private void bnGetParam_Click(object sender, EventArgs e)
        {
            MyCamera.MVCC_FLOATVALUE stParam = new MyCamera.MVCC_FLOATVALUE();
            int nRet = m_MyCamera.MV_CC_GetFloatValue_NET("ExposureTime", ref stParam);
            if (MyCamera.MV_OK == nRet)
            {
                tbExposure.Text = stParam.fCurValue.ToString("F1");
            }

            nRet = m_MyCamera.MV_CC_GetFloatValue_NET("Gain", ref stParam);
            if (MyCamera.MV_OK == nRet)
            {
                tbGain.Text = stParam.fCurValue.ToString("F1");
            }

            nRet = m_MyCamera.MV_CC_GetFloatValue_NET("ResultingFrameRate", ref stParam);
            if (MyCamera.MV_OK == nRet)
            {
                tbFrameRate.Text = stParam.fCurValue.ToString("F1");
            }
        }

        private void bnGetParam2_Click(object sender, EventArgs e)
        {
            MyCamera.MVCC_FLOATVALUE stParam = new MyCamera.MVCC_FLOATVALUE();
            int nRet = m_MyCamera2.MV_CC_GetFloatValue_NET("ExposureTime", ref stParam);
            if (MyCamera.MV_OK == nRet)
            {
                tbExposure2.Text = stParam.fCurValue.ToString("F1");
            }

            nRet = m_MyCamera2.MV_CC_GetFloatValue_NET("Gain", ref stParam);
            if (MyCamera.MV_OK == nRet)
            {
                tbGain2.Text = stParam.fCurValue.ToString("F1");
            }

            nRet = m_MyCamera2.MV_CC_GetFloatValue_NET("ResultingFrameRate", ref stParam);
            if (MyCamera.MV_OK == nRet)
            {
                tbFrameRate2.Text = stParam.fCurValue.ToString("F1");
            }
        }

        private void bnSetParam_Click(object sender, EventArgs e)
        {
            try
            {
                float.Parse(tbExposure.Text);
                float.Parse(tbGain.Text);
                float.Parse(tbFrameRate.Text);
            }
            catch
            {
                ShowErrorMsg("Please enter correct type!", 0);
                return;
            }

            m_MyCamera.MV_CC_SetEnumValue_NET("ExposureAuto", 0);
            int nRet = m_MyCamera.MV_CC_SetFloatValue_NET("ExposureTime", float.Parse(tbExposure.Text));
            if (nRet != MyCamera.MV_OK)
            {
                ShowErrorMsg("Set Exposure Time Fail!", nRet);
            }

            m_MyCamera.MV_CC_SetEnumValue_NET("GainAuto", 0);
            nRet = m_MyCamera.MV_CC_SetFloatValue_NET("Gain", float.Parse(tbGain.Text));
            if (nRet != MyCamera.MV_OK)
            {
                ShowErrorMsg("Set Gain Fail!", nRet);
            }

            nRet = m_MyCamera.MV_CC_SetFloatValue_NET("AcquisitionFrameRate", float.Parse(tbFrameRate.Text));
            if (nRet != MyCamera.MV_OK)
            {
                ShowErrorMsg("Set Frame Rate Fail!", nRet);
            }
        }

        private void bnSetParam2_Click(object sender, EventArgs e)
        {
            try
            {
                float.Parse(tbExposure2.Text);
                float.Parse(tbGain2.Text);
                float.Parse(tbFrameRate2.Text);
            }
            catch
            {
                ShowErrorMsg("Please enter correct type!", 0);
                return;
            }

            m_MyCamera2.MV_CC_SetEnumValue_NET("ExposureAuto", 0);
            int nRet = m_MyCamera2.MV_CC_SetFloatValue_NET("ExposureTime", float.Parse(tbExposure2.Text));
            if (nRet != MyCamera.MV_OK)
            {
                ShowErrorMsg("Set Exposure Time Fail!", nRet);
            }

            m_MyCamera2.MV_CC_SetEnumValue_NET("GainAuto", 0);
            nRet = m_MyCamera2.MV_CC_SetFloatValue_NET("Gain", float.Parse(tbGain2.Text));
            if (nRet != MyCamera.MV_OK)
            {
                ShowErrorMsg("Set Gain Fail!", nRet);
            }

            nRet = m_MyCamera2.MV_CC_SetFloatValue_NET("AcquisitionFrameRate", float.Parse(tbFrameRate2.Text));
            if (nRet != MyCamera.MV_OK)
            {
                ShowErrorMsg("Set Frame Rate Fail!", nRet);
            }
        }

        // 控件操作相关方法
        private void SetCtrlWhenOpen()
        {
            btn_OpenDevice.Enabled = false;
            btn_CloseDevice.Enabled = true;
            bnStartGrab.Enabled = true;
            bnStopGrab.Enabled = false;
            bnContinuesMode.Enabled = true;
            bnContinuesMode.Checked = true;
            bnTriggerMode.Enabled = true;
            cbSoftTrigger.Enabled = false;
            cbImageProcess.Enabled = true;
            bnTriggerExec.Enabled = false;

            tbExposure.Enabled = true;
            tbGain.Enabled = true;
            tbFrameRate.Enabled = true;
            bnGetParam.Enabled = true;
            bnSetParam.Enabled = true;
        }

        private void SetCtrlWhenOpen2()
        {
            btn_OpenDevice2.Enabled = false;
            btn_CloseDevice2.Enabled = true;
            bnStartGrab2.Enabled = true;
            bnStopGrab2.Enabled = false;
            bnContinuesMode2.Enabled = true;
            bnContinuesMode2.Checked = true;
            bnTriggerMode2.Enabled = true;
            cbSoftTrigger2.Enabled = false;
            cbImageProcess2.Enabled = true;
            bnTriggerExec2.Enabled = false;

            tbExposure2.Enabled = true;
            tbGain2.Enabled = true;
            tbFrameRate2.Enabled = true;
            bnGetParam2.Enabled = true;
            bnSetParam2.Enabled = true;
        }

        private void SetCtrlWhenClose()
        {
            btn_OpenDevice.Enabled = true;
            btn_CloseDevice.Enabled = false;
            bnStartGrab.Enabled = false;
            bnStopGrab.Enabled = false;
            bnContinuesMode.Enabled = false;
            bnTriggerMode.Enabled = false;
            cbSoftTrigger.Enabled = false;
            cbImageProcess.Enabled = false;
            bnTriggerExec.Enabled = false;

            tbExposure.Enabled = false;
            tbGain.Enabled = false;
            tbFrameRate.Enabled = false;
            bnGetParam.Enabled = false;
            bnSetParam.Enabled = false;
        }

        private void SetCtrlWhenClose2()
        {
            btn_OpenDevice2.Enabled = true;
            btn_CloseDevice2.Enabled = false;
            bnStartGrab2.Enabled = false;
            bnStopGrab2.Enabled = false;
            bnContinuesMode2.Enabled = false;
            bnTriggerMode2.Enabled = false;
            cbSoftTrigger2.Enabled = false;
            cbImageProcess2.Enabled = false;
            bnTriggerExec2.Enabled = false;

            tbExposure2.Enabled = false;
            tbGain2.Enabled = false;
            tbFrameRate2.Enabled = false;
            bnGetParam2.Enabled = false;
            bnSetParam2.Enabled = false;
        }

        private void SetCtrlWhenStartGrab()
        {
            bnStartGrab.Enabled = false;
            bnStopGrab.Enabled = true;

            if (bnTriggerMode.Checked && cbSoftTrigger.Checked)
            {
                bnTriggerExec.Enabled = true;
            }

            cbImageProcess.Enabled = true;
        }

        private void SetCtrlWhenStartGrab2()
        {
            bnStartGrab2.Enabled = false;
            bnStopGrab2.Enabled = true;

            if (bnTriggerMode2.Checked && cbSoftTrigger2.Checked)
            {
                bnTriggerExec2.Enabled = true;
            }

            cbImageProcess2.Enabled = true;
        }

        private void SetCtrlWhenStopGrab()
        {
            bnStartGrab.Enabled = true;
            bnStopGrab.Enabled = false;
            bnTriggerExec.Enabled = false;
        }

        private void SetCtrlWhenStopGrab2()
        {
            bnStartGrab2.Enabled = true;
            bnStopGrab2.Enabled = false;
            bnTriggerExec2.Enabled = false;
        }
        // 图像采集相关方法
        private void bnStartGrab_Click(object sender, EventArgs e)
        {
            int nRet = NecessaryOperBeforeGrab();
            if (MyCamera.MV_OK != nRet)
            {
                return;
            }

            m_bGrabbing = true;
            m_stFrameInfo.nFrameLen = 0;
            m_stFrameInfo.enPixelType = MyCamera.MvGvspPixelType.PixelType_Gvsp_Undefined;

            m_hReceiveThread = new Thread(ReceiveThreadProcess);
            m_hReceiveThread.Start();

            nRet = m_MyCamera.MV_CC_StartGrabbing_NET();
            if (MyCamera.MV_OK != nRet)
            {
                m_bGrabbing = false;
                m_hReceiveThread.Join();
                ShowErrorMsg("Start Grabbing Fail!", nRet);
                return;
            }

            SetCtrlWhenStartGrab();
        }

        private void bnStartGrab2_Click(object sender, EventArgs e)
        {
            int nRet = NecessaryOperBeforeGrab2();
            if (MyCamera.MV_OK != nRet)
            {
                return;
            }

            m_bGrabbing2 = true;
            m_stFrameInfo2.nFrameLen = 0;
            m_stFrameInfo2.enPixelType = MyCamera.MvGvspPixelType.PixelType_Gvsp_Undefined;

            m_hReceiveThread2 = new Thread(ReceiveThreadProcess2);
            m_hReceiveThread2.Start();

            nRet = m_MyCamera2.MV_CC_StartGrabbing_NET();
            if (MyCamera.MV_OK != nRet)
            {
                m_bGrabbing2 = false;
                m_hReceiveThread2.Join();
                ShowErrorMsg("Start Grabbing Fail!", nRet);
                return;
            }

            SetCtrlWhenStartGrab2();
        }

        private void bnStopGrab_Click(object sender, EventArgs e)
        {
            m_bGrabbing = false;
            m_hReceiveThread.Join();

            // 重置平滑器
            smoothingFilters[0].Reset();

            int nRet = m_MyCamera.MV_CC_StopGrabbing_NET();
            if (nRet != MyCamera.MV_OK)
            {
                ShowErrorMsg("Stop Grabbing Fail!", nRet);
            }

            SetCtrlWhenStopGrab();
        }

        private void bnStopGrab2_Click(object sender, EventArgs e)
        {
            m_bGrabbing2 = false;
            m_hReceiveThread2.Join();

            // 重置平滑器
            smoothingFilters[1].Reset();

            int nRet = m_MyCamera2.MV_CC_StopGrabbing_NET();
            if (nRet != MyCamera.MV_OK)
            {
                ShowErrorMsg("Stop Grabbing Fail!", nRet);
            }

            SetCtrlWhenStopGrab2();
        }

        // 图像接收线程
        public void ReceiveThreadProcess()
        {
            MyCamera.MV_FRAME_OUT stFrameInfo = new MyCamera.MV_FRAME_OUT();
            MyCamera.MV_DISPLAY_FRAME_INFO stDisplayInfo = new MyCamera.MV_DISPLAY_FRAME_INFO();
            MyCamera.MV_PIXEL_CONVERT_PARAM stConvertInfo = new MyCamera.MV_PIXEL_CONVERT_PARAM();
            int nRet = MyCamera.MV_OK;

            while (m_bGrabbing)
            {
                nRet = m_MyCamera.MV_CC_GetImageBuffer_NET(ref stFrameInfo, 1000);
                if (nRet == MyCamera.MV_OK)
                {
                    lock (BufForDriverLock)
                    {
                        if (m_BufForDriver == IntPtr.Zero || stFrameInfo.stFrameInfo.nFrameLen > m_nBufSizeForDriver)
                        {
                            if (m_BufForDriver != IntPtr.Zero)
                            {
                                Marshal.Release(m_BufForDriver);
                                m_BufForDriver = IntPtr.Zero;
                            }

                            m_BufForDriver = Marshal.AllocHGlobal((Int32)stFrameInfo.stFrameInfo.nFrameLen);
                            if (m_BufForDriver == IntPtr.Zero)
                            {
                                return;
                            }
                            m_nBufSizeForDriver = stFrameInfo.stFrameInfo.nFrameLen;
                        }

                        m_stFrameInfo = stFrameInfo.stFrameInfo;
                        CopyMemory(m_BufForDriver, stFrameInfo.pBufAddr, stFrameInfo.stFrameInfo.nFrameLen);

                        stConvertInfo.nWidth = stFrameInfo.stFrameInfo.nWidth;
                        stConvertInfo.nHeight = stFrameInfo.stFrameInfo.nHeight;
                        stConvertInfo.enSrcPixelType = stFrameInfo.stFrameInfo.enPixelType;
                        stConvertInfo.pSrcData = stFrameInfo.pBufAddr;
                        stConvertInfo.nSrcDataLen = stFrameInfo.stFrameInfo.nFrameLen;
                        stConvertInfo.pDstBuffer = m_ConvertDstBuf;
                        stConvertInfo.nDstBufferSize = m_nConvertDstBufLen;
                        if (PixelFormat.Format8bppIndexed == m_bitmap.PixelFormat)
                        {
                            stConvertInfo.enDstPixelType = MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono8;
                            m_MyCamera.MV_CC_ConvertPixelType_NET(ref stConvertInfo);
                        }
                        else
                        {
                            stConvertInfo.enDstPixelType = MyCamera.MvGvspPixelType.PixelType_Gvsp_BGR8_Packed;
                            m_MyCamera.MV_CC_ConvertPixelType_NET(ref stConvertInfo);
                        }

                        BitmapData bmpData = m_bitmap.LockBits(new Rectangle(0, 0, stConvertInfo.nWidth, stConvertInfo.nHeight),
                            ImageLockMode.ReadWrite, m_bitmap.PixelFormat);
                        CopyMemory(bmpData.Scan0, stConvertInfo.pDstBuffer, (UInt32)(bmpData.Stride * m_bitmap.Height));
                        m_bitmap.UnlockBits(bmpData);

                        if (IsImageProceee)
                        {
                            Mat mat = OpenCvSharp.Extensions.BitmapConverter.ToMat(m_bitmap);
                            ProcessAndDisplayImageAsync1(mat);
                        }
                    }

                    stDisplayInfo.hWnd = pictureBox1.Handle;
                    stDisplayInfo.pData = stFrameInfo.pBufAddr;
                    stDisplayInfo.nDataLen = stFrameInfo.stFrameInfo.nFrameLen;
                    stDisplayInfo.nWidth = stFrameInfo.stFrameInfo.nWidth;
                    stDisplayInfo.nHeight = stFrameInfo.stFrameInfo.nHeight;
                    stDisplayInfo.enPixelType = stFrameInfo.stFrameInfo.enPixelType;
                    m_MyCamera.MV_CC_DisplayOneFrame_NET(ref stDisplayInfo);

                    m_MyCamera.MV_CC_FreeImageBuffer_NET(ref stFrameInfo);
                }
                else
                {
                    if (bnTriggerMode.Checked)
                    {
                        Thread.Sleep(5);
                    }
                }
            }
        }

        public void ReceiveThreadProcess2()
        {
            MyCamera.MV_FRAME_OUT stFrameInfo = new MyCamera.MV_FRAME_OUT();
            MyCamera.MV_DISPLAY_FRAME_INFO stDisplayInfo = new MyCamera.MV_DISPLAY_FRAME_INFO();
            MyCamera.MV_PIXEL_CONVERT_PARAM stConvertInfo = new MyCamera.MV_PIXEL_CONVERT_PARAM();
            int nRet = MyCamera.MV_OK;

            while (m_bGrabbing2)
            {
                nRet = m_MyCamera2.MV_CC_GetImageBuffer_NET(ref stFrameInfo, 1000);
                if (nRet == MyCamera.MV_OK)
                {
                    lock (BufForDriverLock2)
                    {
                        if (m_BufForDriver2 == IntPtr.Zero || stFrameInfo.stFrameInfo.nFrameLen > m_nBufSizeForDriver2)
                        {
                            if (m_BufForDriver2 != IntPtr.Zero)
                            {
                                Marshal.Release(m_BufForDriver2);
                                m_BufForDriver2 = IntPtr.Zero;
                            }

                            m_BufForDriver2 = Marshal.AllocHGlobal((Int32)stFrameInfo.stFrameInfo.nFrameLen);
                            if (m_BufForDriver2 == IntPtr.Zero)
                            {
                                return;
                            }
                            m_nBufSizeForDriver2 = stFrameInfo.stFrameInfo.nFrameLen;
                        }

                        m_stFrameInfo2 = stFrameInfo.stFrameInfo;
                        CopyMemory(m_BufForDriver2, stFrameInfo.pBufAddr, stFrameInfo.stFrameInfo.nFrameLen);

                        stConvertInfo.nWidth = stFrameInfo.stFrameInfo.nWidth;
                        stConvertInfo.nHeight = stFrameInfo.stFrameInfo.nHeight;
                        stConvertInfo.enSrcPixelType = stFrameInfo.stFrameInfo.enPixelType;
                        stConvertInfo.pSrcData = stFrameInfo.pBufAddr;
                        stConvertInfo.nSrcDataLen = stFrameInfo.stFrameInfo.nFrameLen;
                        stConvertInfo.pDstBuffer = m_ConvertDstBuf2;
                        stConvertInfo.nDstBufferSize = m_nConvertDstBufLen2;
                        if (PixelFormat.Format8bppIndexed == m_bitmap2.PixelFormat)
                        {
                            stConvertInfo.enDstPixelType = MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono8;
                            m_MyCamera2.MV_CC_ConvertPixelType_NET(ref stConvertInfo);
                        }
                        else
                        {
                            stConvertInfo.enDstPixelType = MyCamera.MvGvspPixelType.PixelType_Gvsp_BGR8_Packed;
                            m_MyCamera2.MV_CC_ConvertPixelType_NET(ref stConvertInfo);
                        }

                        BitmapData bmpData = m_bitmap2.LockBits(new Rectangle(0, 0, stConvertInfo.nWidth, stConvertInfo.nHeight),
                            ImageLockMode.ReadWrite, m_bitmap2.PixelFormat);
                        CopyMemory(bmpData.Scan0, stConvertInfo.pDstBuffer, (UInt32)(bmpData.Stride * m_bitmap2.Height));
                        m_bitmap2.UnlockBits(bmpData);

                        if (IsImageProceee2)
                        {
                            Mat mat = OpenCvSharp.Extensions.BitmapConverter.ToMat(m_bitmap2);
                            ProcessAndDisplayImageAsync2(mat);
                        }
                    }

                    stDisplayInfo.hWnd = pictureBox3.Handle;
                    stDisplayInfo.pData = stFrameInfo.pBufAddr;
                    stDisplayInfo.nDataLen = stFrameInfo.stFrameInfo.nFrameLen;
                    stDisplayInfo.nWidth = stFrameInfo.stFrameInfo.nWidth;
                    stDisplayInfo.nHeight = stFrameInfo.stFrameInfo.nHeight;
                    stDisplayInfo.enPixelType = stFrameInfo.stFrameInfo.enPixelType;
                    m_MyCamera2.MV_CC_DisplayOneFrame_NET(ref stDisplayInfo);

                    m_MyCamera2.MV_CC_FreeImageBuffer_NET(ref stFrameInfo);
                }
                else
                {
                    if (bnTriggerMode2.Checked)
                    {
                        Thread.Sleep(5);
                    }
                }
            }
        }

        // 由marker推算cube位姿
        private (double X, double Y, double Z, double Roll, double Pitch, double Yaw)
            EstimateCubePoseFromMarker1(int markerId, Mat rvec, Mat tvec)
        {
            try
            {
                using (var rotMat = new Mat())
                {
                    // 将旋转向量转换为旋转矩阵
                    Cv2.Rodrigues(rvec, rotMat);

                    // 相机坐标系下的位置
                    double xCam = tvec.Get<double>(0);
                    double yCam = tvec.Get<double>(1);
                    double zCam = tvec.Get<double>(2);

                    // 先计算欧拉角
                    double roll = Math.Atan2(rotMat.At<double>(2, 1), rotMat.At<double>(2, 2));
                    double pitch = Math.Atan2(-rotMat.At<double>(2, 0),
                        Math.Sqrt(rotMat.At<double>(2, 1) * rotMat.At<double>(2, 1) +
                                 rotMat.At<double>(2, 2) * rotMat.At<double>(2, 2)));
                    double yaw = Math.Atan2(rotMat.At<double>(1, 0), rotMat.At<double>(0, 0));

                    // 根据marker ID获取其在立方体上的偏移量
                    Vector3 offset = markerTransforms[markerId].offset;

                    // 使用旋转矩阵对偏移量进行旋转
                    double offsetX = rotMat.At<double>(0, 0) * offset.X +
                                   rotMat.At<double>(0, 1) * offset.Y +
                                   rotMat.At<double>(0, 2) * offset.Z;
                    double offsetY = rotMat.At<double>(1, 0) * offset.X +
                                   rotMat.At<double>(1, 1) * offset.Y +
                                   rotMat.At<double>(1, 2) * offset.Z;
                    double offsetZ = rotMat.At<double>(2, 0) * offset.X +
                                   rotMat.At<double>(2, 1) * offset.Y +
                                   rotMat.At<double>(2, 2) * offset.Z;

                    // 在相机坐标系中减去旋转后的偏移量以得到立方体中心位置
                    xCam -= offsetX;
                    yCam -= offsetY;
                    zCam -= offsetZ;

                    // 转换到世界坐标系
                    double xWorld = -zCam - CAMERA1_DISTANCE;  // 相机1的Z轴对应世界-X轴
                    double yWorld = -xCam;                     // 相机1的X轴对应世界-Y轴
                    double zWorld = yCam;                      // 相机1的Y轴对应世界Z轴

                    // 转换角度到度数
                    roll = roll * 180.0 / Math.PI;
                    pitch = pitch * 180.0 / Math.PI;
                    yaw = yaw * 180.0 / Math.PI;

                    return (xWorld, yWorld, zWorld, roll, pitch, yaw);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error in EstimateCubePoseFromMarker1: {ex.Message}");
                return (0, 0, 0, 0, 0, 0);
            }
        }

        private (double X, double Y, double Z, double Roll, double Pitch, double Yaw)
            EstimateCubePoseFromMarker2(int markerId, Mat rvec, Mat tvec)
        {
            try
            {
                using (var rotMat = new Mat())
                {
                    // 将旋转向量转换为旋转矩阵
                    Cv2.Rodrigues(rvec, rotMat);

                    // 相机坐标系下的位置
                    double xCam = tvec.Get<double>(0);
                    double yCam = tvec.Get<double>(1);
                    double zCam = tvec.Get<double>(2);

                    // 先计算欧拉角
                    double roll = Math.Atan2(rotMat.At<double>(2, 1), rotMat.At<double>(2, 2));
                    double pitch = Math.Atan2(-rotMat.At<double>(2, 0),
                        Math.Sqrt(rotMat.At<double>(2, 1) * rotMat.At<double>(2, 1) +
                                 rotMat.At<double>(2, 2) * rotMat.At<double>(2, 2)));
                    double yaw = Math.Atan2(rotMat.At<double>(1, 0), rotMat.At<double>(0, 0));

                    // 根据marker ID获取其在立方体上的偏移量
                    Vector3 offset = markerTransforms[markerId].offset;

                    // 使用旋转矩阵对偏移量进行旋转
                    double offsetX = rotMat.At<double>(0, 0) * offset.X +
                                   rotMat.At<double>(0, 1) * offset.Y +
                                   rotMat.At<double>(0, 2) * offset.Z;
                    double offsetY = rotMat.At<double>(1, 0) * offset.X +
                                   rotMat.At<double>(1, 1) * offset.Y +
                                   rotMat.At<double>(1, 2) * offset.Z;
                    double offsetZ = rotMat.At<double>(2, 0) * offset.X +
                                   rotMat.At<double>(2, 1) * offset.Y +
                                   rotMat.At<double>(2, 2) * offset.Z;

                    // 在相机坐标系中减去旋转后的偏移量以得到立方体中心位置
                    xCam -= offsetX;
                    yCam -= offsetY;
                    zCam -= offsetZ;

                    // 转换到世界坐标系
                    double xWorld = xCam;                      // 相机2的X轴对应世界X轴
                    double yWorld = -zCam - CAMERA2_DISTANCE;  // 相机2的Z轴对应世界-Y轴
                    double zWorld = yCam;                      // 相机2的Y轴对应世界Z轴

                    // 转换角度到度数
                    roll = roll * 180.0 / Math.PI;
                    pitch = pitch * 180.0 / Math.PI;
                    yaw = yaw * 180.0 / Math.PI;

                    return (xWorld, yWorld, zWorld, roll, pitch, yaw);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error in EstimateCubePoseFromMarker2: {ex.Message}");
                return (0, 0, 0, 0, 0, 0);
            }
        }

        // 辅助方法：将角度标准化到 -180 到 180 度范围
        private double NormalizeAngle(double angle)
        {
            angle = angle % 360;
            if (angle > 180)
                angle -= 360;
            else if (angle < -180)
                angle += 360;
            return angle;
        }

        private double FuseAngles(double angle1, double angle2)
        {
            // 确保两个角度都在-180到180度范围内
            angle1 = NormalizeAngle(angle1);
            angle2 = NormalizeAngle(angle2);

            // 计算角度差
            double diff = angle2 - angle1;

            // 如果角度差大于180度，需要调整
            if (diff > 180)
                angle2 -= 360;
            else if (diff < -180)
                angle2 += 360;

            // 计算平均值并标准化
            return NormalizeAngle((angle1 + angle2) / 2);
        }


        // 新增的 ArUco 检测相关代码
        private Mat ProcessImage1(Mat image, out Mat grayImage,
            out float X, out float Y, out float Z, 
            out float Roll, out float Pitch, out float Yaw,
            out int selectedMarkerId)
        {
            X = 0; Y = 0; Z = 0;  // 初始化
            Roll = 0; Pitch = 0; Yaw = 0;
            selectedMarkerId = -1;

            grayImage = new Mat();
            Cv2.CvtColor(image, grayImage, ColorConversionCodes.BGR2GRAY);
            Mat outputImage = image.Clone();
            try
            {
                var dictionary = CvAruco.GetPredefinedDictionary(PredefinedDictionaryName.Dict5X5_250);
                var parameters = new DetectorParameters();
                Point2f[][] rejectedCorners;
                CvAruco.DetectMarkers(
                    grayImage,
                    dictionary,
                    out Point2f[][] corners,
                    out int[] ids,
                    parameters,
                    out rejectedCorners
                );
                if (ids != null && ids.Length > 0)
                {
                    CvAruco.DrawDetectedMarkers(outputImage, corners, ids);
                    var markersWithArea = Enumerable.Range(0, ids.Length)
                        .Select(i => new
                        {
                            Id = ids[i],
                            Corners = corners[i],
                            Area = CalculateMarkerArea(corners[i])
                        })
                        .OrderByDescending(m => m.Area)
                        .ToList();

                    var bestMarker = markersWithArea[0];
                    selectedMarkerId = bestMarker.Id;  // 记录使用的marker ID
                    using (var rvec = new Mat())
                    using (var tvec = new Mat())
                    {
                        Point3f[] objectPoints = new Point3f[]
                        {
                    new Point3f(-MARKER_SIZE/2, MARKER_SIZE/2, 0),
                    new Point3f(MARKER_SIZE/2, MARKER_SIZE/2, 0),
                    new Point3f(MARKER_SIZE/2, -MARKER_SIZE/2, 0),
                    new Point3f(-MARKER_SIZE/2, -MARKER_SIZE/2, 0)
                        };

                        Cv2.SolvePnP(
                            InputArray.Create(objectPoints),
                            InputArray.Create(bestMarker.Corners),
                            cameraMatrix,
                            distCoeffs,
                            rvec,
                            tvec
                        );

                        // 获取立方体位姿
                        var cubePose = EstimateCubePoseFromMarker1(bestMarker.Id, rvec, tvec);

                        // 更新姿态角度
                        X = (float)cubePose.X;
                        Y = (float)cubePose.Y;
                        Z = (float)cubePose.Z;
                        Roll = (float)cubePose.Roll;
                        Pitch = (float)cubePose.Pitch;
                        Yaw = (float)cubePose.Yaw;

                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error in image processing: {ex.Message}");
            }
            return outputImage;
        }
        private Mat ProcessImage2(Mat image, out Mat grayImage,
            out float X, out float Y, out float Z,  
            out float Roll, out float Pitch, out float Yaw,
            out int selectedMarkerId)
        {
            X = 0; Y = 0; Z = 0;  // 初始化
            Roll = 0; Pitch = 0; Yaw = 0;
            selectedMarkerId = -1;

            grayImage = new Mat();
            Cv2.CvtColor(image, grayImage, ColorConversionCodes.BGR2GRAY);
            Mat outputImage = image.Clone();
            try
            {
                var dictionary = CvAruco.GetPredefinedDictionary(PredefinedDictionaryName.Dict5X5_250);
                var parameters = new DetectorParameters();
                Point2f[][] rejectedCorners;
                CvAruco.DetectMarkers(
                    grayImage,
                    dictionary,
                    out Point2f[][] corners,
                    out int[] ids,
                    parameters,
                    out rejectedCorners
                );
                if (ids != null && ids.Length > 0)
                {
                    CvAruco.DrawDetectedMarkers(outputImage, corners, ids);
                    var markersWithArea = Enumerable.Range(0, ids.Length)
                        .Select(i => new
                        {
                            Id = ids[i],
                            Corners = corners[i],
                            Area = CalculateMarkerArea(corners[i])
                        })
                        .OrderByDescending(m => m.Area)
                        .ToList();

                    var bestMarker = markersWithArea[0];
                    selectedMarkerId = bestMarker.Id;  // 记录使用的marker ID

                    using (var rvec = new Mat())
                    using (var tvec = new Mat())
                    {
                        Point3f[] objectPoints = new Point3f[]
                        {
                    new Point3f(-MARKER_SIZE/2, MARKER_SIZE/2, 0),
                    new Point3f(MARKER_SIZE/2, MARKER_SIZE/2, 0),
                    new Point3f(MARKER_SIZE/2, -MARKER_SIZE/2, 0),
                    new Point3f(-MARKER_SIZE/2, -MARKER_SIZE/2, 0)
                        };

                        Cv2.SolvePnP(
                            InputArray.Create(objectPoints),
                            InputArray.Create(bestMarker.Corners),
                            cameraMatrix,
                            distCoeffs,
                            rvec,
                            tvec
                        );

                        // 获取立方体位姿
                        var cubePose = EstimateCubePoseFromMarker2(bestMarker.Id, rvec, tvec);

                        // 更新姿态角度
                        X = (float)cubePose.X;
                        Y = (float)cubePose.Y;
                        Z = (float)cubePose.Z;
                        Roll = (float)cubePose.Roll;
                        Pitch = (float)cubePose.Pitch;
                        Yaw = (float)cubePose.Yaw;


                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error in image processing: {ex.Message}");
            }
            return outputImage;
        }

        // 异步图像处理相关方法

        private void ProcessAndDisplayImageAsync1(Mat mat)
        {
            Task.Run(() =>
            {
                Mat grayImage;
                float X, Y, Z; 
                float Roll, Pitch, Yaw;
                int selectedMarkerId;
                Mat processedImage = ProcessImage1(mat, out grayImage,
                    out X, out Y, out Z,  
                    out Roll, out Pitch, out Yaw,
                    out selectedMarkerId);

                lock (syncLock)
                {
                    camera1Pose = (X, Y, Z, Roll, Pitch, Yaw);

                    if (camera1Pose.HasValue && camera2Pose.HasValue)
                    {
                        ProcessCircleCenters(camera1Pose.Value, camera2Pose.Value);
                        camera1Pose = null;
                        camera2Pose = null;
                    }
                }

                this.Invoke((Action)(() =>
                {
                    string info =
                        $"Camera 1\n\n" +
                        $"Marker ID: {selectedMarkerId}\n\n" +
                        $"Position:\n\n" +
                        $"X = {X:F2}\n\n" +
                        $"Y = {Y:F2}\n\n" +
                        $"Z = {Z:F2}\n\n" +  
                        $"Rotation:\n\n" +
                        $"Roll = {Roll:F2}\n\n" +
                        $"Pitch = {Pitch:F2}\n\n" +
                        $"Yaw = {Yaw:F2}";
                    txt_Test.Text = info;
                    pictureBox2.Image = OpenCvSharp.Extensions.BitmapConverter.ToBitmap(processedImage);
                }));
            });
        }


        private void ProcessAndDisplayImageAsync2(Mat mat)
        {
            Task.Run(() =>
            {
                Mat grayImage;
                float X, Y, Z;  
                float Roll, Pitch, Yaw;
                int selectedMarkerId;
                Mat processedImage = ProcessImage2(mat, out grayImage,
                    out X, out Y, out Z,  
                    out Roll, out Pitch, out Yaw,
                    out selectedMarkerId);

                lock (syncLock)
                {
                    camera2Pose = (X, Y, Z, Roll, Pitch, Yaw);

                    if (camera1Pose.HasValue && camera2Pose.HasValue)
                    {
                        ProcessCircleCenters(camera1Pose.Value, camera2Pose.Value);
                        camera1Pose = null;
                        camera2Pose = null;
                    }
                }

                this.Invoke((Action)(() =>
                {
                    string info =
                        $"Camera 2\n\n" +
                        $"Marker ID: {selectedMarkerId}\n\n" +
                        $"Position:\n\n" +
                        $"X = {X:F2}\n\n" +
                        $"Y = {Y:F2}\n\n" +
                        $"Z = {Z:F2}\n\n" +  
                        $"Rotation:\n\n" +
                        $"Roll = {Roll:F2}\n\n" +
                        $"Pitch = {Pitch:F2}\n\n" +
                        $"Yaw = {Yaw:F2}";
                    txt_Test2.Text = info;
                    pictureBox4.Image = OpenCvSharp.Extensions.BitmapConverter.ToBitmap(processedImage);
                }));
            });
        }
        private void ProcessCircleCenters(
            (double X, double Y, double Z, double Roll, double Pitch, double Yaw) pose1,
            (double X, double Y, double Z, double Roll, double Pitch, double Yaw) pose2)
        {
            // 位置融合
            // 相机1（12点方向）提供Y和Z信息，相机2（3点方向）提供X和Z信息
            // Z值取两个相机的平均值，因为两个相机都能提供相对可靠的Z信息
            var fusedPose = (
                X: pose2.X,            // 从相机2获取X（相机2的X轴方向更可靠）
                Y: pose1.Y,            // 从相机1获取Y（相机1的X轴方向更可靠）
                Z: (pose1.Z + pose2.Z) / 2,  // Z取平均值

                // 姿态角度直接取平均
                Roll: FuseAngles(pose1.Roll, pose2.Roll),
                Pitch: FuseAngles(pose1.Pitch, pose2.Pitch),
                Yaw: FuseAngles(pose1.Yaw, pose2.Yaw)
                        );

            // 更新显示
            string positionText =
                $"Fused Cube Pose:\n\n" +
                $"Position (mm):\n\n" +
                $"X = {fusedPose.X:F2} (from Camera2)\n\n" +
                $"Y = {fusedPose.Y:F2} (from Camera1)\n\n" +
                $"Z = {fusedPose.Z:F2} (averaged)\n\n" +
                $"Rotation (deg):\n\n" +
                $"Roll = {fusedPose.Roll:F2}\n\n" +
                $"Pitch = {fusedPose.Pitch:F2}\n\n" +
                $"Yaw = {fusedPose.Yaw:F2}";

            UpdateTextBox3(positionText);
        }

        // 触发模式相关方法
        private void bnContinuesMode_CheckedChanged(object sender, EventArgs e)
        {
            if (bnContinuesMode.Checked)
            {
                m_MyCamera.MV_CC_SetEnumValue_NET("TriggerMode", (uint)MyCamera.MV_CAM_TRIGGER_MODE.MV_TRIGGER_MODE_OFF);
                cbSoftTrigger.Enabled = false;
                bnTriggerExec.Enabled = false;
            }
        }

        private void bnTriggerMode_CheckedChanged(object sender, EventArgs e)
        {
            if (bnTriggerMode.Checked)
            {
                m_MyCamera.MV_CC_SetEnumValue_NET("TriggerMode", (uint)MyCamera.MV_CAM_TRIGGER_MODE.MV_TRIGGER_MODE_ON);

                if (cbSoftTrigger.Checked)
                {
                    m_MyCamera.MV_CC_SetEnumValue_NET("TriggerSource", (uint)MyCamera.MV_CAM_TRIGGER_SOURCE.MV_TRIGGER_SOURCE_SOFTWARE);
                    if (m_bGrabbing)
                    {
                        bnTriggerExec.Enabled = true;
                    }
                }
                else
                {
                    m_MyCamera.MV_CC_SetEnumValue_NET("TriggerSource", (uint)MyCamera.MV_CAM_TRIGGER_SOURCE.MV_TRIGGER_SOURCE_LINE0);
                }
                cbSoftTrigger.Enabled = true;
            }
        }

        // 软触发相关功能
        private void btn_Trigger_Click(object sender, EventArgs e)
        {
            int nRet = m_MyCamera.MV_CC_SetCommandValue_NET("TriggerSoftware");
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Trigger Software Fail!", nRet);
            }
            int nRet2 = m_MyCamera2.MV_CC_SetCommandValue_NET("TriggerSoftware");
            if (MyCamera.MV_OK != nRet2)
            {
                ShowErrorMsg("Trigger Software Fail!", nRet2);
            }
        }

        private void SoftTrigger()
        {
            while (IsTrigger)
            {
                int nRet = m_MyCamera.MV_CC_SetCommandValue_NET("TriggerSoftware");
                if (MyCamera.MV_OK != nRet)
                {
                    ShowErrorMsg("Trigger Software Fail!", nRet);
                }
                int nRet2 = m_MyCamera2.MV_CC_SetCommandValue_NET("TriggerSoftware");
                if (MyCamera.MV_OK != nRet2)
                {
                    ShowErrorMsg("Trigger Software Fail!", nRet2);
                }

                Thread.Sleep(100);
            }
        }

        // UI更新相关方法
        private void UpdateTextBox(string text)
        {
            if (txt_Test.InvokeRequired)
            {
                txt_Test.Invoke(new Action<string>(UpdateTextBox), text);
            }
            else
            {
                txt_Test.AppendText(text + Environment.NewLine);
                txt_Test.SelectionStart = txt_Test.Text.Length;
                txt_Test.ScrollToCaret();
            }
        }

        private void UpdateTextBox2(string text)
        {
            if (txt_Test2.InvokeRequired)
            {
                txt_Test2.Invoke(new Action<string>(UpdateTextBox2), text);
            }
            else
            {
                txt_Test2.AppendText(text + Environment.NewLine);
                txt_Test2.SelectionStart = txt_Test2.Text.Length;
                txt_Test2.ScrollToCaret();
            }
        }

        private void UpdateTextBox3(string text)
        {
            if (txt_Test3.InvokeRequired)
            {
                txt_Test3.Invoke(new Action<string>(UpdateTextBox3), text);
            }
            else
            {
                txt_Test3.AppendText(text + Environment.NewLine);
                txt_Test3.SelectionStart = txt_Test3.Text.Length;
                txt_Test3.ScrollToCaret();
            }
        }

        // 资源释放
        protected override void OnFormClosing(FormClosingEventArgs e)
        {
            base.OnFormClosing(e);

            // 释放OpenCV相关资源
            cameraMatrix?.Dispose();
            distCoeffs?.Dispose();

            // 关闭相机
            if (m_MyCamera != null)
            {
                m_MyCamera.MV_CC_CloseDevice_NET();
                m_MyCamera.MV_CC_DestroyDevice_NET();
            }

            if (m_MyCamera2 != null)
            {
                m_MyCamera2.MV_CC_CloseDevice_NET();
                m_MyCamera2.MV_CC_DestroyDevice_NET();
            }
        }

        // 图像处理标志位相关
        private void cbImageProcess_CheckedChanged(object sender, EventArgs e)
        {
            IsImageProceee = cbImageProcess.Checked;
            if (!IsImageProceee)
            {
                smoothingFilters[0].Reset();
            }
        }

        private void cbImageProcess2_CheckedChanged(object sender, EventArgs e)
        {
            IsImageProceee2 = cbImageProcess2.Checked;
            if (!IsImageProceee2)
            {
                smoothingFilters[1].Reset();
            }
        }

        // 软触发相关
        private void bnTriggerExec_Click(object sender, EventArgs e)
        {
            int nRet = m_MyCamera.MV_CC_SetCommandValue_NET("TriggerSoftware");
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("触发软件失败!", nRet);
            }
        }

        private void bnTriggerExec2_Click(object sender, EventArgs e)
        {
            int nRet = m_MyCamera2.MV_CC_SetCommandValue_NET("TriggerSoftware");
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("触发软件失败!", nRet);
            }
        }

        // 软触发选项变更
        private void cbSoftTrigger_CheckedChanged(object sender, EventArgs e)
        {
            if (cbSoftTrigger.Checked)
            {
                m_MyCamera.MV_CC_SetEnumValue_NET("TriggerSource", (uint)MyCamera.MV_CAM_TRIGGER_SOURCE.MV_TRIGGER_SOURCE_SOFTWARE);
                if (m_bGrabbing && bnTriggerMode.Checked)
                {
                    bnTriggerExec.Enabled = true;
                    btn_Trigger.Enabled = true;
                    button1.Enabled = true;
                    button2.Enabled = true;
                }
            }
            else
            {
                m_MyCamera.MV_CC_SetEnumValue_NET("TriggerSource", (uint)MyCamera.MV_CAM_TRIGGER_SOURCE.MV_TRIGGER_SOURCE_LINE0);
                bnTriggerExec.Enabled = false;
                btn_Trigger.Enabled = false;
                button1.Enabled = false;
                button2.Enabled = false;
            }
        }

        private void cbSoftTrigger2_CheckedChanged(object sender, EventArgs e)
        {
            if (cbSoftTrigger2.Checked)
            {
                m_MyCamera2.MV_CC_SetEnumValue_NET("TriggerSource", (uint)MyCamera.MV_CAM_TRIGGER_SOURCE.MV_TRIGGER_SOURCE_SOFTWARE);
                if (m_bGrabbing2 && bnTriggerMode2.Checked)
                {
                    bnTriggerExec2.Enabled = true;
                }
            }
            else
            {
                m_MyCamera2.MV_CC_SetEnumValue_NET("TriggerSource", (uint)MyCamera.MV_CAM_TRIGGER_SOURCE.MV_TRIGGER_SOURCE_LINE0);
                bnTriggerExec2.Enabled = false;
            }
        }

        // 触发模式变更
        private void bnTriggerMode2_CheckedChanged(object sender, EventArgs e)
        {
            if (bnTriggerMode2.Checked)
            {
                m_MyCamera2.MV_CC_SetEnumValue_NET("TriggerMode", (uint)MyCamera.MV_CAM_TRIGGER_MODE.MV_TRIGGER_MODE_ON);
                cbSoftTrigger2.Enabled = true;
                if (cbSoftTrigger2.Checked)
                {
                    m_MyCamera2.MV_CC_SetEnumValue_NET("TriggerSource", (uint)MyCamera.MV_CAM_TRIGGER_SOURCE.MV_TRIGGER_SOURCE_SOFTWARE);
                    if (m_bGrabbing2)
                    {
                        bnTriggerExec2.Enabled = true;
                    }
                }
            }
        }

        // 连续模式变更
        private void bnContinuesMode2_CheckedChanged(object sender, EventArgs e)
        {
            if (bnContinuesMode2.Checked)
            {
                m_MyCamera2.MV_CC_SetEnumValue_NET("TriggerMode", (uint)MyCamera.MV_CAM_TRIGGER_MODE.MV_TRIGGER_MODE_OFF);
                cbSoftTrigger2.Enabled = false;
                bnTriggerExec2.Enabled = false;
            }
        }

        // 文本框相关
        private void txt_Test_TextChanged(object sender, EventArgs e)
        {
        }

        private void txt_Test2_TextChanged(object sender, EventArgs e)
        {
        }

        // 按钮事件
        private void btn_Tset_Click(object sender, EventArgs e)
        {
            // 测试按钮功能实现  
        }

        private void button1_Click(object sender, EventArgs e)
        {
            // 开启持续软触发
            IsTrigger = true;
            TriggerThread = new Thread(SoftTrigger);
            TriggerThread.Start();
        }

        private void button2_Click(object sender, EventArgs e)
        {
            // 关闭持续软触发
            IsTrigger = false;
            TriggerThread.Join();
        }

        private void txt_Test2_TextChanged_1(object sender, EventArgs e)
        {

        }

        private void pictureBox2_Click(object sender, EventArgs e)
        {

        }

        private void pictureBox4_Click(object sender, EventArgs e)
        {

        }
    } // class Form1 结束


} // namespace 结束                                                                                                                                                                                 
