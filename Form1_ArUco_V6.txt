using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using MvCamCtrl;
using MvCamCtrl.NET;
using System.Threading;
using System.Runtime.InteropServices;
using System.Text.RegularExpressions;
using System.Drawing.Imaging;
using System.IO;
using System.Diagnostics;
using System.Collections.ObjectModel;
using OpenCvSharp;
using System.Numerics;
using OpenCvSharp.Aruco;
using Point = OpenCvSharp.Point;


namespace 海康威视图像采集及处理
{
    public partial class Form1 : Form
    {
        // DLL导入
        [DllImport("kernel32.dll", EntryPoint = "RtlMoveMemory", SetLastError = false)]
        private static extern void CopyMemory(IntPtr dest, IntPtr src, uint count);

        // 常量定义
        public const Int32 CUSTOMER_PIXEL_FORMAT = unchecked((Int32)0x80000000);

        // 相机1相关变量
        MyCamera.MV_CC_DEVICE_INFO_LIST m_stDeviceList = new MyCamera.MV_CC_DEVICE_INFO_LIST();
        private MyCamera m_MyCamera = new MyCamera();
        bool m_bGrabbing = false;
        Thread m_hReceiveThread = null;
        MyCamera.MV_FRAME_OUT_INFO_EX m_stFrameInfo = new MyCamera.MV_FRAME_OUT_INFO_EX();

        // 相机2相关变量
        MyCamera.MV_CC_DEVICE_INFO_LIST m_stDeviceList2 = new MyCamera.MV_CC_DEVICE_INFO_LIST();
        private MyCamera m_MyCamera2 = new MyCamera();
        bool m_bGrabbing2 = false;
        Thread m_hReceiveThread2 = null;
        MyCamera.MV_FRAME_OUT_INFO_EX m_stFrameInfo2 = new MyCamera.MV_FRAME_OUT_INFO_EX();

        // 相机1图像缓存相关
        UInt32 m_nBufSizeForDriver = 0;
        IntPtr m_BufForDriver = IntPtr.Zero;
        private static Object BufForDriverLock = new Object();
        Bitmap m_bitmap = null;
        PixelFormat m_bitmapPixelFormat = PixelFormat.DontCare;
        IntPtr m_ConvertDstBuf = IntPtr.Zero;
        UInt32 m_nConvertDstBufLen = 0;

        // 相机2图像缓存相关
        UInt32 m_nBufSizeForDriver2 = 0;
        IntPtr m_BufForDriver2 = IntPtr.Zero;
        private static Object BufForDriverLock2 = new Object();
        Bitmap m_bitmap2 = null;
        PixelFormat m_bitmapPixelFormat2 = PixelFormat.DontCare;
        IntPtr m_ConvertDstBuf2 = IntPtr.Zero;
        UInt32 m_nConvertDstBufLen2 = 0;

        // 图像处理相关变量
        private bool IsImageProceee = false;
        private bool IsImageProceee2 = false;
        //private int frameCounter = 0;
        private int frameCounter2 = 0;
        private bool IsTrigger = false;
        Thread TriggerThread = null;
        private object syncLock = new object();

        // ArUco检测相关变量
        private Mat cameraMatrix;
        private Mat distCoeffs;


        // 立方体常量
        private const float CUBE_SIZE = 35.0f;  // 立方体边长
        private const float MARKER_SIZE = 30.0f; // ArUco码边长

        // 修改相机姿态存储变量的定义（在类的成员变量部分）
        private (double X, double Y, double Z, double Roll, double Pitch, double Yaw)? camera1Pose = null;
        private (double X, double Y, double Z, double Roll, double Pitch, double Yaw)? camera2Pose = null;

        // 坐标系相关常量
        private const float CAMERA1_DISTANCE = 450.0f;  // 相机1到原点距离（X轴负方向）
        private const float CAMERA2_DISTANCE = 450.0f;  // 相机2到原点距离（Y轴负方向）

        // 定义Marker相对于立方体中心的变换关系
        private readonly Dictionary<int, (Vector3 offset, Mat worldTransformMatrix)> markerTransforms;


        //计算marker面积的辅助方法
        private double CalculateMarkerArea(Point2f[] corners)
        {
            double area = 0;
            for (int i = 0; i < 4; i++)
            {
                int j = (i + 1) % 4;
                area += corners[i].X * corners[j].Y - corners[j].X * corners[i].Y;
            }
            return Math.Abs(area) / 2;
        }



        public Form1()
        {
            InitializeComponent();

            // 初始化marker变换关系
            markerTransforms = new Dictionary<int, (Vector3 offset, Mat worldTransformMatrix)>();

            // 步骤2.1: 创建Marker1到世界坐标系的基准变换矩阵
            Mat marker1ToWorld = new Mat(3, 3, MatType.CV_64F);

            // 填充变换矩阵：Z->X, X->-Y, Y->-Z
            // 第一行：立方体X轴 = Marker 1的Z轴
            marker1ToWorld.Set<double>(0, 0, 0);
            marker1ToWorld.Set<double>(0, 1, 0);
            marker1ToWorld.Set<double>(0, 2, 1);

            // 第二行：立方体Y轴 = Marker 1的-X轴
            marker1ToWorld.Set<double>(1, 0, -1);
            marker1ToWorld.Set<double>(1, 1, 0);
            marker1ToWorld.Set<double>(1, 2, 0);

            // 第三行：立方体Z轴 = Marker 1的-Y轴
            marker1ToWorld.Set<double>(2, 0, 0);
            marker1ToWorld.Set<double>(2, 1, -1);
            marker1ToWorld.Set<double>(2, 2, 0);

            // 步骤2.2: 创建各Marker到Marker1的补偿矩阵

            // Marker 1 - 无需补偿
            Mat marker1Comp = Mat.Eye(3, 3, MatType.CV_64F);

            // Marker 3 - 后面，面向-X方向，绕Y轴旋转180度
            Mat marker3Comp = new Mat();
            Cv2.Rodrigues(new Vec3d(0, Math.PI, 0), marker3Comp);

            // Marker 5 - 右面，面向-Y方向，绕Y轴旋转-90度
            Mat marker5Comp = new Mat();
            Cv2.Rodrigues(new Vec3d(0, -Math.PI / 2, 0), marker5Comp);

            // Marker 7 - 左面，面向+Y方向，绕Y轴旋转90度
            Mat marker7Comp = new Mat();
            Cv2.Rodrigues(new Vec3d(0, Math.PI / 2, 0), marker7Comp);

            // Marker 9 - 底面，面向+Z方向，绕X轴旋转-90度
            Mat marker9Comp = new Mat();
            Cv2.Rodrigues(new Vec3d(-Math.PI / 2, 0, 0), marker9Comp);

            // 步骤2.3: 计算并存储各Marker直接到世界坐标系的变换矩阵

            // 使用正确的矩阵乘法语法
            Mat marker1ToWorldFinal = marker1Comp * marker1ToWorld;
            Mat marker3ToWorldFinal = marker3Comp * marker1ToWorld;
            Mat marker5ToWorldFinal = marker5Comp * marker1ToWorld;
            Mat marker7ToWorldFinal = marker7Comp * marker1ToWorld;
            Mat marker9ToWorldFinal = marker9Comp * marker1ToWorld;

            // 步骤2.4: 将偏移量和最终变换矩阵存入字典
            markerTransforms.Add(1, (new Vector3(CUBE_SIZE / 2, 0, 0), marker1ToWorldFinal));
            markerTransforms.Add(3, (new Vector3(-CUBE_SIZE / 2, 0, 0), marker3ToWorldFinal));
            markerTransforms.Add(5, (new Vector3(0, -CUBE_SIZE / 2, 0), marker5ToWorldFinal));
            markerTransforms.Add(7, (new Vector3(0, CUBE_SIZE / 2, 0), marker7ToWorldFinal));
            markerTransforms.Add(9, (new Vector3(0, 0, CUBE_SIZE / 2), marker9ToWorldFinal));

            // 步骤2.5: 释放临时矩阵
            marker1ToWorld.Dispose();
            marker1Comp.Dispose();
            marker3Comp.Dispose();
            marker5Comp.Dispose();
            marker7Comp.Dispose();
            marker9Comp.Dispose();

            // 其他现有初始化代码
            Control.CheckForIllegalCrossThreadCalls = false;
            this.Load += new EventHandler(Form1_Load);

            // 初始化相机参数
            cameraMatrix = Mat.Eye(3, 3, MatType.CV_64F);
            cameraMatrix.Set<double>(0, 0, 1000.0); // fx
            cameraMatrix.Set<double>(1, 1, 1000.0); // fy
            cameraMatrix.Set<double>(0, 2, 1536 / 2.0); // cx
            cameraMatrix.Set<double>(1, 2, 1024 / 2.0); // cy

            distCoeffs = Mat.Zeros(rows: 1, cols: 5, type: MatType.CV_64F);
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            // 初始化SDK
            MyCamera.MV_CC_Initialize_NET();
            // 枚举设备
            DeviceListAcq();
            DeviceListAcq2();
        }

        // 像素类型是否为Mono格式检查
        private Boolean IsMono(UInt32 enPixelType)
        {
            switch (enPixelType)
            {
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono1p:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono2p:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono4p:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono8:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono8_Signed:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono10:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono10_Packed:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono12:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono12_Packed:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono14:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono16:
                    return true;
                default:
                    return false;
            }
        }

        // 取图前的必要操作
        private Int32 NecessaryOperBeforeGrab()
        {
            // 获取图像宽度
            MyCamera.MVCC_INTVALUE_EX stWidth = new MyCamera.MVCC_INTVALUE_EX();
            int nRet = m_MyCamera.MV_CC_GetIntValueEx_NET("Width", ref stWidth);
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Get Width Info Fail!", nRet);
                return nRet;
            }

            // 获取图像高度
            MyCamera.MVCC_INTVALUE_EX stHeight = new MyCamera.MVCC_INTVALUE_EX();
            nRet = m_MyCamera.MV_CC_GetIntValueEx_NET("Height", ref stHeight);
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Get Height Info Fail!", nRet);
                return nRet;
            }

            // 获取像素格式
            MyCamera.MVCC_ENUMVALUE stPixelFormat = new MyCamera.MVCC_ENUMVALUE();
            nRet = m_MyCamera.MV_CC_GetEnumValue_NET("PixelFormat", ref stPixelFormat);
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Get Pixel Format Fail!", nRet);
                return nRet;
            }

            // 设置bitmap像素格式，分配内存
            if ((Int32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Undefined == (Int32)stPixelFormat.nCurValue)
            {
                ShowErrorMsg("Unknown Pixel Format!", MyCamera.MV_E_UNKNOW);
                return MyCamera.MV_E_UNKNOW;
            }
            else if (IsMono(stPixelFormat.nCurValue))
            {
                m_bitmapPixelFormat = PixelFormat.Format8bppIndexed;

                if (IntPtr.Zero != m_ConvertDstBuf)
                {
                    Marshal.Release(m_ConvertDstBuf);
                    m_ConvertDstBuf = IntPtr.Zero;
                }
                m_nConvertDstBufLen = (UInt32)(stWidth.nCurValue * stHeight.nCurValue);
                m_ConvertDstBuf = Marshal.AllocHGlobal((Int32)m_nConvertDstBufLen);
            }
            else
            {
                m_bitmapPixelFormat = PixelFormat.Format24bppRgb;

                if (IntPtr.Zero != m_ConvertDstBuf)
                {
                    Marshal.FreeHGlobal(m_ConvertDstBuf);
                    m_ConvertDstBuf = IntPtr.Zero;
                }
                m_nConvertDstBufLen = (UInt32)(3 * stWidth.nCurValue * stHeight.nCurValue);
                m_ConvertDstBuf = Marshal.AllocHGlobal((Int32)m_nConvertDstBufLen);
            }

            if (null != m_bitmap)
            {
                m_bitmap.Dispose();
                m_bitmap = null;
            }
            m_bitmap = new Bitmap((Int32)stWidth.nCurValue, (Int32)stHeight.nCurValue, m_bitmapPixelFormat);

            if (PixelFormat.Format8bppIndexed == m_bitmapPixelFormat)
            {
                ColorPalette palette = m_bitmap.Palette;
                for (int i = 0; i < palette.Entries.Length; i++)
                {
                    palette.Entries[i] = Color.FromArgb(i, i, i);
                }
                m_bitmap.Palette = palette;
            }

            return MyCamera.MV_OK;
        }

        // 显示错误信息
        private void ShowErrorMsg(string csMessage, int nErrorNum)
        {
            string errorMsg;
            if (nErrorNum == 0)
            {
                errorMsg = csMessage;
            }
            else
            {
                errorMsg = csMessage + ": Error =" + String.Format("{0:X}", nErrorNum);
            }

            switch (nErrorNum)
            {
                case MyCamera.MV_E_HANDLE: errorMsg += " Error or invalid handle "; break;
                case MyCamera.MV_E_SUPPORT: errorMsg += " Not supported function "; break;
                case MyCamera.MV_E_BUFOVER: errorMsg += " Cache is full "; break;
                case MyCamera.MV_E_CALLORDER: errorMsg += " Function calling order error "; break;
                case MyCamera.MV_E_PARAMETER: errorMsg += " Incorrect parameter "; break;
                case MyCamera.MV_E_RESOURCE: errorMsg += " Applying resource failed "; break;
                case MyCamera.MV_E_NODATA: errorMsg += " No data "; break;
                case MyCamera.MV_E_PRECONDITION: errorMsg += " Precondition error, or running environment changed "; break;
                case MyCamera.MV_E_VERSION: errorMsg += " Version mismatches "; break;
                case MyCamera.MV_E_NOENOUGH_BUF: errorMsg += " Insufficient memory "; break;
                case MyCamera.MV_E_UNKNOW: errorMsg += " Unknown error "; break;
                case MyCamera.MV_E_GC_GENERIC: errorMsg += " General error "; break;
                case MyCamera.MV_E_GC_ACCESS: errorMsg += " Node accessing condition error "; break;
                case MyCamera.MV_E_ACCESS_DENIED: errorMsg += " No permission "; break;
                case MyCamera.MV_E_BUSY: errorMsg += " Device is busy, or network disconnected "; break;
                case MyCamera.MV_E_NETER: errorMsg += " Network error "; break;
            }

            MessageBox.Show(errorMsg, "PROMPT");
        }

        // 用于清理设备名称中的空字符
        private string DeleteTail(string strUserDefinedName)
        {
            strUserDefinedName = Regex.Unescape(strUserDefinedName);
            int nIndex = strUserDefinedName.IndexOf("\0");
            if (nIndex >= 0)
            {
                strUserDefinedName = strUserDefinedName.Remove(nIndex);
            }
            return strUserDefinedName;
        }

        // 取图前的必要操作2
        private Int32 NecessaryOperBeforeGrab2()
        {
            MyCamera.MVCC_INTVALUE_EX stWidth = new MyCamera.MVCC_INTVALUE_EX();
            int nRet = m_MyCamera2.MV_CC_GetIntValueEx_NET("Width", ref stWidth);
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Get Width Info Fail!", nRet);
                return nRet;
            }

            MyCamera.MVCC_INTVALUE_EX stHeight = new MyCamera.MVCC_INTVALUE_EX();
            nRet = m_MyCamera2.MV_CC_GetIntValueEx_NET("Height", ref stHeight);
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Get Height Info Fail!", nRet);
                return nRet;
            }

            MyCamera.MVCC_ENUMVALUE stPixelFormat = new MyCamera.MVCC_ENUMVALUE();
            nRet = m_MyCamera2.MV_CC_GetEnumValue_NET("PixelFormat", ref stPixelFormat);
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Get Pixel Format Fail!", nRet);
                return nRet;
            }

            if ((Int32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Undefined == (Int32)stPixelFormat.nCurValue)
            {
                ShowErrorMsg("Unknown Pixel Format!", MyCamera.MV_E_UNKNOW);
                return MyCamera.MV_E_UNKNOW;
            }
            else if (IsMono(stPixelFormat.nCurValue))
            {
                m_bitmapPixelFormat2 = PixelFormat.Format8bppIndexed;

                if (IntPtr.Zero != m_ConvertDstBuf2)
                {
                    Marshal.Release(m_ConvertDstBuf2);
                    m_ConvertDstBuf2 = IntPtr.Zero;
                }
                m_nConvertDstBufLen2 = (UInt32)(stWidth.nCurValue * stHeight.nCurValue);
                m_ConvertDstBuf2 = Marshal.AllocHGlobal((Int32)m_nConvertDstBufLen2);
            }
            else
            {
                m_bitmapPixelFormat2 = PixelFormat.Format24bppRgb;

                if (IntPtr.Zero != m_ConvertDstBuf2)
                {
                    Marshal.FreeHGlobal(m_ConvertDstBuf2);
                    m_ConvertDstBuf2 = IntPtr.Zero;
                }
                m_nConvertDstBufLen2 = (UInt32)(3 * stWidth.nCurValue * stHeight.nCurValue);
                m_ConvertDstBuf2 = Marshal.AllocHGlobal((Int32)m_nConvertDstBufLen2);
            }

            if (null != m_bitmap2)
            {
                m_bitmap2.Dispose();
                m_bitmap2 = null;
            }
            m_bitmap2 = new Bitmap((Int32)stWidth.nCurValue, (Int32)stHeight.nCurValue, m_bitmapPixelFormat2);

            if (PixelFormat.Format8bppIndexed == m_bitmapPixelFormat2)
            {
                ColorPalette palette = m_bitmap2.Palette;
                for (int i = 0; i < palette.Entries.Length; i++)
                {
                    palette.Entries[i] = Color.FromArgb(i, i, i);
                }
                m_bitmap2.Palette = palette;
            }

            return MyCamera.MV_OK;
        }

        // 设备枚举相关方法
        private void btn_Enum_Click(object sender, EventArgs e)
        {
            DeviceListAcq();
        }

        private void btn_Enum2_Click(object sender, EventArgs e)
        {
            DeviceListAcq2();
        }

        private void DeviceListAcq()
        {
            System.GC.Collect();
            cbDeviceList.Items.Clear();
            m_stDeviceList.nDeviceNum = 0;

            int nRet = MyCamera.MV_CC_EnumDevices_NET(MyCamera.MV_GIGE_DEVICE | MyCamera.MV_USB_DEVICE | MyCamera.MV_GENTL_GIGE_DEVICE
                | MyCamera.MV_GENTL_CAMERALINK_DEVICE | MyCamera.MV_GENTL_CXP_DEVICE | MyCamera.MV_GENTL_XOF_DEVICE, ref m_stDeviceList);

            if (0 != nRet)
            {
                ShowErrorMsg("Enumerate devices fail!", 0);
                return;
            }

            // 在窗体列表中显示设备名
            for (int i = 0; i < m_stDeviceList.nDeviceNum; i++)
            {
                MyCamera.MV_CC_DEVICE_INFO device = (MyCamera.MV_CC_DEVICE_INFO)Marshal.PtrToStructure(m_stDeviceList.pDeviceInfo[i], typeof(MyCamera.MV_CC_DEVICE_INFO));
                string strUserDefinedName = "";

                if (device.nTLayerType == MyCamera.MV_GIGE_DEVICE)
                {
                    MyCamera.MV_GIGE_DEVICE_INFO_EX gigeInfo = (MyCamera.MV_GIGE_DEVICE_INFO_EX)MyCamera.ByteToStruct(device.SpecialInfo.stGigEInfo, typeof(MyCamera.MV_GIGE_DEVICE_INFO_EX));

                    if ((gigeInfo.chUserDefinedName.Length > 0) && (gigeInfo.chUserDefinedName[0] != '\0'))
                    {
                        if (MyCamera.IsTextUTF8(gigeInfo.chUserDefinedName))
                            strUserDefinedName = Encoding.UTF8.GetString(gigeInfo.chUserDefinedName).TrimEnd('\0');
                        else
                            strUserDefinedName = Encoding.Default.GetString(gigeInfo.chUserDefinedName).TrimEnd('\0');
                        cbDeviceList.Items.Add("GEV: " + DeleteTail(strUserDefinedName) + " (" + gigeInfo.chSerialNumber + ")");
                    }
                    else
                    {
                        cbDeviceList.Items.Add("GEV: " + gigeInfo.chManufacturerName + " " + gigeInfo.chModelName + " (" + gigeInfo.chSerialNumber + ")");
                    }
                }
                else if (device.nTLayerType == MyCamera.MV_USB_DEVICE)
                {
                    MyCamera.MV_USB3_DEVICE_INFO_EX usbInfo = (MyCamera.MV_USB3_DEVICE_INFO_EX)MyCamera.ByteToStruct(device.SpecialInfo.stUsb3VInfo, typeof(MyCamera.MV_USB3_DEVICE_INFO_EX));

                    if ((usbInfo.chUserDefinedName.Length > 0) && (usbInfo.chUserDefinedName[0] != '\0'))
                    {
                        if (MyCamera.IsTextUTF8(usbInfo.chUserDefinedName))
                            strUserDefinedName = Encoding.UTF8.GetString(usbInfo.chUserDefinedName).TrimEnd('\0');
                        else
                            strUserDefinedName = Encoding.Default.GetString(usbInfo.chUserDefinedName).TrimEnd('\0');
                        cbDeviceList.Items.Add("U3V: " + DeleteTail(strUserDefinedName) + " (" + usbInfo.chSerialNumber + ")");
                    }
                    else
                    {
                        cbDeviceList.Items.Add("U3V: " + usbInfo.chManufacturerName + " " + usbInfo.chModelName + " (" + usbInfo.chSerialNumber + ")");
                    }
                }
            }

            if (m_stDeviceList.nDeviceNum != 0)
            {
                cbDeviceList.SelectedIndex = 0;
            }
        }

        private void DeviceListAcq2()
        {
            System.GC.Collect();
            cbDeviceList2.Items.Clear();
            m_stDeviceList2.nDeviceNum = 0;

            int nRet = MyCamera.MV_CC_EnumDevices_NET(MyCamera.MV_GIGE_DEVICE | MyCamera.MV_USB_DEVICE | MyCamera.MV_GENTL_GIGE_DEVICE
                | MyCamera.MV_GENTL_CAMERALINK_DEVICE | MyCamera.MV_GENTL_CXP_DEVICE | MyCamera.MV_GENTL_XOF_DEVICE, ref m_stDeviceList2);

            if (0 != nRet)
            {
                ShowErrorMsg("Enumerate devices fail!", 0);
                return;
            }

            // 在窗体列表中显示设备名
            for (int i = 0; i < m_stDeviceList2.nDeviceNum; i++)
            {
                MyCamera.MV_CC_DEVICE_INFO device = (MyCamera.MV_CC_DEVICE_INFO)Marshal.PtrToStructure(m_stDeviceList2.pDeviceInfo[i], typeof(MyCamera.MV_CC_DEVICE_INFO));
                string strUserDefinedName = "";

                if (device.nTLayerType == MyCamera.MV_GIGE_DEVICE)
                {
                    MyCamera.MV_GIGE_DEVICE_INFO_EX gigeInfo = (MyCamera.MV_GIGE_DEVICE_INFO_EX)MyCamera.ByteToStruct(device.SpecialInfo.stGigEInfo, typeof(MyCamera.MV_GIGE_DEVICE_INFO_EX));

                    if ((gigeInfo.chUserDefinedName.Length > 0) && (gigeInfo.chUserDefinedName[0] != '\0'))
                    {
                        if (MyCamera.IsTextUTF8(gigeInfo.chUserDefinedName))
                            strUserDefinedName = Encoding.UTF8.GetString(gigeInfo.chUserDefinedName).TrimEnd('\0');
                        else
                            strUserDefinedName = Encoding.Default.GetString(gigeInfo.chUserDefinedName).TrimEnd('\0');
                        cbDeviceList2.Items.Add("GEV: " + DeleteTail(strUserDefinedName) + " (" + gigeInfo.chSerialNumber + ")");
                    }
                    else
                    {
                        cbDeviceList2.Items.Add("GEV: " + gigeInfo.chManufacturerName + " " + gigeInfo.chModelName + " (" + gigeInfo.chSerialNumber + ")");
                    }
                }
                else if (device.nTLayerType == MyCamera.MV_USB_DEVICE)
                {
                    MyCamera.MV_USB3_DEVICE_INFO_EX usbInfo = (MyCamera.MV_USB3_DEVICE_INFO_EX)MyCamera.ByteToStruct(device.SpecialInfo.stUsb3VInfo, typeof(MyCamera.MV_USB3_DEVICE_INFO_EX));

                    if ((usbInfo.chUserDefinedName.Length > 0) && (usbInfo.chUserDefinedName[0] != '\0'))
                    {
                        if (MyCamera.IsTextUTF8(usbInfo.chUserDefinedName))
                            strUserDefinedName = Encoding.UTF8.GetString(usbInfo.chUserDefinedName).TrimEnd('\0');
                        else
                            strUserDefinedName = Encoding.Default.GetString(usbInfo.chUserDefinedName).TrimEnd('\0');
                        cbDeviceList2.Items.Add("U3V: " + DeleteTail(strUserDefinedName) + " (" + usbInfo.chSerialNumber + ")");
                    }
                    else
                    {
                        cbDeviceList2.Items.Add("U3V: " + usbInfo.chManufacturerName + " " + usbInfo.chModelName + " (" + usbInfo.chSerialNumber + ")");
                    }
                }
            }

            if (m_stDeviceList2.nDeviceNum != 0)
            {
                cbDeviceList2.SelectedIndex = 0;
            }
        }

        // 设备打开关闭相关方法
        private void btn_OpenDevice_Click(object sender, EventArgs e)
        {
            if (m_stDeviceList.nDeviceNum == 0 || cbDeviceList.SelectedIndex == -1)
            {
                ShowErrorMsg("No device, please select", 0);
                return;
            }

            MyCamera.MV_CC_DEVICE_INFO device =
                (MyCamera.MV_CC_DEVICE_INFO)Marshal.PtrToStructure(m_stDeviceList.pDeviceInfo[cbDeviceList.SelectedIndex],
                                                              typeof(MyCamera.MV_CC_DEVICE_INFO));

            if (null == m_MyCamera)
            {
                m_MyCamera = new MyCamera();
                if (null == m_MyCamera)
                {
                    ShowErrorMsg("Applying resource fail!", MyCamera.MV_E_RESOURCE);
                    return;
                }
            }

            int nRet = m_MyCamera.MV_CC_CreateDevice_NET(ref device);
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Create device fail!", nRet);
                return;
            }

            nRet = m_MyCamera.MV_CC_OpenDevice_NET();
            if (MyCamera.MV_OK != nRet)
            {
                m_MyCamera.MV_CC_DestroyDevice_NET();
                ShowErrorMsg("Device open fail!", nRet);
                return;
            }

            // 探测网络最佳包大小(只对GigE相机有效)
            if (device.nTLayerType == MyCamera.MV_GIGE_DEVICE)
            {
                int nPacketSize = m_MyCamera.MV_CC_GetOptimalPacketSize_NET();
                if (nPacketSize > 0)
                {
                    nRet = m_MyCamera.MV_CC_SetIntValueEx_NET("GevSCPSPacketSize", nPacketSize);
                    if (nRet != MyCamera.MV_OK)
                    {
                        ShowErrorMsg("Set Packet Size failed!", nRet);
                    }
                }
                else
                {
                    ShowErrorMsg("Get Packet Size failed!", nPacketSize);
                }
            }

            // 设置触发模式为off
            m_MyCamera.MV_CC_SetEnumValue_NET("TriggerMode", (uint)MyCamera.MV_CAM_TRIGGER_MODE.MV_TRIGGER_MODE_OFF);

            // 获取参数
            bnGetParam_Click(null, null);

            SetCtrlWhenOpen();
        }

        private void btn_OpenDevice2_Click(object sender, EventArgs e)
        {
            if (m_stDeviceList2.nDeviceNum == 0 || cbDeviceList2.SelectedIndex == -1)
            {
                ShowErrorMsg("No device, please select", 0);
                return;
            }

            MyCamera.MV_CC_DEVICE_INFO device2 =
                (MyCamera.MV_CC_DEVICE_INFO)Marshal.PtrToStructure(m_stDeviceList2.pDeviceInfo[cbDeviceList2.SelectedIndex],
                                                              typeof(MyCamera.MV_CC_DEVICE_INFO));

            if (null == m_MyCamera2)
            {
                m_MyCamera2 = new MyCamera();
                if (null == m_MyCamera2)
                {
                    ShowErrorMsg("Applying resource fail!", MyCamera.MV_E_RESOURCE);
                    return;
                }
            }

            int nRet = m_MyCamera2.MV_CC_CreateDevice_NET(ref device2);
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Create device fail!", nRet);
                return;
            }

            nRet = m_MyCamera2.MV_CC_OpenDevice_NET();
            if (MyCamera.MV_OK != nRet)
            {
                m_MyCamera2.MV_CC_DestroyDevice_NET();
                ShowErrorMsg("Device open fail!", nRet);
                return;
            }

            if (device2.nTLayerType == MyCamera.MV_GIGE_DEVICE)
            {
                int nPacketSize2 = m_MyCamera2.MV_CC_GetOptimalPacketSize_NET();
                if (nPacketSize2 > 0)
                {
                    nRet = m_MyCamera2.MV_CC_SetIntValueEx_NET("GevSCPSPacketSize", nPacketSize2);
                    if (nRet != MyCamera.MV_OK)
                    {
                        ShowErrorMsg("Set Packet Size failed!", nRet);
                    }
                }
                else
                {
                    ShowErrorMsg("Get Packet Size failed!", nPacketSize2);
                }
            }

            m_MyCamera2.MV_CC_SetEnumValue_NET("TriggerMode", (uint)MyCamera.MV_CAM_TRIGGER_MODE.MV_TRIGGER_MODE_OFF);

            bnGetParam2_Click(null, null);

            SetCtrlWhenOpen2();
        }

        private void btn_CloseDevice_Click(object sender, EventArgs e)
        {
            if (m_bGrabbing == true)
            {
                m_bGrabbing = false;
                m_hReceiveThread.Join();
            }

            if (m_BufForDriver != IntPtr.Zero)
            {
                Marshal.Release(m_BufForDriver);
            }

            if (m_MyCamera != null)
            {
                m_MyCamera.MV_CC_CloseDevice_NET();
                m_MyCamera.MV_CC_DestroyDevice_NET();
            }

            SetCtrlWhenClose();
        }

        private void btn_CloseDevice2_Click(object sender, EventArgs e)
        {
            if (m_bGrabbing2 == true)
            {
                m_bGrabbing2 = false;
                m_hReceiveThread2.Join();
            }

            if (m_BufForDriver2 != IntPtr.Zero)
            {
                Marshal.Release(m_BufForDriver2);
            }

            if (m_MyCamera2 != null)
            {
                m_MyCamera2.MV_CC_CloseDevice_NET();
                m_MyCamera2.MV_CC_DestroyDevice_NET();
            }

            SetCtrlWhenClose2();
        }

        // 参数设置相关方法
        private void bnGetParam_Click(object sender, EventArgs e)
        {
            MyCamera.MVCC_FLOATVALUE stParam = new MyCamera.MVCC_FLOATVALUE();
            int nRet = m_MyCamera.MV_CC_GetFloatValue_NET("ExposureTime", ref stParam);
            if (MyCamera.MV_OK == nRet)
            {
                tbExposure.Text = stParam.fCurValue.ToString("F1");
            }

            nRet = m_MyCamera.MV_CC_GetFloatValue_NET("Gain", ref stParam);
            if (MyCamera.MV_OK == nRet)
            {
                tbGain.Text = stParam.fCurValue.ToString("F1");
            }

            nRet = m_MyCamera.MV_CC_GetFloatValue_NET("ResultingFrameRate", ref stParam);
            if (MyCamera.MV_OK == nRet)
            {
                tbFrameRate.Text = stParam.fCurValue.ToString("F1");
            }
        }

        private void bnGetParam2_Click(object sender, EventArgs e)
        {
            MyCamera.MVCC_FLOATVALUE stParam = new MyCamera.MVCC_FLOATVALUE();
            int nRet = m_MyCamera2.MV_CC_GetFloatValue_NET("ExposureTime", ref stParam);
            if (MyCamera.MV_OK == nRet)
            {
                tbExposure2.Text = stParam.fCurValue.ToString("F1");
            }

            nRet = m_MyCamera2.MV_CC_GetFloatValue_NET("Gain", ref stParam);
            if (MyCamera.MV_OK == nRet)
            {
                tbGain2.Text = stParam.fCurValue.ToString("F1");
            }

            nRet = m_MyCamera2.MV_CC_GetFloatValue_NET("ResultingFrameRate", ref stParam);
            if (MyCamera.MV_OK == nRet)
            {
                tbFrameRate2.Text = stParam.fCurValue.ToString("F1");
            }
        }

        private void bnSetParam_Click(object sender, EventArgs e)
        {
            try
            {
                float.Parse(tbExposure.Text);
                float.Parse(tbGain.Text);
                float.Parse(tbFrameRate.Text);
            }
            catch
            {
                ShowErrorMsg("Please enter correct type!", 0);
                return;
            }

            m_MyCamera.MV_CC_SetEnumValue_NET("ExposureAuto", 0);
            int nRet = m_MyCamera.MV_CC_SetFloatValue_NET("ExposureTime", float.Parse(tbExposure.Text));
            if (nRet != MyCamera.MV_OK)
            {
                ShowErrorMsg("Set Exposure Time Fail!", nRet);
            }

            m_MyCamera.MV_CC_SetEnumValue_NET("GainAuto", 0);
            nRet = m_MyCamera.MV_CC_SetFloatValue_NET("Gain", float.Parse(tbGain.Text));
            if (nRet != MyCamera.MV_OK)
            {
                ShowErrorMsg("Set Gain Fail!", nRet);
            }

            nRet = m_MyCamera.MV_CC_SetFloatValue_NET("AcquisitionFrameRate", float.Parse(tbFrameRate.Text));
            if (nRet != MyCamera.MV_OK)
            {
                ShowErrorMsg("Set Frame Rate Fail!", nRet);
            }
        }

        private void bnSetParam2_Click(object sender, EventArgs e)
        {
            try
            {
                float.Parse(tbExposure2.Text);
                float.Parse(tbGain2.Text);
                float.Parse(tbFrameRate2.Text);
            }
            catch
            {
                ShowErrorMsg("Please enter correct type!", 0);
                return;
            }

            m_MyCamera2.MV_CC_SetEnumValue_NET("ExposureAuto", 0);
            int nRet = m_MyCamera2.MV_CC_SetFloatValue_NET("ExposureTime", float.Parse(tbExposure2.Text));
            if (nRet != MyCamera.MV_OK)
            {
                ShowErrorMsg("Set Exposure Time Fail!", nRet);
            }

            m_MyCamera2.MV_CC_SetEnumValue_NET("GainAuto", 0);
            nRet = m_MyCamera2.MV_CC_SetFloatValue_NET("Gain", float.Parse(tbGain2.Text));
            if (nRet != MyCamera.MV_OK)
            {
                ShowErrorMsg("Set Gain Fail!", nRet);
            }

            nRet = m_MyCamera2.MV_CC_SetFloatValue_NET("AcquisitionFrameRate", float.Parse(tbFrameRate2.Text));
            if (nRet != MyCamera.MV_OK)
            {
                ShowErrorMsg("Set Frame Rate Fail!", nRet);
            }
        }

        // 控件操作相关方法
        private void SetCtrlWhenOpen()
        {
            btn_OpenDevice.Enabled = false;
            btn_CloseDevice.Enabled = true;
            bnStartGrab.Enabled = true;
            bnStopGrab.Enabled = false;
            bnContinuesMode.Enabled = true;
            bnContinuesMode.Checked = true;
            bnTriggerMode.Enabled = true;
            cbSoftTrigger.Enabled = false;
            cbImageProcess.Enabled = true;
            bnTriggerExec.Enabled = false;

            tbExposure.Enabled = true;
            tbGain.Enabled = true;
            tbFrameRate.Enabled = true;
            bnGetParam.Enabled = true;
            bnSetParam.Enabled = true;
        }

        private void SetCtrlWhenOpen2()
        {
            btn_OpenDevice2.Enabled = false;
            btn_CloseDevice2.Enabled = true;
            bnStartGrab2.Enabled = true;
            bnStopGrab2.Enabled = false;
            bnContinuesMode2.Enabled = true;
            bnContinuesMode2.Checked = true;
            bnTriggerMode2.Enabled = true;
            cbSoftTrigger2.Enabled = false;
            cbImageProcess2.Enabled = true;
            bnTriggerExec2.Enabled = false;

            tbExposure2.Enabled = true;
            tbGain2.Enabled = true;
            tbFrameRate2.Enabled = true;
            bnGetParam2.Enabled = true;
            bnSetParam2.Enabled = true;
        }

        private void SetCtrlWhenClose()
        {
            btn_OpenDevice.Enabled = true;
            btn_CloseDevice.Enabled = false;
            bnStartGrab.Enabled = false;
            bnStopGrab.Enabled = false;
            bnContinuesMode.Enabled = false;
            bnTriggerMode.Enabled = false;
            cbSoftTrigger.Enabled = false;
            cbImageProcess.Enabled = false;
            bnTriggerExec.Enabled = false;

            tbExposure.Enabled = false;
            tbGain.Enabled = false;
            tbFrameRate.Enabled = false;
            bnGetParam.Enabled = false;
            bnSetParam.Enabled = false;
        }

        private void SetCtrlWhenClose2()
        {
            btn_OpenDevice2.Enabled = true;
            btn_CloseDevice2.Enabled = false;
            bnStartGrab2.Enabled = false;
            bnStopGrab2.Enabled = false;
            bnContinuesMode2.Enabled = false;
            bnTriggerMode2.Enabled = false;
            cbSoftTrigger2.Enabled = false;
            cbImageProcess2.Enabled = false;
            bnTriggerExec2.Enabled = false;

            tbExposure2.Enabled = false;
            tbGain2.Enabled = false;
            tbFrameRate2.Enabled = false;
            bnGetParam2.Enabled = false;
            bnSetParam2.Enabled = false;
        }

        private void SetCtrlWhenStartGrab()
        {
            bnStartGrab.Enabled = false;
            bnStopGrab.Enabled = true;

            if (bnTriggerMode.Checked && cbSoftTrigger.Checked)
            {
                bnTriggerExec.Enabled = true;
            }

            cbImageProcess.Enabled = true;
        }

        private void SetCtrlWhenStartGrab2()
        {
            bnStartGrab2.Enabled = false;
            bnStopGrab2.Enabled = true;

            if (bnTriggerMode2.Checked && cbSoftTrigger2.Checked)
            {
                bnTriggerExec2.Enabled = true;
            }

            cbImageProcess2.Enabled = true;
        }

        private void SetCtrlWhenStopGrab()
        {
            bnStartGrab.Enabled = true;
            bnStopGrab.Enabled = false;
            bnTriggerExec.Enabled = false;
        }

        private void SetCtrlWhenStopGrab2()
        {
            bnStartGrab2.Enabled = true;
            bnStopGrab2.Enabled = false;
            bnTriggerExec2.Enabled = false;
        }
        // 图像采集相关方法
        private void bnStartGrab_Click(object sender, EventArgs e)
        {
            int nRet = NecessaryOperBeforeGrab();
            if (MyCamera.MV_OK != nRet)
            {
                return;
            }

            m_bGrabbing = true;
            m_stFrameInfo.nFrameLen = 0;
            m_stFrameInfo.enPixelType = MyCamera.MvGvspPixelType.PixelType_Gvsp_Undefined;

            m_hReceiveThread = new Thread(ReceiveThreadProcess);
            m_hReceiveThread.Start();

            nRet = m_MyCamera.MV_CC_StartGrabbing_NET();
            if (MyCamera.MV_OK != nRet)
            {
                m_bGrabbing = false;
                m_hReceiveThread.Join();
                ShowErrorMsg("Start Grabbing Fail!", nRet);
                return;
            }

            SetCtrlWhenStartGrab();
        }

        private void bnStartGrab2_Click(object sender, EventArgs e)
        {
            int nRet = NecessaryOperBeforeGrab2();
            if (MyCamera.MV_OK != nRet)
            {
                return;
            }

            m_bGrabbing2 = true;
            m_stFrameInfo2.nFrameLen = 0;
            m_stFrameInfo2.enPixelType = MyCamera.MvGvspPixelType.PixelType_Gvsp_Undefined;

            m_hReceiveThread2 = new Thread(ReceiveThreadProcess2);
            m_hReceiveThread2.Start();

            nRet = m_MyCamera2.MV_CC_StartGrabbing_NET();
            if (MyCamera.MV_OK != nRet)
            {
                m_bGrabbing2 = false;
                m_hReceiveThread2.Join();
                ShowErrorMsg("Start Grabbing Fail!", nRet);
                return;
            }

            SetCtrlWhenStartGrab2();
        }

        private void bnStopGrab_Click(object sender, EventArgs e)
        {
            m_bGrabbing = false;
            m_hReceiveThread.Join();

            int nRet = m_MyCamera.MV_CC_StopGrabbing_NET();
            if (nRet != MyCamera.MV_OK)
            {
                ShowErrorMsg("Stop Grabbing Fail!", nRet);
            }

            SetCtrlWhenStopGrab();
        }

        private void bnStopGrab2_Click(object sender, EventArgs e)
        {
            m_bGrabbing2 = false;
            m_hReceiveThread2.Join();

            int nRet = m_MyCamera2.MV_CC_StopGrabbing_NET();
            if (nRet != MyCamera.MV_OK)
            {
                ShowErrorMsg("Stop Grabbing Fail!", nRet);
            }

            SetCtrlWhenStopGrab2();
        }

        // 图像接收线程
        public void ReceiveThreadProcess()
        {
            MyCamera.MV_FRAME_OUT stFrameInfo = new MyCamera.MV_FRAME_OUT();
            MyCamera.MV_DISPLAY_FRAME_INFO stDisplayInfo = new MyCamera.MV_DISPLAY_FRAME_INFO();
            MyCamera.MV_PIXEL_CONVERT_PARAM stConvertInfo = new MyCamera.MV_PIXEL_CONVERT_PARAM();
            int nRet = MyCamera.MV_OK;

            while (m_bGrabbing)
            {
                nRet = m_MyCamera.MV_CC_GetImageBuffer_NET(ref stFrameInfo, 1000);
                if (nRet == MyCamera.MV_OK)
                {
                    lock (BufForDriverLock)
                    {
                        if (m_BufForDriver == IntPtr.Zero || stFrameInfo.stFrameInfo.nFrameLen > m_nBufSizeForDriver)
                        {
                            if (m_BufForDriver != IntPtr.Zero)
                            {
                                Marshal.Release(m_BufForDriver);
                                m_BufForDriver = IntPtr.Zero;
                            }

                            m_BufForDriver = Marshal.AllocHGlobal((Int32)stFrameInfo.stFrameInfo.nFrameLen);
                            if (m_BufForDriver == IntPtr.Zero)
                            {
                                return;
                            }
                            m_nBufSizeForDriver = stFrameInfo.stFrameInfo.nFrameLen;
                        }

                        m_stFrameInfo = stFrameInfo.stFrameInfo;
                        CopyMemory(m_BufForDriver, stFrameInfo.pBufAddr, stFrameInfo.stFrameInfo.nFrameLen);

                        stConvertInfo.nWidth = stFrameInfo.stFrameInfo.nWidth;
                        stConvertInfo.nHeight = stFrameInfo.stFrameInfo.nHeight;
                        stConvertInfo.enSrcPixelType = stFrameInfo.stFrameInfo.enPixelType;
                        stConvertInfo.pSrcData = stFrameInfo.pBufAddr;
                        stConvertInfo.nSrcDataLen = stFrameInfo.stFrameInfo.nFrameLen;
                        stConvertInfo.pDstBuffer = m_ConvertDstBuf;
                        stConvertInfo.nDstBufferSize = m_nConvertDstBufLen;
                        if (PixelFormat.Format8bppIndexed == m_bitmap.PixelFormat)
                        {
                            stConvertInfo.enDstPixelType = MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono8;
                            m_MyCamera.MV_CC_ConvertPixelType_NET(ref stConvertInfo);
                        }
                        else
                        {
                            stConvertInfo.enDstPixelType = MyCamera.MvGvspPixelType.PixelType_Gvsp_BGR8_Packed;
                            m_MyCamera.MV_CC_ConvertPixelType_NET(ref stConvertInfo);
                        }

                        BitmapData bmpData = m_bitmap.LockBits(new Rectangle(0, 0, stConvertInfo.nWidth, stConvertInfo.nHeight),
                            ImageLockMode.ReadWrite, m_bitmap.PixelFormat);
                        CopyMemory(bmpData.Scan0, stConvertInfo.pDstBuffer, (UInt32)(bmpData.Stride * m_bitmap.Height));
                        m_bitmap.UnlockBits(bmpData);

                        if (IsImageProceee)
                        {
                            Mat mat = OpenCvSharp.Extensions.BitmapConverter.ToMat(m_bitmap);
                            ProcessAndDisplayImageAsync1(mat);
                        }
                    }

                    stDisplayInfo.hWnd = pictureBox1.Handle;
                    stDisplayInfo.pData = stFrameInfo.pBufAddr;
                    stDisplayInfo.nDataLen = stFrameInfo.stFrameInfo.nFrameLen;
                    stDisplayInfo.nWidth = stFrameInfo.stFrameInfo.nWidth;
                    stDisplayInfo.nHeight = stFrameInfo.stFrameInfo.nHeight;
                    stDisplayInfo.enPixelType = stFrameInfo.stFrameInfo.enPixelType;
                    m_MyCamera.MV_CC_DisplayOneFrame_NET(ref stDisplayInfo);

                    m_MyCamera.MV_CC_FreeImageBuffer_NET(ref stFrameInfo);
                }
                else
                {
                    if (bnTriggerMode.Checked)
                    {
                        Thread.Sleep(5);
                    }
                }
            }
        }

        public void ReceiveThreadProcess2()
        {
            MyCamera.MV_FRAME_OUT stFrameInfo = new MyCamera.MV_FRAME_OUT();
            MyCamera.MV_DISPLAY_FRAME_INFO stDisplayInfo = new MyCamera.MV_DISPLAY_FRAME_INFO();
            MyCamera.MV_PIXEL_CONVERT_PARAM stConvertInfo = new MyCamera.MV_PIXEL_CONVERT_PARAM();
            int nRet = MyCamera.MV_OK;

            while (m_bGrabbing2)
            {
                nRet = m_MyCamera2.MV_CC_GetImageBuffer_NET(ref stFrameInfo, 1000);
                if (nRet == MyCamera.MV_OK)
                {
                    lock (BufForDriverLock2)
                    {
                        if (m_BufForDriver2 == IntPtr.Zero || stFrameInfo.stFrameInfo.nFrameLen > m_nBufSizeForDriver2)
                        {
                            if (m_BufForDriver2 != IntPtr.Zero)
                            {
                                Marshal.Release(m_BufForDriver2);
                                m_BufForDriver2 = IntPtr.Zero;
                            }

                            m_BufForDriver2 = Marshal.AllocHGlobal((Int32)stFrameInfo.stFrameInfo.nFrameLen);
                            if (m_BufForDriver2 == IntPtr.Zero)
                            {
                                return;
                            }
                            m_nBufSizeForDriver2 = stFrameInfo.stFrameInfo.nFrameLen;
                        }

                        m_stFrameInfo2 = stFrameInfo.stFrameInfo;
                        CopyMemory(m_BufForDriver2, stFrameInfo.pBufAddr, stFrameInfo.stFrameInfo.nFrameLen);

                        stConvertInfo.nWidth = stFrameInfo.stFrameInfo.nWidth;
                        stConvertInfo.nHeight = stFrameInfo.stFrameInfo.nHeight;
                        stConvertInfo.enSrcPixelType = stFrameInfo.stFrameInfo.enPixelType;
                        stConvertInfo.pSrcData = stFrameInfo.pBufAddr;
                        stConvertInfo.nSrcDataLen = stFrameInfo.stFrameInfo.nFrameLen;
                        stConvertInfo.pDstBuffer = m_ConvertDstBuf2;
                        stConvertInfo.nDstBufferSize = m_nConvertDstBufLen2;
                        if (PixelFormat.Format8bppIndexed == m_bitmap2.PixelFormat)
                        {
                            stConvertInfo.enDstPixelType = MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono8;
                            m_MyCamera2.MV_CC_ConvertPixelType_NET(ref stConvertInfo);
                        }
                        else
                        {
                            stConvertInfo.enDstPixelType = MyCamera.MvGvspPixelType.PixelType_Gvsp_BGR8_Packed;
                            m_MyCamera2.MV_CC_ConvertPixelType_NET(ref stConvertInfo);
                        }

                        BitmapData bmpData = m_bitmap2.LockBits(new Rectangle(0, 0, stConvertInfo.nWidth, stConvertInfo.nHeight),
                            ImageLockMode.ReadWrite, m_bitmap2.PixelFormat);
                        CopyMemory(bmpData.Scan0, stConvertInfo.pDstBuffer, (UInt32)(bmpData.Stride * m_bitmap2.Height));
                        m_bitmap2.UnlockBits(bmpData);

                        if (IsImageProceee2)
                        {
                            Mat mat = OpenCvSharp.Extensions.BitmapConverter.ToMat(m_bitmap2);
                            ProcessAndDisplayImageAsync2(mat);
                        }
                    }

                    stDisplayInfo.hWnd = pictureBox3.Handle;
                    stDisplayInfo.pData = stFrameInfo.pBufAddr;
                    stDisplayInfo.nDataLen = stFrameInfo.stFrameInfo.nFrameLen;
                    stDisplayInfo.nWidth = stFrameInfo.stFrameInfo.nWidth;
                    stDisplayInfo.nHeight = stFrameInfo.stFrameInfo.nHeight;
                    stDisplayInfo.enPixelType = stFrameInfo.stFrameInfo.enPixelType;
                    m_MyCamera2.MV_CC_DisplayOneFrame_NET(ref stDisplayInfo);

                    m_MyCamera2.MV_CC_FreeImageBuffer_NET(ref stFrameInfo);
                }
                else
                {
                    if (bnTriggerMode2.Checked)
                    {
                        Thread.Sleep(5);
                    }
                }
            }
        }

        private (double Roll, double Pitch, double Yaw) MatrixToEulerAngles(Mat rotMat)
        {
            // 检查万向节锁（Gimbal Lock）
            if (Math.Abs(rotMat.At<double>(2, 0)) >= 0.99999)
            {
                double yaw = 0;
                double roll;
                double pitch;

                if (rotMat.At<double>(2, 0) > 0)
                {
                    pitch = -Math.PI / 2;
                    roll = yaw + Math.Atan2(-rotMat.At<double>(0, 1), -rotMat.At<double>(0, 2));
                }
                else
                {
                    pitch = Math.PI / 2;
                    roll = -yaw + Math.Atan2(rotMat.At<double>(0, 1), rotMat.At<double>(0, 2));
                }

                return (roll, pitch, yaw);
            }
            else
            {
                double pitch = -Math.Asin(rotMat.At<double>(2, 0));
                double roll = Math.Atan2(rotMat.At<double>(2, 1) / Math.Cos(pitch),
                                        rotMat.At<double>(2, 2) / Math.Cos(pitch));
                double yaw = Math.Atan2(rotMat.At<double>(1, 0) / Math.Cos(pitch),
                                       rotMat.At<double>(0, 0) / Math.Cos(pitch));

                return (roll, pitch, yaw);
            }
        }

        /*
        private Matrix4x4 GetCamera1ToWorldMatrix()
        {
            // 相机1在世界坐标系X轴负方向，距离原点CAMERA1_DISTANCE
            Matrix4x4 rotation = Matrix4x4.CreateRotationY((float)Math.PI / 2);  // 相机1朝向X轴正方向
            Matrix4x4 translation = Matrix4x4.CreateTranslation(-CAMERA1_DISTANCE, 0, 0);
            return Matrix4x4.Multiply(rotation, translation);
        }

        private Matrix4x4 GetCamera2ToWorldMatrix()
        {
            // 相机2在世界坐标系Y轴负方向，距离原点CAMERA2_DISTANCE
            Matrix4x4 rotation = Matrix4x4.CreateRotationX(-(float)Math.PI / 2);  // 相机2朝向Y轴正方向
            Matrix4x4 translation = Matrix4x4.CreateTranslation(0, -CAMERA2_DISTANCE, 0);
            return Matrix4x4.Multiply(rotation, translation);
        }

        private Matrix4x4 ToMatrix4x4(Mat cvMat)
        {
            return new Matrix4x4(
                (float)cvMat.At<double>(0, 0), (float)cvMat.At<double>(0, 1), (float)cvMat.At<double>(0, 2), 0,
                (float)cvMat.At<double>(1, 0), (float)cvMat.At<double>(1, 1), (float)cvMat.At<double>(1, 2), 0,
                (float)cvMat.At<double>(2, 0), (float)cvMat.At<double>(2, 1), (float)cvMat.At<double>(2, 2), 0,
                0, 0, 0, 1
            );
        }

        private (double Roll, double Pitch, double Yaw) CalculateEulerAngles(Matrix4x4 rotationMatrix)
        {
            // 输入为Matrix4x4的欧拉角计算逻辑
            double roll = Math.Atan2(rotationMatrix.M23, rotationMatrix.M33);
            double pitch = Math.Atan2(-rotationMatrix.M13,
                Math.Sqrt(rotationMatrix.M23 * rotationMatrix.M23 + rotationMatrix.M33 * rotationMatrix.M33));
            double yaw = Math.Atan2(rotationMatrix.M12, rotationMatrix.M11);

            return (
                Roll: roll * 180.0 / Math.PI,
                Pitch: pitch * 180.0 / Math.PI,
                Yaw: yaw * 180.0 / Math.PI
            );
        }
        */


        // 由marker推算cube位姿

        //Camera1
        private (double X, double Y, double Z, double Roll, double Pitch, double Yaw)
             EstimateCubePoseFromMarker1(int markerId, Mat rvec, Mat tvec)
        {
            try
            {
                using (var rotMat = new Mat())
                {
                    // 将旋转向量转换为旋转矩阵
                    Cv2.Rodrigues(rvec, rotMat);

                    // 获取该Marker直接到世界坐标系的变换矩阵
                    Mat worldTransform = markerTransforms[markerId].worldTransformMatrix;

                    // 使用矩阵乘法计算立方体的世界坐标系旋转
                    Mat cubeRotMat = rotMat * worldTransform;

                    // 相机坐标系下的位置
                    double xCam = tvec.Get<double>(0);
                    double yCam = tvec.Get<double>(1);
                    double zCam = tvec.Get<double>(2);

                    // 从补偿后的旋转矩阵中计算欧拉角
                    double roll = Math.Atan2(cubeRotMat.At<double>(2, 1), cubeRotMat.At<double>(2, 2));
                    double pitch = Math.Atan2(-cubeRotMat.At<double>(2, 0),
                        Math.Sqrt(cubeRotMat.At<double>(2, 1) * cubeRotMat.At<double>(2, 1) +
                                 cubeRotMat.At<double>(2, 2) * cubeRotMat.At<double>(2, 2)));
                    double yaw = Math.Atan2(cubeRotMat.At<double>(1, 0), cubeRotMat.At<double>(0, 0));

                    // 根据marker ID获取其在立方体上的偏移量
                    Vector3 offset = markerTransforms[markerId].offset;

                    // 使用旋转矩阵对偏移量进行旋转
                    double offsetX = rotMat.At<double>(0, 0) * offset.X +
                                   rotMat.At<double>(0, 1) * offset.Y +
                                   rotMat.At<double>(0, 2) * offset.Z;
                    double offsetY = rotMat.At<double>(1, 0) * offset.X +
                                   rotMat.At<double>(1, 1) * offset.Y +
                                   rotMat.At<double>(1, 2) * offset.Z;
                    double offsetZ = rotMat.At<double>(2, 0) * offset.X +
                                   rotMat.At<double>(2, 1) * offset.Y +
                                   rotMat.At<double>(2, 2) * offset.Z;

                    // 在相机坐标系中减去旋转后的偏移量以得到立方体中心位置
                    xCam -= offsetX;
                    yCam -= offsetY;
                    zCam -= offsetZ;

                    // 转换到世界坐标系
                    double xWorld = -zCam - CAMERA1_DISTANCE;  // 相机1的Z轴对应世界-X轴
                    double yWorld = -xCam;                     // 相机1的X轴对应世界-Y轴
                    double zWorld = yCam;                      // 相机1的Y轴对应世界Z轴

                    // 转换角度到度数
                    roll = roll * 180.0 / Math.PI;
                    pitch = pitch * 180.0 / Math.PI;
                    yaw = yaw * 180.0 / Math.PI;

                    // 释放临时矩阵
                    cubeRotMat.Dispose();

                    return (xWorld, yWorld, zWorld, roll, pitch, yaw);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error in EstimateCubePoseFromMarker1: {ex.Message}");
                return (0, 0, 0, 0, 0, 0);
            }
        }

        //Camera2
        private (double X, double Y, double Z, double Roll, double Pitch, double Yaw)
           EstimateCubePoseFromMarker2(int markerId, Mat rvec, Mat tvec)
        {
            try
            {
                using (var rotMat = new Mat())
                {
                    // 将旋转向量转换为旋转矩阵
                    Cv2.Rodrigues(rvec, rotMat);

                    // 获取该Marker直接到世界坐标系的变换矩阵
                    Mat worldTransform = markerTransforms[markerId].worldTransformMatrix;

                    // 使用矩阵乘法计算立方体的世界坐标系旋转
                    Mat cubeRotMat = rotMat * worldTransform;

                    // 相机坐标系下的位置
                    double xCam = tvec.Get<double>(0);
                    double yCam = tvec.Get<double>(1);
                    double zCam = tvec.Get<double>(2);

                    // 从补偿后的旋转矩阵中计算欧拉角
                    double roll = Math.Atan2(cubeRotMat.At<double>(2, 1), cubeRotMat.At<double>(2, 2));
                    double pitch = Math.Atan2(-cubeRotMat.At<double>(2, 0),
                        Math.Sqrt(cubeRotMat.At<double>(2, 1) * cubeRotMat.At<double>(2, 1) +
                                 cubeRotMat.At<double>(2, 2) * cubeRotMat.At<double>(2, 2)));
                    double yaw = Math.Atan2(cubeRotMat.At<double>(1, 0), cubeRotMat.At<double>(0, 0));

                    // 根据marker ID获取其在立方体上的偏移量
                    Vector3 offset = markerTransforms[markerId].offset;

                    // 使用旋转矩阵对偏移量进行旋转
                    double offsetX = rotMat.At<double>(0, 0) * offset.X +
                                   rotMat.At<double>(0, 1) * offset.Y +
                                   rotMat.At<double>(0, 2) * offset.Z;
                    double offsetY = rotMat.At<double>(1, 0) * offset.X +
                                   rotMat.At<double>(1, 1) * offset.Y +
                                   rotMat.At<double>(1, 2) * offset.Z;
                    double offsetZ = rotMat.At<double>(2, 0) * offset.X +
                                   rotMat.At<double>(2, 1) * offset.Y +
                                   rotMat.At<double>(2, 2) * offset.Z;

                    // 在相机坐标系中减去旋转后的偏移量以得到立方体中心位置
                    xCam -= offsetX;
                    yCam -= offsetY;
                    zCam -= offsetZ;

                    // 转换到世界坐标系
                    double xWorld = xCam;                      // 相机2的X轴对应世界X轴
                    double yWorld = -zCam - CAMERA2_DISTANCE;  // 相机2的Z轴对应世界-Y轴
                    double zWorld = yCam;                      // 相机2的Y轴对应世界Z轴

                    // 转换角度到度数
                    roll = roll * 180.0 / Math.PI;
                    pitch = pitch * 180.0 / Math.PI;
                    yaw = yaw * 180.0 / Math.PI;

                    // 记得释放临时矩阵
                    cubeRotMat.Dispose();

                    return (xWorld, yWorld, zWorld, roll, pitch, yaw);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error in EstimateCubePoseFromMarker2: {ex.Message}");
                return (0, 0, 0, 0, 0, 0);
            }
        }
        // 辅助方法：将角度标准化到 -180 到 180 度范围
        private double NormalizeAngle(double angle)
        {
            angle = angle % 360;
            if (angle > 180)
                angle -= 360;
            else if (angle < -180)
                angle += 360;
            return angle;
        }

        private double FuseAngles(double angle1, double angle2)
        {
            // 确保两个角度都在-180到180度范围内
            angle1 = NormalizeAngle(angle1);
            angle2 = NormalizeAngle(angle2);

            // 计算角度差
            double diff = angle2 - angle1;

            // 如果角度差大于180度，需要调整
            if (diff > 180)
                angle2 -= 360;
            else if (diff < -180)
                angle2 += 360;

            // 计算平均值并标准化
            return NormalizeAngle((angle1 + angle2) / 2);
        }

        /*
        private void DrawCubeCoordinateSystem(Mat image,
            Vector3 worldPosition,    // 世界坐标系中的位置
            Matrix4x4 worldRotation) // 世界坐标系中的旋转矩阵
        {
            float axisLength = CUBE_SIZE * 2;

            // 定义世界坐标系中的坐标轴
            Point3f[] worldAxisPoints = new Point3f[]
            {
                new Point3f(0, 0, 0),                // 原点
                new Point3f(axisLength, 0, 0),       // X轴终点（红色）
                new Point3f(0, axisLength, 0),       // Y轴终点（绿色）
                new Point3f(0, 0, axisLength)        // Z轴终点（蓝色）
            };

            // 将世界坐标系转换到相机坐标系
            Matrix4x4 worldToCamera = Matrix4x4.Invert(GetCamera1ToWorldMatrix());
            Vector3 cameraPosition = Vector3.Transform(worldPosition, worldToCamera);
            Matrix4x4 cameraRotation = Matrix4x4.Multiply(worldRotation, worldToCamera);

            // 转换为OpenCV可用的格式
            using (var tvec = new Mat(3, 1, MatType.CV_64F))
            using (var rvec = new Mat(3, 1, MatType.CV_64F))
            {
                // 设置平移向量
                tvec.Set(0, 0, cameraPosition.X);
                tvec.Set(1, 0, cameraPosition.Y);
                tvec.Set(2, 0, cameraPosition.Z);

                // 从旋转矩阵转换为旋转向量
                Mat rotMat = new Mat(3, 3, MatType.CV_64F);
                // 将Matrix4x4转换为Mat
                for (int i = 0; i < 3; i++)
                    for (int j = 0; j < 3; j++)
                        rotMat.Set(i, j, cameraRotation[i, j]);

                Cv2.Rodrigues(rotMat, rvec);

                // 投影坐标轴到图像平面
                using (var imagePoints = new Mat())
                {
                    Cv2.ProjectPoints(
                        InputArray.Create(worldAxisPoints),
                        rvec,
                        tvec,
                        cameraMatrix,
                        distCoeffs,
                        imagePoints
                    );

                    // 绘制坐标轴
                    DrawAxis(image, imagePoints);
                }
            }
        }
        */


        // 新增的 ArUco 检测相关代码
        private Mat ProcessImage1(Mat image, out Mat grayImage,
            out float X, out float Y, out float Z,
            out float Roll, out float Pitch, out float Yaw,
            out int selectedMarkerId)
        {
            X = 0; Y = 0; Z = 0;  // 初始化
            Roll = 0; Pitch = 0; Yaw = 0;
            selectedMarkerId = -1;

            grayImage = new Mat();
            Cv2.CvtColor(image, grayImage, ColorConversionCodes.BGR2GRAY);
            Mat outputImage = image.Clone();
            try
            {
                var dictionary = CvAruco.GetPredefinedDictionary(PredefinedDictionaryName.Dict5X5_250);
                var parameters = new DetectorParameters();
                Point2f[][] rejectedCorners;
                CvAruco.DetectMarkers(
                    grayImage,
                    dictionary,
                    out Point2f[][] corners,
                    out int[] ids,
                    parameters,
                    out rejectedCorners
                );
                if (ids != null && ids.Length > 0)
                {
                    CvAruco.DrawDetectedMarkers(outputImage, corners, ids);
                    var markersWithArea = Enumerable.Range(0, ids.Length)
                        .Select(i => new
                        {
                            Id = ids[i],
                            Corners = corners[i],
                            Area = CalculateMarkerArea(corners[i])
                        })
                        .OrderByDescending(m => m.Area)
                        .ToList();

                    var bestMarker = markersWithArea[0];
                    selectedMarkerId = bestMarker.Id;  // 记录使用的marker ID
                    using (var rvec = new Mat())
                    using (var tvec = new Mat())
                    {
                        Point3f[] objectPoints = new Point3f[]
                        {
                    new Point3f(-MARKER_SIZE/2, MARKER_SIZE/2, 0),
                    new Point3f(MARKER_SIZE/2, MARKER_SIZE/2, 0),
                    new Point3f(MARKER_SIZE/2, -MARKER_SIZE/2, 0),
                    new Point3f(-MARKER_SIZE/2, -MARKER_SIZE/2, 0)
                        };

                        Cv2.SolvePnP(
                            InputArray.Create(objectPoints),
                            InputArray.Create(bestMarker.Corners),
                            cameraMatrix,
                            distCoeffs,
                            rvec,
                            tvec
                        );

                        // 获取立方体位姿
                        var cubePose = EstimateCubePoseFromMarker1(bestMarker.Id, rvec, tvec);

                        // 更新姿态角度
                        X = (float)cubePose.X;
                        Y = (float)cubePose.Y;
                        Z = (float)cubePose.Z;
                        Roll = (float)cubePose.Roll;
                        Pitch = (float)cubePose.Pitch;
                        Yaw = (float)cubePose.Yaw;

                    }
                    /*
                    if (X != 0 || Y != 0 || Z != 0)  // 检测到有效位姿
                    {
                        Vector3 worldPosition = new Vector3(X, Y, Z);
                        Matrix4x4 worldRotation = Matrix4x4.CreateFromYawPitchRoll(
                            Yaw * (float)Math.PI / 180.0f,
                            Pitch * (float)Math.PI / 180.0f,
                            Roll * (float)Math.PI / 180.0f
                        );

                        DrawCubeCoordinateSystem(
                            processedImage,
                            worldPosition,
                            worldRotation
                        );
                    }
                    */
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error in image processing: {ex.Message}");
            }
            return outputImage;
        }
        private Mat ProcessImage2(Mat image, out Mat grayImage,
            out float X, out float Y, out float Z,
            out float Roll, out float Pitch, out float Yaw,
            out int selectedMarkerId)
        {
            X = 0; Y = 0; Z = 0;  // 初始化
            Roll = 0; Pitch = 0; Yaw = 0;
            selectedMarkerId = -1;

            grayImage = new Mat();
            Cv2.CvtColor(image, grayImage, ColorConversionCodes.BGR2GRAY);
            Mat outputImage = image.Clone();
            try
            {
                var dictionary = CvAruco.GetPredefinedDictionary(PredefinedDictionaryName.Dict5X5_250);
                var parameters = new DetectorParameters();
                Point2f[][] rejectedCorners;
                CvAruco.DetectMarkers(
                    grayImage,
                    dictionary,
                    out Point2f[][] corners,
                    out int[] ids,
                    parameters,
                    out rejectedCorners
                );
                if (ids != null && ids.Length > 0)
                {
                    CvAruco.DrawDetectedMarkers(outputImage, corners, ids);
                    var markersWithArea = Enumerable.Range(0, ids.Length)
                        .Select(i => new
                        {
                            Id = ids[i],
                            Corners = corners[i],
                            Area = CalculateMarkerArea(corners[i])
                        })
                        .OrderByDescending(m => m.Area)
                        .ToList();

                    var bestMarker = markersWithArea[0];
                    selectedMarkerId = bestMarker.Id;  // 记录使用的marker ID

                    using (var rvec = new Mat())
                    using (var tvec = new Mat())
                    {
                        Point3f[] objectPoints = new Point3f[]
                        {
                    new Point3f(-MARKER_SIZE/2, MARKER_SIZE/2, 0),
                    new Point3f(MARKER_SIZE/2, MARKER_SIZE/2, 0),
                    new Point3f(MARKER_SIZE/2, -MARKER_SIZE/2, 0),
                    new Point3f(-MARKER_SIZE/2, -MARKER_SIZE/2, 0)
                        };

                        Cv2.SolvePnP(
                            InputArray.Create(objectPoints),
                            InputArray.Create(bestMarker.Corners),
                            cameraMatrix,
                            distCoeffs,
                            rvec,
                            tvec
                        );

                        // 获取立方体位姿
                        var cubePose = EstimateCubePoseFromMarker2(bestMarker.Id, rvec, tvec);

                        // 更新姿态角度
                        X = (float)cubePose.X;
                        Y = (float)cubePose.Y;
                        Z = (float)cubePose.Z;
                        Roll = (float)cubePose.Roll;
                        Pitch = (float)cubePose.Pitch;
                        Yaw = (float)cubePose.Yaw;

                    }
                    /*
                    if (X != 0 || Y != 0 || Z != 0)  // 检测到有效位姿
                    {
                        Vector3 worldPosition = new Vector3(X, Y, Z);
                        Matrix4x4 worldRotation = Matrix4x4.CreateFromYawPitchRoll(
                            Yaw * (float)Math.PI / 180.0f,
                            Pitch * (float)Math.PI / 180.0f,
                            Roll * (float)Math.PI / 180.0f
                        );

                        DrawCubeCoordinateSystem(
                            processedImage,
                            worldPosition,
                            worldRotation
                        );
                    }
                    */
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error in image processing: {ex.Message}");
            }
            return outputImage;
        }

        // 异步图像处理相关方法

        private void ProcessAndDisplayImageAsync1(Mat mat)
        {
            Task.Run(() =>
            {
                Mat grayImage;
                float X, Y, Z;
                float Roll, Pitch, Yaw;
                int selectedMarkerId;
                Mat processedImage = ProcessImage1(mat, out grayImage,
                    out X, out Y, out Z,
                    out Roll, out Pitch, out Yaw,
                    out selectedMarkerId);

                lock (syncLock)
                {
                    camera1Pose = (X, Y, Z, Roll, Pitch, Yaw);

                    if (camera1Pose.HasValue && camera2Pose.HasValue)
                    {
                        ProcessCubeCenters(camera1Pose.Value, camera2Pose.Value);
                        camera1Pose = null;
                        camera2Pose = null;
                    }
                }


                this.Invoke((Action)(() =>
                {
                    string info =
                        $"Camera 1  \n" +
                        $"Marker ID: {selectedMarkerId}    \n" +
                        $"Position:     \n" +
                        $"X = {X:F2}    \n" +
                        $"Y = {Y:F2}    \n" +
                        $"Z = {Z:F2}    \n" +
                        $"Rotation:     \n" +
                        $"Roll = {Roll:F2}  \n" +
                        $"Pitch = {Pitch:F2}    \n" +
                        $"Yaw = {Yaw:F2}";
                    txt_Test.Text = info;
                    pictureBox2.Image = OpenCvSharp.Extensions.BitmapConverter.ToBitmap(processedImage);
                }));
            });
        }


        private void ProcessAndDisplayImageAsync2(Mat mat)
        {
            Task.Run(() =>
            {
                Mat grayImage;
                float X, Y, Z;
                float Roll, Pitch, Yaw;
                int selectedMarkerId;
                Mat processedImage = ProcessImage2(mat, out grayImage,
                    out X, out Y, out Z,
                    out Roll, out Pitch, out Yaw,
                    out selectedMarkerId);

                lock (syncLock)
                {
                    camera2Pose = (X, Y, Z, Roll, Pitch, Yaw);

                    if (camera1Pose.HasValue && camera2Pose.HasValue)
                    {
                        ProcessCubeCenters(camera1Pose.Value, camera2Pose.Value);
                        camera1Pose = null;
                        camera2Pose = null;
                    }
                }

                this.Invoke((Action)(() =>
                {
                    string info =
                        $"Camera 2  \n" +
                        $"Marker ID: {selectedMarkerId}     \n" +
                        $"Position:     \n" +
                        $"X = {X:F2}    \n" +
                        $"Y = {Y:F2}    \n" +
                        $"Z = {Z:F2}    \n" +
                        $"Rotation:     \n" +
                        $"Roll = {Roll:F2}  \n" +
                        $"Pitch = {Pitch:F2}    \n" +
                        $"Yaw = {Yaw:F2}";
                    txt_Test2.Text = info;
                    pictureBox4.Image = OpenCvSharp.Extensions.BitmapConverter.ToBitmap(processedImage);
                }));
            });
        }
        private void ProcessCubeCenters(
            (double X, double Y, double Z, double Roll, double Pitch, double Yaw) pose1,
            (double X, double Y, double Z, double Roll, double Pitch, double Yaw) pose2)
        {
            // 位置融合
            // 相机1（12点方向）提供Y和Z信息，相机2（3点方向）提供X和Z信息
            // Z值取两个相机的平均值，因为两个相机都能提供相对可靠的Z信息
            var fusedPose = (
                X: pose2.X,            // 从相机2获取X（相机2的X轴方向更可靠）
                Y: pose1.Y,            // 从相机1获取Y（相机1的X轴方向更可靠）
                Z: (pose1.Z + pose2.Z) / 2,  // Z取平均值

                // 姿态角度直接取平均
                Roll: -FuseAngles(pose1.Roll, pose2.Roll),
                Pitch: FuseAngles(pose1.Pitch, pose2.Pitch),
                Yaw: -FuseAngles(pose1.Yaw, pose2.Yaw)
               );

            // 更新显示
            string positionText =
                $"Fused Cube Pose:  \n" +
                $"Position (mm):    \n" +
                $"X = {fusedPose.X:F2} (get from Camera2)   \n" +
                $"Y = {fusedPose.Y:F2} (get from Camera1)   \n" +
                $"Z = {fusedPose.Z:F2} (averaged)   \n" +
                $"Rotation (deg):   \n" +
                $"Roll = {fusedPose.Roll:F2}    \n" +
                $"Pitch = {fusedPose.Pitch:F2}  \n" +
                $"Yaw = {fusedPose.Yaw:F2}";

            UpdateTextBox3(positionText);
        }

        // 触发模式相关方法
        private void bnContinuesMode_CheckedChanged(object sender, EventArgs e)
        {
            if (bnContinuesMode.Checked)
            {
                m_MyCamera.MV_CC_SetEnumValue_NET("TriggerMode", (uint)MyCamera.MV_CAM_TRIGGER_MODE.MV_TRIGGER_MODE_OFF);
                cbSoftTrigger.Enabled = false;
                bnTriggerExec.Enabled = false;
            }
        }

        private void bnTriggerMode_CheckedChanged(object sender, EventArgs e)
        {
            if (bnTriggerMode.Checked)
            {
                m_MyCamera.MV_CC_SetEnumValue_NET("TriggerMode", (uint)MyCamera.MV_CAM_TRIGGER_MODE.MV_TRIGGER_MODE_ON);

                if (cbSoftTrigger.Checked)
                {
                    m_MyCamera.MV_CC_SetEnumValue_NET("TriggerSource", (uint)MyCamera.MV_CAM_TRIGGER_SOURCE.MV_TRIGGER_SOURCE_SOFTWARE);
                    if (m_bGrabbing)
                    {
                        bnTriggerExec.Enabled = true;
                    }
                }
                else
                {
                    m_MyCamera.MV_CC_SetEnumValue_NET("TriggerSource", (uint)MyCamera.MV_CAM_TRIGGER_SOURCE.MV_TRIGGER_SOURCE_LINE0);
                }
                cbSoftTrigger.Enabled = true;
            }
        }

        // 软触发相关功能
        private void btn_Trigger_Click(object sender, EventArgs e)
        {
            int nRet = m_MyCamera.MV_CC_SetCommandValue_NET("TriggerSoftware");
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Trigger Software Fail!", nRet);
            }
            int nRet2 = m_MyCamera2.MV_CC_SetCommandValue_NET("TriggerSoftware");
            if (MyCamera.MV_OK != nRet2)
            {
                ShowErrorMsg("Trigger Software Fail!", nRet2);
            }
        }

        private void SoftTrigger()
        {
            while (IsTrigger)
            {
                int nRet = m_MyCamera.MV_CC_SetCommandValue_NET("TriggerSoftware");
                if (MyCamera.MV_OK != nRet)
                {
                    ShowErrorMsg("Trigger Software Fail!", nRet);
                }
                int nRet2 = m_MyCamera2.MV_CC_SetCommandValue_NET("TriggerSoftware");
                if (MyCamera.MV_OK != nRet2)
                {
                    ShowErrorMsg("Trigger Software Fail!", nRet2);
                }

                Thread.Sleep(100);
            }
        }

        // UI更新相关方法
        private void UpdateTextBox(string text)
        {
            if (txt_Test.InvokeRequired)
            {
                txt_Test.Invoke(new Action<string>(UpdateTextBox), text);
            }
            else
            {
                txt_Test.AppendText(text + Environment.NewLine);
                txt_Test.SelectionStart = txt_Test.Text.Length;
                txt_Test.ScrollToCaret();
            }
        }

        private void UpdateTextBox2(string text)
        {
            if (txt_Test2.InvokeRequired)
            {
                txt_Test2.Invoke(new Action<string>(UpdateTextBox2), text);
            }
            else
            {
                txt_Test2.AppendText(text + Environment.NewLine);
                txt_Test2.SelectionStart = txt_Test2.Text.Length;
                txt_Test2.ScrollToCaret();
            }
        }

        private void UpdateTextBox3(string text)
        {
            if (txt_Test3.InvokeRequired)
            {
                txt_Test3.Invoke(new Action<string>(UpdateTextBox3), text);
            }
            else
            {
                txt_Test3.AppendText(text + Environment.NewLine);
                txt_Test3.SelectionStart = txt_Test3.Text.Length;
                txt_Test3.ScrollToCaret();
            }
        }

        // 资源释放
        protected override void OnFormClosing(FormClosingEventArgs e)
        {
            base.OnFormClosing(e);

            // 释放OpenCV相关资源
            cameraMatrix?.Dispose();
            distCoeffs?.Dispose();

            // 释放世界变换矩阵资源
            foreach (var item in markerTransforms.Values)
            {
                item.worldTransformMatrix?.Dispose();
            }

            // 关闭相机
            if (m_MyCamera != null)
            {
                m_MyCamera.MV_CC_CloseDevice_NET();
                m_MyCamera.MV_CC_DestroyDevice_NET();
            }

            if (m_MyCamera2 != null)
            {
                m_MyCamera2.MV_CC_CloseDevice_NET();
                m_MyCamera2.MV_CC_DestroyDevice_NET();
            }
        }

        // 图像处理标志位相关
        private void cbImageProcess_CheckedChanged(object sender, EventArgs e)
        {
            IsImageProceee = cbImageProcess.Checked;
        }

        private void cbImageProcess2_CheckedChanged(object sender, EventArgs e)
        {
            IsImageProceee2 = cbImageProcess2.Checked;
        }

        // 软触发相关
        private void bnTriggerExec_Click(object sender, EventArgs e)
        {
            int nRet = m_MyCamera.MV_CC_SetCommandValue_NET("TriggerSoftware");
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("触发软件失败!", nRet);
            }
        }

        private void bnTriggerExec2_Click(object sender, EventArgs e)
        {
            int nRet = m_MyCamera2.MV_CC_SetCommandValue_NET("TriggerSoftware");
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("触发软件失败!", nRet);
            }
        }

        // 软触发选项变更
        private void cbSoftTrigger_CheckedChanged(object sender, EventArgs e)
        {
            if (cbSoftTrigger.Checked)
            {
                m_MyCamera.MV_CC_SetEnumValue_NET("TriggerSource", (uint)MyCamera.MV_CAM_TRIGGER_SOURCE.MV_TRIGGER_SOURCE_SOFTWARE);
                if (m_bGrabbing && bnTriggerMode.Checked)
                {
                    bnTriggerExec.Enabled = true;
                    btn_Trigger.Enabled = true;
                    button1.Enabled = true;
                    button2.Enabled = true;
                }
            }
            else
            {
                m_MyCamera.MV_CC_SetEnumValue_NET("TriggerSource", (uint)MyCamera.MV_CAM_TRIGGER_SOURCE.MV_TRIGGER_SOURCE_LINE0);
                bnTriggerExec.Enabled = false;
                btn_Trigger.Enabled = false;
                button1.Enabled = false;
                button2.Enabled = false;
            }
        }

        private void cbSoftTrigger2_CheckedChanged(object sender, EventArgs e)
        {
            if (cbSoftTrigger2.Checked)
            {
                m_MyCamera2.MV_CC_SetEnumValue_NET("TriggerSource", (uint)MyCamera.MV_CAM_TRIGGER_SOURCE.MV_TRIGGER_SOURCE_SOFTWARE);
                if (m_bGrabbing2 && bnTriggerMode2.Checked)
                {
                    bnTriggerExec2.Enabled = true;
                }
            }
            else
            {
                m_MyCamera2.MV_CC_SetEnumValue_NET("TriggerSource", (uint)MyCamera.MV_CAM_TRIGGER_SOURCE.MV_TRIGGER_SOURCE_LINE0);
                bnTriggerExec2.Enabled = false;
            }
        }

        // 触发模式变更
        private void bnTriggerMode2_CheckedChanged(object sender, EventArgs e)
        {
            if (bnTriggerMode2.Checked)
            {
                m_MyCamera2.MV_CC_SetEnumValue_NET("TriggerMode", (uint)MyCamera.MV_CAM_TRIGGER_MODE.MV_TRIGGER_MODE_ON);
                cbSoftTrigger2.Enabled = true;
                if (cbSoftTrigger2.Checked)
                {
                    m_MyCamera2.MV_CC_SetEnumValue_NET("TriggerSource", (uint)MyCamera.MV_CAM_TRIGGER_SOURCE.MV_TRIGGER_SOURCE_SOFTWARE);
                    if (m_bGrabbing2)
                    {
                        bnTriggerExec2.Enabled = true;
                    }
                }
            }
        }

        // 连续模式变更
        private void bnContinuesMode2_CheckedChanged(object sender, EventArgs e)
        {
            if (bnContinuesMode2.Checked)
            {
                m_MyCamera2.MV_CC_SetEnumValue_NET("TriggerMode", (uint)MyCamera.MV_CAM_TRIGGER_MODE.MV_TRIGGER_MODE_OFF);
                cbSoftTrigger2.Enabled = false;
                bnTriggerExec2.Enabled = false;
            }
        }

        // 文本框相关
        private void txt_Test_TextChanged(object sender, EventArgs e)
        {
        }

        private void txt_Test2_TextChanged(object sender, EventArgs e)
        {
        }

        // 按钮事件
        private void btn_Tset_Click(object sender, EventArgs e)
        {
            // 测试按钮功能实现  
        }

        private void button1_Click(object sender, EventArgs e)
        {
            // 开启持续软触发
            IsTrigger = true;
            TriggerThread = new Thread(SoftTrigger);
            TriggerThread.Start();
        }

        private void button2_Click(object sender, EventArgs e)
        {
            // 关闭持续软触发
            IsTrigger = false;
            TriggerThread.Join();
        }

        private void txt_Test2_TextChanged_1(object sender, EventArgs e)
        {

        }

        private void pictureBox2_Click(object sender, EventArgs e)
        {

        }

        private void pictureBox4_Click(object sender, EventArgs e)
        {

        }
    } // class Form1 结束


} // namespace 结束                                                                                                                                                                                 
