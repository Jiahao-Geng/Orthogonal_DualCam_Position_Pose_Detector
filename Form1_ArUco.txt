using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using MvCamCtrl;
using MvCamCtrl.NET;
using System.Threading;
using System.Runtime.InteropServices;
using System.Text.RegularExpressions;
using System.Drawing.Imaging;
using System.IO;
using System.Diagnostics;
using System.Collections.ObjectModel;
using OpenCvSharp;
using System.Numerics;
using OpenCvSharp.Aruco;
using Point = OpenCvSharp.Point;


namespace 海康威视图像采集及处理
{
    public partial class Form1 : Form
    {
        // DLL导入
        [DllImport("kernel32.dll", EntryPoint = "RtlMoveMemory", SetLastError = false)]
        private static extern void CopyMemory(IntPtr dest, IntPtr src, uint count);

        // 常量定义
        public const Int32 CUSTOMER_PIXEL_FORMAT = unchecked((Int32)0x80000000);

        // 相机1相关变量
        MyCamera.MV_CC_DEVICE_INFO_LIST m_stDeviceList = new MyCamera.MV_CC_DEVICE_INFO_LIST();
        private MyCamera m_MyCamera = new MyCamera();
        bool m_bGrabbing = false;
        Thread m_hReceiveThread = null;
        MyCamera.MV_FRAME_OUT_INFO_EX m_stFrameInfo = new MyCamera.MV_FRAME_OUT_INFO_EX();

        // 相机2相关变量
        MyCamera.MV_CC_DEVICE_INFO_LIST m_stDeviceList2 = new MyCamera.MV_CC_DEVICE_INFO_LIST();
        private MyCamera m_MyCamera2 = new MyCamera();
        bool m_bGrabbing2 = false;
        Thread m_hReceiveThread2 = null;
        MyCamera.MV_FRAME_OUT_INFO_EX m_stFrameInfo2 = new MyCamera.MV_FRAME_OUT_INFO_EX();

        // 相机1图像缓存相关
        UInt32 m_nBufSizeForDriver = 0;
        IntPtr m_BufForDriver = IntPtr.Zero;
        private static Object BufForDriverLock = new Object();
        Bitmap m_bitmap = null;
        PixelFormat m_bitmapPixelFormat = PixelFormat.DontCare;
        IntPtr m_ConvertDstBuf = IntPtr.Zero;
        UInt32 m_nConvertDstBufLen = 0;

        // 相机2图像缓存相关
        UInt32 m_nBufSizeForDriver2 = 0;
        IntPtr m_BufForDriver2 = IntPtr.Zero;
        private static Object BufForDriverLock2 = new Object();
        Bitmap m_bitmap2 = null;
        PixelFormat m_bitmapPixelFormat2 = PixelFormat.DontCare;
        IntPtr m_ConvertDstBuf2 = IntPtr.Zero;
        UInt32 m_nConvertDstBufLen2 = 0;

        // 图像处理相关变量
        private bool IsImageProceee = false;
        private bool IsImageProceee2 = false;
        //private int frameCounter = 0;
        private int frameCounter2 = 0;
        private bool IsTrigger = false;
        Thread TriggerThread = null;
        private object syncLock = new object();

        // ArUco检测相关变量
        private Mat cameraMatrix;
        private Mat distCoeffs;


        // 立方体常量
        private const float CUBE_SIZE = 35.0f;  // 立方体边长
        private const float MARKER_SIZE = 30.0f; // ArUco码边长

        // 修改相机姿态存储变量的定义（在类的成员变量部分）
        private (double X, double Y, double Z, double Roll, double Pitch, double Yaw)? camera1Pose = null;
        private (double X, double Y, double Z, double Roll, double Pitch, double Yaw)? camera2Pose = null;

        // 坐标系相关常量
        private const float CAMERA1_DISTANCE = -450.0f;  // 相机1到原点距离（X轴负方向）
        private const float CAMERA2_DISTANCE = -450.0f;  // 相机2到原点距离（Y轴负方向）

        // 定义Marker相对于立方体中心的变换关系
        private Dictionary<int, (Vector3 offset, Mat transformMatrix)> markerTransforms;


        //计算marker面积的辅助方法
        private double CalculateMarkerArea(Point2f[] corners)
        {
            double area = 0;
            for (int i = 0; i < 4; i++)
            {
                int j = (i + 1) % 4;
                area += corners[i].X * corners[j].Y - corners[j].X * corners[i].Y;
            }
            return Math.Abs(area) / 2;
        }



        public Form1()
        {
            InitializeComponent();

            // 初始化相机参数
            cameraMatrix = Mat.Eye(3, 3, MatType.CV_64F);
            cameraMatrix.Set<double>(0, 0, 1000.0); // fx
            cameraMatrix.Set<double>(1, 1, 1000.0); // fy
            cameraMatrix.Set<double>(0, 2, 1536 / 2.0); // cx
            cameraMatrix.Set<double>(1, 2, 1024 / 2.0); // cy

            distCoeffs = Mat.Zeros(rows: 1, cols: 5, type: MatType.CV_64F);

            // 使用新的初始化方法
            InitializeMarkerTransforms();

            // 其他初始化代码
            Control.CheckForIllegalCrossThreadCalls = false;
            this.Load += new EventHandler(Form1_Load);
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            // 初始化SDK
            MyCamera.MV_CC_Initialize_NET();
            // 枚举设备
            DeviceListAcq();
            DeviceListAcq2();
        }

        // 像素类型是否为Mono格式检查
        private Boolean IsMono(UInt32 enPixelType)
        {
            switch (enPixelType)
            {
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono1p:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono2p:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono4p:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono8:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono8_Signed:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono10:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono10_Packed:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono12:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono12_Packed:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono14:
                case (UInt32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono16:
                    return true;
                default:
                    return false;
            }
        }

        // 取图前的必要操作
        private Int32 NecessaryOperBeforeGrab()
        {
            // 获取图像宽度
            MyCamera.MVCC_INTVALUE_EX stWidth = new MyCamera.MVCC_INTVALUE_EX();
            int nRet = m_MyCamera.MV_CC_GetIntValueEx_NET("Width", ref stWidth);
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Get Width Info Fail!", nRet);
                return nRet;
            }

            // 获取图像高度
            MyCamera.MVCC_INTVALUE_EX stHeight = new MyCamera.MVCC_INTVALUE_EX();
            nRet = m_MyCamera.MV_CC_GetIntValueEx_NET("Height", ref stHeight);
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Get Height Info Fail!", nRet);
                return nRet;
            }

            // 获取像素格式
            MyCamera.MVCC_ENUMVALUE stPixelFormat = new MyCamera.MVCC_ENUMVALUE();
            nRet = m_MyCamera.MV_CC_GetEnumValue_NET("PixelFormat", ref stPixelFormat);
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Get Pixel Format Fail!", nRet);
                return nRet;
            }

            // 设置bitmap像素格式，分配内存
            if ((Int32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Undefined == (Int32)stPixelFormat.nCurValue)
            {
                ShowErrorMsg("Unknown Pixel Format!", MyCamera.MV_E_UNKNOW);
                return MyCamera.MV_E_UNKNOW;
            }
            else if (IsMono(stPixelFormat.nCurValue))
            {
                m_bitmapPixelFormat = PixelFormat.Format8bppIndexed;

                if (IntPtr.Zero != m_ConvertDstBuf)
                {
                    Marshal.Release(m_ConvertDstBuf);
                    m_ConvertDstBuf = IntPtr.Zero;
                }
                m_nConvertDstBufLen = (UInt32)(stWidth.nCurValue * stHeight.nCurValue);
                m_ConvertDstBuf = Marshal.AllocHGlobal((Int32)m_nConvertDstBufLen);
            }
            else
            {
                m_bitmapPixelFormat = PixelFormat.Format24bppRgb;

                if (IntPtr.Zero != m_ConvertDstBuf)
                {
                    Marshal.FreeHGlobal(m_ConvertDstBuf);
                    m_ConvertDstBuf = IntPtr.Zero;
                }
                m_nConvertDstBufLen = (UInt32)(3 * stWidth.nCurValue * stHeight.nCurValue);
                m_ConvertDstBuf = Marshal.AllocHGlobal((Int32)m_nConvertDstBufLen);
            }

            if (null != m_bitmap)
            {
                m_bitmap.Dispose();
                m_bitmap = null;
            }
            m_bitmap = new Bitmap((Int32)stWidth.nCurValue, (Int32)stHeight.nCurValue, m_bitmapPixelFormat);

            if (PixelFormat.Format8bppIndexed == m_bitmapPixelFormat)
            {
                ColorPalette palette = m_bitmap.Palette;
                for (int i = 0; i < palette.Entries.Length; i++)
                {
                    palette.Entries[i] = Color.FromArgb(i, i, i);
                }
                m_bitmap.Palette = palette;
            }

            return MyCamera.MV_OK;
        }

        // 显示错误信息
        private void ShowErrorMsg(string csMessage, int nErrorNum)
        {
            string errorMsg;
            if (nErrorNum == 0)
            {
                errorMsg = csMessage;
            }
            else
            {
                errorMsg = csMessage + ": Error =" + String.Format("{0:X}", nErrorNum);
            }

            switch (nErrorNum)
            {
                case MyCamera.MV_E_HANDLE: errorMsg += " Error or invalid handle "; break;
                case MyCamera.MV_E_SUPPORT: errorMsg += " Not supported function "; break;
                case MyCamera.MV_E_BUFOVER: errorMsg += " Cache is full "; break;
                case MyCamera.MV_E_CALLORDER: errorMsg += " Function calling order error "; break;
                case MyCamera.MV_E_PARAMETER: errorMsg += " Incorrect parameter "; break;
                case MyCamera.MV_E_RESOURCE: errorMsg += " Applying resource failed "; break;
                case MyCamera.MV_E_NODATA: errorMsg += " No data "; break;
                case MyCamera.MV_E_PRECONDITION: errorMsg += " Precondition error, or running environment changed "; break;
                case MyCamera.MV_E_VERSION: errorMsg += " Version mismatches "; break;
                case MyCamera.MV_E_NOENOUGH_BUF: errorMsg += " Insufficient memory "; break;
                case MyCamera.MV_E_UNKNOW: errorMsg += " Unknown error "; break;
                case MyCamera.MV_E_GC_GENERIC: errorMsg += " General error "; break;
                case MyCamera.MV_E_GC_ACCESS: errorMsg += " Node accessing condition error "; break;
                case MyCamera.MV_E_ACCESS_DENIED: errorMsg += " No permission "; break;
                case MyCamera.MV_E_BUSY: errorMsg += " Device is busy, or network disconnected "; break;
                case MyCamera.MV_E_NETER: errorMsg += " Network error "; break;
            }

            MessageBox.Show(errorMsg, "PROMPT");
        }

        // 用于清理设备名称中的空字符
        private string DeleteTail(string strUserDefinedName)
        {
            strUserDefinedName = Regex.Unescape(strUserDefinedName);
            int nIndex = strUserDefinedName.IndexOf("\0");
            if (nIndex >= 0)
            {
                strUserDefinedName = strUserDefinedName.Remove(nIndex);
            }
            return strUserDefinedName;
        }

        // 取图前的必要操作2
        private Int32 NecessaryOperBeforeGrab2()
        {
            MyCamera.MVCC_INTVALUE_EX stWidth = new MyCamera.MVCC_INTVALUE_EX();
            int nRet = m_MyCamera2.MV_CC_GetIntValueEx_NET("Width", ref stWidth);
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Get Width Info Fail!", nRet);
                return nRet;
            }

            MyCamera.MVCC_INTVALUE_EX stHeight = new MyCamera.MVCC_INTVALUE_EX();
            nRet = m_MyCamera2.MV_CC_GetIntValueEx_NET("Height", ref stHeight);
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Get Height Info Fail!", nRet);
                return nRet;
            }

            MyCamera.MVCC_ENUMVALUE stPixelFormat = new MyCamera.MVCC_ENUMVALUE();
            nRet = m_MyCamera2.MV_CC_GetEnumValue_NET("PixelFormat", ref stPixelFormat);
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Get Pixel Format Fail!", nRet);
                return nRet;
            }

            if ((Int32)MyCamera.MvGvspPixelType.PixelType_Gvsp_Undefined == (Int32)stPixelFormat.nCurValue)
            {
                ShowErrorMsg("Unknown Pixel Format!", MyCamera.MV_E_UNKNOW);
                return MyCamera.MV_E_UNKNOW;
            }
            else if (IsMono(stPixelFormat.nCurValue))
            {
                m_bitmapPixelFormat2 = PixelFormat.Format8bppIndexed;

                if (IntPtr.Zero != m_ConvertDstBuf2)
                {
                    Marshal.Release(m_ConvertDstBuf2);
                    m_ConvertDstBuf2 = IntPtr.Zero;
                }
                m_nConvertDstBufLen2 = (UInt32)(stWidth.nCurValue * stHeight.nCurValue);
                m_ConvertDstBuf2 = Marshal.AllocHGlobal((Int32)m_nConvertDstBufLen2);
            }
            else
            {
                m_bitmapPixelFormat2 = PixelFormat.Format24bppRgb;

                if (IntPtr.Zero != m_ConvertDstBuf2)
                {
                    Marshal.FreeHGlobal(m_ConvertDstBuf2);
                    m_ConvertDstBuf2 = IntPtr.Zero;
                }
                m_nConvertDstBufLen2 = (UInt32)(3 * stWidth.nCurValue * stHeight.nCurValue);
                m_ConvertDstBuf2 = Marshal.AllocHGlobal((Int32)m_nConvertDstBufLen2);
            }

            if (null != m_bitmap2)
            {
                m_bitmap2.Dispose();
                m_bitmap2 = null;
            }
            m_bitmap2 = new Bitmap((Int32)stWidth.nCurValue, (Int32)stHeight.nCurValue, m_bitmapPixelFormat2);

            if (PixelFormat.Format8bppIndexed == m_bitmapPixelFormat2)
            {
                ColorPalette palette = m_bitmap2.Palette;
                for (int i = 0; i < palette.Entries.Length; i++)
                {
                    palette.Entries[i] = Color.FromArgb(i, i, i);
                }
                m_bitmap2.Palette = palette;
            }

            return MyCamera.MV_OK;
        }

        // 设备枚举相关方法
        private void btn_Enum_Click(object sender, EventArgs e)
        {
            DeviceListAcq();
        }

        private void btn_Enum2_Click(object sender, EventArgs e)
        {
            DeviceListAcq2();
        }

        private void DeviceListAcq()
        {
            System.GC.Collect();
            cbDeviceList.Items.Clear();
            m_stDeviceList.nDeviceNum = 0;

            int nRet = MyCamera.MV_CC_EnumDevices_NET(MyCamera.MV_GIGE_DEVICE | MyCamera.MV_USB_DEVICE | MyCamera.MV_GENTL_GIGE_DEVICE
                | MyCamera.MV_GENTL_CAMERALINK_DEVICE | MyCamera.MV_GENTL_CXP_DEVICE | MyCamera.MV_GENTL_XOF_DEVICE, ref m_stDeviceList);

            if (0 != nRet)
            {
                ShowErrorMsg("Enumerate devices fail!", 0);
                return;
            }

            // 在窗体列表中显示设备名
            for (int i = 0; i < m_stDeviceList.nDeviceNum; i++)
            {
                MyCamera.MV_CC_DEVICE_INFO device = (MyCamera.MV_CC_DEVICE_INFO)Marshal.PtrToStructure(m_stDeviceList.pDeviceInfo[i], typeof(MyCamera.MV_CC_DEVICE_INFO));
                string strUserDefinedName = "";

                if (device.nTLayerType == MyCamera.MV_GIGE_DEVICE)
                {
                    MyCamera.MV_GIGE_DEVICE_INFO_EX gigeInfo = (MyCamera.MV_GIGE_DEVICE_INFO_EX)MyCamera.ByteToStruct(device.SpecialInfo.stGigEInfo, typeof(MyCamera.MV_GIGE_DEVICE_INFO_EX));

                    if ((gigeInfo.chUserDefinedName.Length > 0) && (gigeInfo.chUserDefinedName[0] != '\0'))
                    {
                        if (MyCamera.IsTextUTF8(gigeInfo.chUserDefinedName))
                            strUserDefinedName = Encoding.UTF8.GetString(gigeInfo.chUserDefinedName).TrimEnd('\0');
                        else
                            strUserDefinedName = Encoding.Default.GetString(gigeInfo.chUserDefinedName).TrimEnd('\0');
                        cbDeviceList.Items.Add("GEV: " + DeleteTail(strUserDefinedName) + " (" + gigeInfo.chSerialNumber + ")");
                    }
                    else
                    {
                        cbDeviceList.Items.Add("GEV: " + gigeInfo.chManufacturerName + " " + gigeInfo.chModelName + " (" + gigeInfo.chSerialNumber + ")");
                    }
                }
                else if (device.nTLayerType == MyCamera.MV_USB_DEVICE)
                {
                    MyCamera.MV_USB3_DEVICE_INFO_EX usbInfo = (MyCamera.MV_USB3_DEVICE_INFO_EX)MyCamera.ByteToStruct(device.SpecialInfo.stUsb3VInfo, typeof(MyCamera.MV_USB3_DEVICE_INFO_EX));

                    if ((usbInfo.chUserDefinedName.Length > 0) && (usbInfo.chUserDefinedName[0] != '\0'))
                    {
                        if (MyCamera.IsTextUTF8(usbInfo.chUserDefinedName))
                            strUserDefinedName = Encoding.UTF8.GetString(usbInfo.chUserDefinedName).TrimEnd('\0');
                        else
                            strUserDefinedName = Encoding.Default.GetString(usbInfo.chUserDefinedName).TrimEnd('\0');
                        cbDeviceList.Items.Add("U3V: " + DeleteTail(strUserDefinedName) + " (" + usbInfo.chSerialNumber + ")");
                    }
                    else
                    {
                        cbDeviceList.Items.Add("U3V: " + usbInfo.chManufacturerName + " " + usbInfo.chModelName + " (" + usbInfo.chSerialNumber + ")");
                    }
                }
            }

            if (m_stDeviceList.nDeviceNum != 0)
            {
                cbDeviceList.SelectedIndex = 0;
            }
        }

        private void DeviceListAcq2()
        {
            System.GC.Collect();
            cbDeviceList2.Items.Clear();
            m_stDeviceList2.nDeviceNum = 0;

            int nRet = MyCamera.MV_CC_EnumDevices_NET(MyCamera.MV_GIGE_DEVICE | MyCamera.MV_USB_DEVICE | MyCamera.MV_GENTL_GIGE_DEVICE
                | MyCamera.MV_GENTL_CAMERALINK_DEVICE | MyCamera.MV_GENTL_CXP_DEVICE | MyCamera.MV_GENTL_XOF_DEVICE, ref m_stDeviceList2);

            if (0 != nRet)
            {
                ShowErrorMsg("Enumerate devices fail!", 0);
                return;
            }

            // 在窗体列表中显示设备名
            for (int i = 0; i < m_stDeviceList2.nDeviceNum; i++)
            {
                MyCamera.MV_CC_DEVICE_INFO device = (MyCamera.MV_CC_DEVICE_INFO)Marshal.PtrToStructure(m_stDeviceList2.pDeviceInfo[i], typeof(MyCamera.MV_CC_DEVICE_INFO));
                string strUserDefinedName = "";

                if (device.nTLayerType == MyCamera.MV_GIGE_DEVICE)
                {
                    MyCamera.MV_GIGE_DEVICE_INFO_EX gigeInfo = (MyCamera.MV_GIGE_DEVICE_INFO_EX)MyCamera.ByteToStruct(device.SpecialInfo.stGigEInfo, typeof(MyCamera.MV_GIGE_DEVICE_INFO_EX));

                    if ((gigeInfo.chUserDefinedName.Length > 0) && (gigeInfo.chUserDefinedName[0] != '\0'))
                    {
                        if (MyCamera.IsTextUTF8(gigeInfo.chUserDefinedName))
                            strUserDefinedName = Encoding.UTF8.GetString(gigeInfo.chUserDefinedName).TrimEnd('\0');
                        else
                            strUserDefinedName = Encoding.Default.GetString(gigeInfo.chUserDefinedName).TrimEnd('\0');
                        cbDeviceList2.Items.Add("GEV: " + DeleteTail(strUserDefinedName) + " (" + gigeInfo.chSerialNumber + ")");
                    }
                    else
                    {
                        cbDeviceList2.Items.Add("GEV: " + gigeInfo.chManufacturerName + " " + gigeInfo.chModelName + " (" + gigeInfo.chSerialNumber + ")");
                    }
                }
                else if (device.nTLayerType == MyCamera.MV_USB_DEVICE)
                {
                    MyCamera.MV_USB3_DEVICE_INFO_EX usbInfo = (MyCamera.MV_USB3_DEVICE_INFO_EX)MyCamera.ByteToStruct(device.SpecialInfo.stUsb3VInfo, typeof(MyCamera.MV_USB3_DEVICE_INFO_EX));

                    if ((usbInfo.chUserDefinedName.Length > 0) && (usbInfo.chUserDefinedName[0] != '\0'))
                    {
                        if (MyCamera.IsTextUTF8(usbInfo.chUserDefinedName))
                            strUserDefinedName = Encoding.UTF8.GetString(usbInfo.chUserDefinedName).TrimEnd('\0');
                        else
                            strUserDefinedName = Encoding.Default.GetString(usbInfo.chUserDefinedName).TrimEnd('\0');
                        cbDeviceList2.Items.Add("U3V: " + DeleteTail(strUserDefinedName) + " (" + usbInfo.chSerialNumber + ")");
                    }
                    else
                    {
                        cbDeviceList2.Items.Add("U3V: " + usbInfo.chManufacturerName + " " + usbInfo.chModelName + " (" + usbInfo.chSerialNumber + ")");
                    }
                }
            }

            if (m_stDeviceList2.nDeviceNum != 0)
            {
                cbDeviceList2.SelectedIndex = 0;
            }
        }

        // 设备打开关闭相关方法
        private void btn_OpenDevice_Click(object sender, EventArgs e)
        {
            if (m_stDeviceList.nDeviceNum == 0 || cbDeviceList.SelectedIndex == -1)
            {
                ShowErrorMsg("No device, please select", 0);
                return;
            }

            MyCamera.MV_CC_DEVICE_INFO device =
                (MyCamera.MV_CC_DEVICE_INFO)Marshal.PtrToStructure(m_stDeviceList.pDeviceInfo[cbDeviceList.SelectedIndex],
                                                              typeof(MyCamera.MV_CC_DEVICE_INFO));

            if (null == m_MyCamera)
            {
                m_MyCamera = new MyCamera();
                if (null == m_MyCamera)
                {
                    ShowErrorMsg("Applying resource fail!", MyCamera.MV_E_RESOURCE);
                    return;
                }
            }

            int nRet = m_MyCamera.MV_CC_CreateDevice_NET(ref device);
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Create device fail!", nRet);
                return;
            }

            nRet = m_MyCamera.MV_CC_OpenDevice_NET();
            if (MyCamera.MV_OK != nRet)
            {
                m_MyCamera.MV_CC_DestroyDevice_NET();
                ShowErrorMsg("Device open fail!", nRet);
                return;
            }

            // 探测网络最佳包大小(只对GigE相机有效)
            if (device.nTLayerType == MyCamera.MV_GIGE_DEVICE)
            {
                int nPacketSize = m_MyCamera.MV_CC_GetOptimalPacketSize_NET();
                if (nPacketSize > 0)
                {
                    nRet = m_MyCamera.MV_CC_SetIntValueEx_NET("GevSCPSPacketSize", nPacketSize);
                    if (nRet != MyCamera.MV_OK)
                    {
                        ShowErrorMsg("Set Packet Size failed!", nRet);
                    }
                }
                else
                {
                    ShowErrorMsg("Get Packet Size failed!", nPacketSize);
                }
            }

            // 设置触发模式为off
            m_MyCamera.MV_CC_SetEnumValue_NET("TriggerMode", (uint)MyCamera.MV_CAM_TRIGGER_MODE.MV_TRIGGER_MODE_OFF);

            // 获取参数
            bnGetParam_Click(null, null);

            SetCtrlWhenOpen();
        }

        private void btn_OpenDevice2_Click(object sender, EventArgs e)
        {
            if (m_stDeviceList2.nDeviceNum == 0 || cbDeviceList2.SelectedIndex == -1)
            {
                ShowErrorMsg("No device, please select", 0);
                return;
            }

            MyCamera.MV_CC_DEVICE_INFO device2 =
                (MyCamera.MV_CC_DEVICE_INFO)Marshal.PtrToStructure(m_stDeviceList2.pDeviceInfo[cbDeviceList2.SelectedIndex],
                                                              typeof(MyCamera.MV_CC_DEVICE_INFO));

            if (null == m_MyCamera2)
            {
                m_MyCamera2 = new MyCamera();
                if (null == m_MyCamera2)
                {
                    ShowErrorMsg("Applying resource fail!", MyCamera.MV_E_RESOURCE);
                    return;
                }
            }

            int nRet = m_MyCamera2.MV_CC_CreateDevice_NET(ref device2);
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Create device fail!", nRet);
                return;
            }

            nRet = m_MyCamera2.MV_CC_OpenDevice_NET();
            if (MyCamera.MV_OK != nRet)
            {
                m_MyCamera2.MV_CC_DestroyDevice_NET();
                ShowErrorMsg("Device open fail!", nRet);
                return;
            }

            if (device2.nTLayerType == MyCamera.MV_GIGE_DEVICE)
            {
                int nPacketSize2 = m_MyCamera2.MV_CC_GetOptimalPacketSize_NET();
                if (nPacketSize2 > 0)
                {
                    nRet = m_MyCamera2.MV_CC_SetIntValueEx_NET("GevSCPSPacketSize", nPacketSize2);
                    if (nRet != MyCamera.MV_OK)
                    {
                        ShowErrorMsg("Set Packet Size failed!", nRet);
                    }
                }
                else
                {
                    ShowErrorMsg("Get Packet Size failed!", nPacketSize2);
                }
            }

            m_MyCamera2.MV_CC_SetEnumValue_NET("TriggerMode", (uint)MyCamera.MV_CAM_TRIGGER_MODE.MV_TRIGGER_MODE_OFF);

            bnGetParam2_Click(null, null);

            SetCtrlWhenOpen2();
        }

        private void btn_CloseDevice_Click(object sender, EventArgs e)
        {
            if (m_bGrabbing == true)
            {
                m_bGrabbing = false;
                m_hReceiveThread.Join();
            }

            if (m_BufForDriver != IntPtr.Zero)
            {
                Marshal.Release(m_BufForDriver);
            }

            if (m_MyCamera != null)
            {
                m_MyCamera.MV_CC_CloseDevice_NET();
                m_MyCamera.MV_CC_DestroyDevice_NET();
            }

            SetCtrlWhenClose();
        }

        private void btn_CloseDevice2_Click(object sender, EventArgs e)
        {
            if (m_bGrabbing2 == true)
            {
                m_bGrabbing2 = false;
                m_hReceiveThread2.Join();
            }

            if (m_BufForDriver2 != IntPtr.Zero)
            {
                Marshal.Release(m_BufForDriver2);
            }

            if (m_MyCamera2 != null)
            {
                m_MyCamera2.MV_CC_CloseDevice_NET();
                m_MyCamera2.MV_CC_DestroyDevice_NET();
            }

            SetCtrlWhenClose2();
        }

        // 参数设置相关方法
        private void bnGetParam_Click(object sender, EventArgs e)
        {
            MyCamera.MVCC_FLOATVALUE stParam = new MyCamera.MVCC_FLOATVALUE();
            int nRet = m_MyCamera.MV_CC_GetFloatValue_NET("ExposureTime", ref stParam);
            if (MyCamera.MV_OK == nRet)
            {
                tbExposure.Text = stParam.fCurValue.ToString("F1");
            }

            nRet = m_MyCamera.MV_CC_GetFloatValue_NET("Gain", ref stParam);
            if (MyCamera.MV_OK == nRet)
            {
                tbGain.Text = stParam.fCurValue.ToString("F1");
            }

            nRet = m_MyCamera.MV_CC_GetFloatValue_NET("ResultingFrameRate", ref stParam);
            if (MyCamera.MV_OK == nRet)
            {
                tbFrameRate.Text = stParam.fCurValue.ToString("F1");
            }
        }

        private void bnGetParam2_Click(object sender, EventArgs e)
        {
            MyCamera.MVCC_FLOATVALUE stParam = new MyCamera.MVCC_FLOATVALUE();
            int nRet = m_MyCamera2.MV_CC_GetFloatValue_NET("ExposureTime", ref stParam);
            if (MyCamera.MV_OK == nRet)
            {
                tbExposure2.Text = stParam.fCurValue.ToString("F1");
            }

            nRet = m_MyCamera2.MV_CC_GetFloatValue_NET("Gain", ref stParam);
            if (MyCamera.MV_OK == nRet)
            {
                tbGain2.Text = stParam.fCurValue.ToString("F1");
            }

            nRet = m_MyCamera2.MV_CC_GetFloatValue_NET("ResultingFrameRate", ref stParam);
            if (MyCamera.MV_OK == nRet)
            {
                tbFrameRate2.Text = stParam.fCurValue.ToString("F1");
            }
        }

        private void bnSetParam_Click(object sender, EventArgs e)
        {
            try
            {
                float.Parse(tbExposure.Text);
                float.Parse(tbGain.Text);
                float.Parse(tbFrameRate.Text);
            }
            catch
            {
                ShowErrorMsg("Please enter correct type!", 0);
                return;
            }

            m_MyCamera.MV_CC_SetEnumValue_NET("ExposureAuto", 0);
            int nRet = m_MyCamera.MV_CC_SetFloatValue_NET("ExposureTime", float.Parse(tbExposure.Text));
            if (nRet != MyCamera.MV_OK)
            {
                ShowErrorMsg("Set Exposure Time Fail!", nRet);
            }

            m_MyCamera.MV_CC_SetEnumValue_NET("GainAuto", 0);
            nRet = m_MyCamera.MV_CC_SetFloatValue_NET("Gain", float.Parse(tbGain.Text));
            if (nRet != MyCamera.MV_OK)
            {
                ShowErrorMsg("Set Gain Fail!", nRet);
            }

            nRet = m_MyCamera.MV_CC_SetFloatValue_NET("AcquisitionFrameRate", float.Parse(tbFrameRate.Text));
            if (nRet != MyCamera.MV_OK)
            {
                ShowErrorMsg("Set Frame Rate Fail!", nRet);
            }
        }

        private void bnSetParam2_Click(object sender, EventArgs e)
        {
            try
            {
                float.Parse(tbExposure2.Text);
                float.Parse(tbGain2.Text);
                float.Parse(tbFrameRate2.Text);
            }
            catch
            {
                ShowErrorMsg("Please enter correct type!", 0);
                return;
            }

            m_MyCamera2.MV_CC_SetEnumValue_NET("ExposureAuto", 0);
            int nRet = m_MyCamera2.MV_CC_SetFloatValue_NET("ExposureTime", float.Parse(tbExposure2.Text));
            if (nRet != MyCamera.MV_OK)
            {
                ShowErrorMsg("Set Exposure Time Fail!", nRet);
            }

            m_MyCamera2.MV_CC_SetEnumValue_NET("GainAuto", 0);
            nRet = m_MyCamera2.MV_CC_SetFloatValue_NET("Gain", float.Parse(tbGain2.Text));
            if (nRet != MyCamera.MV_OK)
            {
                ShowErrorMsg("Set Gain Fail!", nRet);
            }

            nRet = m_MyCamera2.MV_CC_SetFloatValue_NET("AcquisitionFrameRate", float.Parse(tbFrameRate2.Text));
            if (nRet != MyCamera.MV_OK)
            {
                ShowErrorMsg("Set Frame Rate Fail!", nRet);
            }
        }

        // 控件操作相关方法
        private void SetCtrlWhenOpen()
        {
            btn_OpenDevice.Enabled = false;
            btn_CloseDevice.Enabled = true;
            bnStartGrab.Enabled = true;
            bnStopGrab.Enabled = false;
            bnContinuesMode.Enabled = true;
            bnContinuesMode.Checked = true;
            bnTriggerMode.Enabled = true;
            cbSoftTrigger.Enabled = false;
            cbImageProcess.Enabled = true;
            bnTriggerExec.Enabled = false;

            tbExposure.Enabled = true;
            tbGain.Enabled = true;
            tbFrameRate.Enabled = true;
            bnGetParam.Enabled = true;
            bnSetParam.Enabled = true;
        }

        private void SetCtrlWhenOpen2()
        {
            btn_OpenDevice2.Enabled = false;
            btn_CloseDevice2.Enabled = true;
            bnStartGrab2.Enabled = true;
            bnStopGrab2.Enabled = false;
            bnContinuesMode2.Enabled = true;
            bnContinuesMode2.Checked = true;
            bnTriggerMode2.Enabled = true;
            cbSoftTrigger2.Enabled = false;
            cbImageProcess2.Enabled = true;
            bnTriggerExec2.Enabled = false;

            tbExposure2.Enabled = true;
            tbGain2.Enabled = true;
            tbFrameRate2.Enabled = true;
            bnGetParam2.Enabled = true;
            bnSetParam2.Enabled = true;
        }

        private void SetCtrlWhenClose()
        {
            btn_OpenDevice.Enabled = true;
            btn_CloseDevice.Enabled = false;
            bnStartGrab.Enabled = false;
            bnStopGrab.Enabled = false;
            bnContinuesMode.Enabled = false;
            bnTriggerMode.Enabled = false;
            cbSoftTrigger.Enabled = false;
            cbImageProcess.Enabled = false;
            bnTriggerExec.Enabled = false;

            tbExposure.Enabled = false;
            tbGain.Enabled = false;
            tbFrameRate.Enabled = false;
            bnGetParam.Enabled = false;
            bnSetParam.Enabled = false;
        }

        private void SetCtrlWhenClose2()
        {
            btn_OpenDevice2.Enabled = true;
            btn_CloseDevice2.Enabled = false;
            bnStartGrab2.Enabled = false;
            bnStopGrab2.Enabled = false;
            bnContinuesMode2.Enabled = false;
            bnTriggerMode2.Enabled = false;
            cbSoftTrigger2.Enabled = false;
            cbImageProcess2.Enabled = false;
            bnTriggerExec2.Enabled = false;

            tbExposure2.Enabled = false;
            tbGain2.Enabled = false;
            tbFrameRate2.Enabled = false;
            bnGetParam2.Enabled = false;
            bnSetParam2.Enabled = false;
        }

        private void SetCtrlWhenStartGrab()
        {
            bnStartGrab.Enabled = false;
            bnStopGrab.Enabled = true;

            if (bnTriggerMode.Checked && cbSoftTrigger.Checked)
            {
                bnTriggerExec.Enabled = true;
            }

            cbImageProcess.Enabled = true;
        }

        private void SetCtrlWhenStartGrab2()
        {
            bnStartGrab2.Enabled = false;
            bnStopGrab2.Enabled = true;

            if (bnTriggerMode2.Checked && cbSoftTrigger2.Checked)
            {
                bnTriggerExec2.Enabled = true;
            }

            cbImageProcess2.Enabled = true;
        }

        private void SetCtrlWhenStopGrab()
        {
            bnStartGrab.Enabled = true;
            bnStopGrab.Enabled = false;
            bnTriggerExec.Enabled = false;
        }

        private void SetCtrlWhenStopGrab2()
        {
            bnStartGrab2.Enabled = true;
            bnStopGrab2.Enabled = false;
            bnTriggerExec2.Enabled = false;
        }
        // 图像采集相关方法
        private void bnStartGrab_Click(object sender, EventArgs e)
        {
            int nRet = NecessaryOperBeforeGrab();
            if (MyCamera.MV_OK != nRet)
            {
                return;
            }

            m_bGrabbing = true;
            m_stFrameInfo.nFrameLen = 0;
            m_stFrameInfo.enPixelType = MyCamera.MvGvspPixelType.PixelType_Gvsp_Undefined;

            m_hReceiveThread = new Thread(ReceiveThreadProcess);
            m_hReceiveThread.Start();

            nRet = m_MyCamera.MV_CC_StartGrabbing_NET();
            if (MyCamera.MV_OK != nRet)
            {
                m_bGrabbing = false;
                m_hReceiveThread.Join();
                ShowErrorMsg("Start Grabbing Fail!", nRet);
                return;
            }

            SetCtrlWhenStartGrab();
        }

        private void bnStartGrab2_Click(object sender, EventArgs e)
        {
            int nRet = NecessaryOperBeforeGrab2();
            if (MyCamera.MV_OK != nRet)
            {
                return;
            }

            m_bGrabbing2 = true;
            m_stFrameInfo2.nFrameLen = 0;
            m_stFrameInfo2.enPixelType = MyCamera.MvGvspPixelType.PixelType_Gvsp_Undefined;

            m_hReceiveThread2 = new Thread(ReceiveThreadProcess2);
            m_hReceiveThread2.Start();

            nRet = m_MyCamera2.MV_CC_StartGrabbing_NET();
            if (MyCamera.MV_OK != nRet)
            {
                m_bGrabbing2 = false;
                m_hReceiveThread2.Join();
                ShowErrorMsg("Start Grabbing Fail!", nRet);
                return;
            }

            SetCtrlWhenStartGrab2();
        }

        private void bnStopGrab_Click(object sender, EventArgs e)
        {
            m_bGrabbing = false;
            m_hReceiveThread.Join();

            int nRet = m_MyCamera.MV_CC_StopGrabbing_NET();
            if (nRet != MyCamera.MV_OK)
            {
                ShowErrorMsg("Stop Grabbing Fail!", nRet);
            }

            SetCtrlWhenStopGrab();
        }

        private void bnStopGrab2_Click(object sender, EventArgs e)
        {
            m_bGrabbing2 = false;
            m_hReceiveThread2.Join();

            int nRet = m_MyCamera2.MV_CC_StopGrabbing_NET();
            if (nRet != MyCamera.MV_OK)
            {
                ShowErrorMsg("Stop Grabbing Fail!", nRet);
            }

            SetCtrlWhenStopGrab2();
        }

        // 图像接收线程
        public void ReceiveThreadProcess()
        {
            MyCamera.MV_FRAME_OUT stFrameInfo = new MyCamera.MV_FRAME_OUT();
            MyCamera.MV_DISPLAY_FRAME_INFO stDisplayInfo = new MyCamera.MV_DISPLAY_FRAME_INFO();
            MyCamera.MV_PIXEL_CONVERT_PARAM stConvertInfo = new MyCamera.MV_PIXEL_CONVERT_PARAM();
            int nRet = MyCamera.MV_OK;

            while (m_bGrabbing)
            {
                nRet = m_MyCamera.MV_CC_GetImageBuffer_NET(ref stFrameInfo, 1000);
                if (nRet == MyCamera.MV_OK)
                {
                    lock (BufForDriverLock)
                    {
                        if (m_BufForDriver == IntPtr.Zero || stFrameInfo.stFrameInfo.nFrameLen > m_nBufSizeForDriver)
                        {
                            if (m_BufForDriver != IntPtr.Zero)
                            {
                                Marshal.Release(m_BufForDriver);
                                m_BufForDriver = IntPtr.Zero;
                            }

                            m_BufForDriver = Marshal.AllocHGlobal((Int32)stFrameInfo.stFrameInfo.nFrameLen);
                            if (m_BufForDriver == IntPtr.Zero)
                            {
                                return;
                            }
                            m_nBufSizeForDriver = stFrameInfo.stFrameInfo.nFrameLen;
                        }

                        m_stFrameInfo = stFrameInfo.stFrameInfo;
                        CopyMemory(m_BufForDriver, stFrameInfo.pBufAddr, stFrameInfo.stFrameInfo.nFrameLen);

                        stConvertInfo.nWidth = stFrameInfo.stFrameInfo.nWidth;
                        stConvertInfo.nHeight = stFrameInfo.stFrameInfo.nHeight;
                        stConvertInfo.enSrcPixelType = stFrameInfo.stFrameInfo.enPixelType;
                        stConvertInfo.pSrcData = stFrameInfo.pBufAddr;
                        stConvertInfo.nSrcDataLen = stFrameInfo.stFrameInfo.nFrameLen;
                        stConvertInfo.pDstBuffer = m_ConvertDstBuf;
                        stConvertInfo.nDstBufferSize = m_nConvertDstBufLen;
                        if (PixelFormat.Format8bppIndexed == m_bitmap.PixelFormat)
                        {
                            stConvertInfo.enDstPixelType = MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono8;
                            m_MyCamera.MV_CC_ConvertPixelType_NET(ref stConvertInfo);
                        }
                        else
                        {
                            stConvertInfo.enDstPixelType = MyCamera.MvGvspPixelType.PixelType_Gvsp_BGR8_Packed;
                            m_MyCamera.MV_CC_ConvertPixelType_NET(ref stConvertInfo);
                        }

                        BitmapData bmpData = m_bitmap.LockBits(new Rectangle(0, 0, stConvertInfo.nWidth, stConvertInfo.nHeight),
                            ImageLockMode.ReadWrite, m_bitmap.PixelFormat);
                        CopyMemory(bmpData.Scan0, stConvertInfo.pDstBuffer, (UInt32)(bmpData.Stride * m_bitmap.Height));
                        m_bitmap.UnlockBits(bmpData);

                        if (IsImageProceee)
                        {
                            Mat mat = OpenCvSharp.Extensions.BitmapConverter.ToMat(m_bitmap);
                            ProcessAndDisplayImageAsync1(mat);
                        }
                    }

                    stDisplayInfo.hWnd = pictureBox1.Handle;
                    stDisplayInfo.pData = stFrameInfo.pBufAddr;
                    stDisplayInfo.nDataLen = stFrameInfo.stFrameInfo.nFrameLen;
                    stDisplayInfo.nWidth = stFrameInfo.stFrameInfo.nWidth;
                    stDisplayInfo.nHeight = stFrameInfo.stFrameInfo.nHeight;
                    stDisplayInfo.enPixelType = stFrameInfo.stFrameInfo.enPixelType;
                    m_MyCamera.MV_CC_DisplayOneFrame_NET(ref stDisplayInfo);

                    m_MyCamera.MV_CC_FreeImageBuffer_NET(ref stFrameInfo);
                }
                else
                {
                    if (bnTriggerMode.Checked)
                    {
                        Thread.Sleep(5);
                    }
                }
            }
        }

        public void ReceiveThreadProcess2()
        {
            MyCamera.MV_FRAME_OUT stFrameInfo = new MyCamera.MV_FRAME_OUT();
            MyCamera.MV_DISPLAY_FRAME_INFO stDisplayInfo = new MyCamera.MV_DISPLAY_FRAME_INFO();
            MyCamera.MV_PIXEL_CONVERT_PARAM stConvertInfo = new MyCamera.MV_PIXEL_CONVERT_PARAM();
            int nRet = MyCamera.MV_OK;

            while (m_bGrabbing2)
            {
                nRet = m_MyCamera2.MV_CC_GetImageBuffer_NET(ref stFrameInfo, 1000);
                if (nRet == MyCamera.MV_OK)
                {
                    lock (BufForDriverLock2)
                    {
                        if (m_BufForDriver2 == IntPtr.Zero || stFrameInfo.stFrameInfo.nFrameLen > m_nBufSizeForDriver2)
                        {
                            if (m_BufForDriver2 != IntPtr.Zero)
                            {
                                Marshal.Release(m_BufForDriver2);
                                m_BufForDriver2 = IntPtr.Zero;
                            }

                            m_BufForDriver2 = Marshal.AllocHGlobal((Int32)stFrameInfo.stFrameInfo.nFrameLen);
                            if (m_BufForDriver2 == IntPtr.Zero)
                            {
                                return;
                            }
                            m_nBufSizeForDriver2 = stFrameInfo.stFrameInfo.nFrameLen;
                        }

                        m_stFrameInfo2 = stFrameInfo.stFrameInfo;
                        CopyMemory(m_BufForDriver2, stFrameInfo.pBufAddr, stFrameInfo.stFrameInfo.nFrameLen);

                        stConvertInfo.nWidth = stFrameInfo.stFrameInfo.nWidth;
                        stConvertInfo.nHeight = stFrameInfo.stFrameInfo.nHeight;
                        stConvertInfo.enSrcPixelType = stFrameInfo.stFrameInfo.enPixelType;
                        stConvertInfo.pSrcData = stFrameInfo.pBufAddr;
                        stConvertInfo.nSrcDataLen = stFrameInfo.stFrameInfo.nFrameLen;
                        stConvertInfo.pDstBuffer = m_ConvertDstBuf2;
                        stConvertInfo.nDstBufferSize = m_nConvertDstBufLen2;
                        if (PixelFormat.Format8bppIndexed == m_bitmap2.PixelFormat)
                        {
                            stConvertInfo.enDstPixelType = MyCamera.MvGvspPixelType.PixelType_Gvsp_Mono8;
                            m_MyCamera2.MV_CC_ConvertPixelType_NET(ref stConvertInfo);
                        }
                        else
                        {
                            stConvertInfo.enDstPixelType = MyCamera.MvGvspPixelType.PixelType_Gvsp_BGR8_Packed;
                            m_MyCamera2.MV_CC_ConvertPixelType_NET(ref stConvertInfo);
                        }

                        BitmapData bmpData = m_bitmap2.LockBits(new Rectangle(0, 0, stConvertInfo.nWidth, stConvertInfo.nHeight),
                            ImageLockMode.ReadWrite, m_bitmap2.PixelFormat);
                        CopyMemory(bmpData.Scan0, stConvertInfo.pDstBuffer, (UInt32)(bmpData.Stride * m_bitmap2.Height));
                        m_bitmap2.UnlockBits(bmpData);

                        if (IsImageProceee2)
                        {
                            Mat mat = OpenCvSharp.Extensions.BitmapConverter.ToMat(m_bitmap2);
                            ProcessAndDisplayImageAsync2(mat);
                        }
                    }

                    stDisplayInfo.hWnd = pictureBox3.Handle;
                    stDisplayInfo.pData = stFrameInfo.pBufAddr;
                    stDisplayInfo.nDataLen = stFrameInfo.stFrameInfo.nFrameLen;
                    stDisplayInfo.nWidth = stFrameInfo.stFrameInfo.nWidth;
                    stDisplayInfo.nHeight = stFrameInfo.stFrameInfo.nHeight;
                    stDisplayInfo.enPixelType = stFrameInfo.stFrameInfo.enPixelType;
                    m_MyCamera2.MV_CC_DisplayOneFrame_NET(ref stDisplayInfo);

                    m_MyCamera2.MV_CC_FreeImageBuffer_NET(ref stFrameInfo);
                }
                else
                {
                    if (bnTriggerMode2.Checked)
                    {
                        Thread.Sleep(5);
                    }
                }
            }
        }




        // 初始化marker变换关系
        private void InitializeMarkerTransforms()
        {
            markerTransforms = new Dictionary<int, (Vector3 offset, Mat transformMatrix)>();

            // 定义立方体到世界坐标系的变换
            // 在本例中，立方体坐标系与世界坐标系一致，所以是单位矩阵
            Mat cubeToWorld = Mat.Eye(4, 4, MatType.CV_64F);

            // 定义Marker 1到立方体的变换矩阵
            Mat marker1ToCube = CreateHomogeneousMatrix();

            // 填充旋转部分：Z->X, X->-Y, Y->-Z
            marker1ToCube.Set<double>(0, 0, 0); marker1ToCube.Set<double>(0, 1, 0); marker1ToCube.Set<double>(0, 2, 1);
            marker1ToCube.Set<double>(1, 0, -1); marker1ToCube.Set<double>(1, 1, 0); marker1ToCube.Set<double>(1, 2, 0);
            marker1ToCube.Set<double>(2, 0, 0); marker1ToCube.Set<double>(2, 1, -1); marker1ToCube.Set<double>(2, 2, 0);

            // 设置平移部分（Marker 1位于立方体的前面，距离中心CUBE_SIZE/2）
            marker1ToCube.Set<double>(0, 3, -CUBE_SIZE / 2); // -X方向（立方体坐标系，移动到原点）
            marker1ToCube.Set<double>(1, 3, 0);
            marker1ToCube.Set<double>(2, 3, 0);

            // 计算Marker 1到世界坐标系的变换
            Mat marker1ToWorld = cubeToWorld * marker1ToCube;

            // 创建其他Marker的变换矩阵

            // Marker 3 - 后面，面向-X方向
            Mat marker3ToCube = CreateHomogeneousMatrix();
            // 旋转部分：Z->-X, X->Y, Y->-Z
            marker3ToCube.Set<double>(0, 0, 0); marker3ToCube.Set<double>(0, 1, 0); marker3ToCube.Set<double>(0, 2, -1);
            marker3ToCube.Set<double>(1, 0, 1); marker3ToCube.Set<double>(1, 1, 0); marker3ToCube.Set<double>(1, 2, 0);
            marker3ToCube.Set<double>(2, 0, 0); marker3ToCube.Set<double>(2, 1, -1); marker3ToCube.Set<double>(2, 2, 0);
            // 平移部分
            marker3ToCube.Set<double>(0, 3, CUBE_SIZE / 2); // +X方向
            marker3ToCube.Set<double>(1, 3, 0);
            marker3ToCube.Set<double>(2, 3, 0);

            // Marker 5 - 右面，面向-Y方向
            Mat marker5ToCube = CreateHomogeneousMatrix();
            // 旋转部分：Z->-Y, X->-X, Y->-Z
            marker5ToCube.Set<double>(0, 0, -1); marker5ToCube.Set<double>(0, 1, 0); marker5ToCube.Set<double>(0, 2, 0);
            marker5ToCube.Set<double>(1, 0, 0); marker5ToCube.Set<double>(1, 1, 0); marker5ToCube.Set<double>(1, 2, -1);
            marker5ToCube.Set<double>(2, 0, 0); marker5ToCube.Set<double>(2, 1, -1); marker5ToCube.Set<double>(2, 2, 0);
            // 平移部分
            marker5ToCube.Set<double>(0, 3, 0);
            marker5ToCube.Set<double>(1, 3, CUBE_SIZE / 2); // +Y方向
            marker5ToCube.Set<double>(2, 3, 0);

            // Marker 7 - 左面，面向+Y方向
            Mat marker7ToCube = CreateHomogeneousMatrix();
            // 旋转部分：Z->Y, X->X, Y->-Z
            marker7ToCube.Set<double>(0, 0, 1); marker7ToCube.Set<double>(0, 1, 0); marker7ToCube.Set<double>(0, 2, 0);
            marker7ToCube.Set<double>(1, 0, 0); marker7ToCube.Set<double>(1, 1, 0); marker7ToCube.Set<double>(1, 2, 1);
            marker7ToCube.Set<double>(2, 0, 0); marker7ToCube.Set<double>(2, 1, -1); marker7ToCube.Set<double>(2, 2, 0);
            // 平移部分
            marker7ToCube.Set<double>(0, 3, 0);
            marker7ToCube.Set<double>(1, 3, -CUBE_SIZE / 2); // -Y方向
            marker7ToCube.Set<double>(2, 3, 0);

            // Marker 9 - 底面，面向+Z方向
            Mat marker9ToCube = CreateHomogeneousMatrix();
            // 旋转部分：Z->Z, X->-Y, Y->X
            marker9ToCube.Set<double>(0, 0, 0); marker9ToCube.Set<double>(0, 1, -1); marker9ToCube.Set<double>(0, 2, 0);
            marker9ToCube.Set<double>(1, 0, 1); marker9ToCube.Set<double>(1, 1, 0); marker9ToCube.Set<double>(1, 2, 0);
            marker9ToCube.Set<double>(2, 0, 0); marker9ToCube.Set<double>(2, 1, 0); marker9ToCube.Set<double>(2, 2, 1);
            // 平移部分
            marker9ToCube.Set<double>(0, 3, 0);
            marker9ToCube.Set<double>(1, 3, 0);
            marker9ToCube.Set<double>(2, 3, -CUBE_SIZE / 2); // -Z方向

            // 计算所有Marker到世界坐标系的变换
            Mat marker3ToWorld = cubeToWorld * marker3ToCube;
            Mat marker5ToWorld = cubeToWorld * marker5ToCube;
            Mat marker7ToWorld = cubeToWorld * marker7ToCube;
            Mat marker9ToWorld = cubeToWorld * marker9ToCube;

            // 计算所有Marker到世界坐标系的逆变换（用于估计立方体位姿）
            Mat marker1ToWorldInv = marker1ToWorld.Inv();
            Mat marker3ToWorldInv = marker3ToWorld.Inv();
            Mat marker5ToWorldInv = marker5ToWorld.Inv();
            Mat marker7ToWorldInv = marker7ToWorld.Inv();
            Mat marker9ToWorldInv = marker9ToWorld.Inv();

            // 存储变换矩阵（用于从Marker估计立方体位姿）
            markerTransforms.Add(1, (new Vector3(CUBE_SIZE / 2, 0, 0), marker1ToWorldInv));
            markerTransforms.Add(3, (new Vector3(-CUBE_SIZE / 2, 0, 0), marker3ToWorldInv));
            markerTransforms.Add(5, (new Vector3(0, -CUBE_SIZE / 2, 0), marker5ToWorldInv));
            markerTransforms.Add(7, (new Vector3(0, CUBE_SIZE / 2, 0), marker7ToWorldInv));
            markerTransforms.Add(9, (new Vector3(0, 0, CUBE_SIZE / 2), marker9ToWorldInv));
        }

        // 创建4x4的齐次变换矩阵
        private Mat CreateHomogeneousMatrix()
        {
            Mat matrix = Mat.Eye(4, 4, MatType.CV_64F);
            return matrix;
        }

        // 创建相机1到世界坐标系的变换矩阵
        private Mat CreateCamera1ToWorldMatrix()
        {
            Mat transform = Mat.Eye(4, 4, MatType.CV_64F);

            // 旋转部分
            transform.Set<double>(0, 0, 0); transform.Set<double>(0, 1, 0); transform.Set<double>(0, 2, -1);
            transform.Set<double>(1, 0, -1); transform.Set<double>(1, 1, 0); transform.Set<double>(1, 2, 0);
            transform.Set<double>(2, 0, 0); transform.Set<double>(2, 1, 1); transform.Set<double>(2, 2, 0);

            // 平移部分
            transform.Set<double>(0, 3, -CAMERA1_DISTANCE);
            transform.Set<double>(1, 3, 0);
            transform.Set<double>(2, 3, 0);

            return transform;
        }

        // 创建相机2到世界坐标系的变换矩阵
        private Mat CreateCamera2ToWorldMatrix()
        {
            Mat transform = Mat.Eye(4, 4, MatType.CV_64F);

            // 旋转部分
            transform.Set<double>(0, 0, 1); transform.Set<double>(0, 1, 0); transform.Set<double>(0, 2, 0);
            transform.Set<double>(1, 0, 0); transform.Set<double>(1, 1, 0); transform.Set<double>(1, 2, -1);
            transform.Set<double>(2, 0, 0); transform.Set<double>(2, 1, 1); transform.Set<double>(2, 2, 0);

            // 平移部分
            transform.Set<double>(0, 3, 0);
            transform.Set<double>(1, 3, -CAMERA2_DISTANCE);
            transform.Set<double>(2, 3, 0);

            return transform;
        }

        // 使用变换链来估计立方体位姿（从相机1检测）
        private (double X, double Y, double Z, double Roll, double Pitch, double Yaw)
            EstimateCubePoseFromMarker1(int markerId, Mat rvec, Mat tvec)
        {
            try
            {
                // 1. 创建Marker到相机的变换矩阵
                Mat rotMat = new Mat();
                Cv2.Rodrigues(rvec, rotMat);

                Mat markerToCamera = CreateHomogeneousMatrix();
                // 填充旋转部分
                for (int i = 0; i < 3; i++)
                {
                    for (int j = 0; j < 3; j++)
                    {
                        markerToCamera.Set<double>(i, j, rotMat.At<double>(i, j));
                    }
                }
                // 填充平移部分
                markerToCamera.Set<double>(0, 3, tvec.Get<double>(0));
                markerToCamera.Set<double>(1, 3, tvec.Get<double>(1));
                markerToCamera.Set<double>(2, 3, tvec.Get<double>(2));

                // 2. 获取该Marker到世界坐标系的逆变换
                Mat worldToMarker = markerTransforms[markerId].transformMatrix;

                // 3. 创建相机到世界坐标系的变换
                Mat cameraToWorld = CreateCamera1ToWorldMatrix();

                // 4. 计算立方体在世界坐标系中的位姿
                // 变换链: 世界 <- 相机 <- Marker <- 立方体
                Mat worldToCube = worldToMarker * markerToCamera.Inv() * cameraToWorld.Inv();
                Mat cubeToWorld = worldToCube.Inv();

                // 5. 从变换矩阵中提取位置
                double xWorld = cubeToWorld.At<double>(0, 3);
                double yWorld = cubeToWorld.At<double>(1, 3);
                double zWorld = cubeToWorld.At<double>(2, 3);

                // 6. 从变换矩阵中提取欧拉角
                Mat rotationMatrix = new Mat(3, 3, MatType.CV_64F);
                for (int i = 0; i < 3; i++)
                {
                    for (int j = 0; j < 3; j++)
                    {
                        rotationMatrix.Set<double>(i, j, cubeToWorld.At<double>(i, j));
                    }
                }

                double roll = Math.Atan2(rotationMatrix.At<double>(2, 1), rotationMatrix.At<double>(2, 2));
                double pitch = Math.Atan2(-rotationMatrix.At<double>(2, 0),
                    Math.Sqrt(rotationMatrix.At<double>(2, 1) * rotationMatrix.At<double>(2, 1) +
                             rotationMatrix.At<double>(2, 2) * rotationMatrix.At<double>(2, 2)));
                double yaw = Math.Atan2(rotationMatrix.At<double>(1, 0), rotationMatrix.At<double>(0, 0));

                // 转换角度到度数
                roll = roll * 180.0 / Math.PI;
                pitch = pitch * 180.0 / Math.PI;
                yaw = yaw * 180.0 / Math.PI;

                // 清理资源
                rotMat.Dispose();
                markerToCamera.Dispose();
                rotationMatrix.Dispose();

                return (xWorld, yWorld, zWorld, roll, pitch, yaw);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error in EstimateCubePoseFromMarker1: {ex.Message}");
                return (0, 0, 0, 0, 0, 0);
            }
        }

        // 使用变换链来估计立方体位姿（从相机2检测）
        private (double X, double Y, double Z, double Roll, double Pitch, double Yaw)
            EstimateCubePoseFromMarker2(int markerId, Mat rvec, Mat tvec)
        {
            try
            {
                // 1. 创建Marker到相机的变换矩阵
                Mat rotMat = new Mat();
                Cv2.Rodrigues(rvec, rotMat);

                Mat markerToCamera = CreateHomogeneousMatrix();
                // 填充旋转部分
                for (int i = 0; i < 3; i++)
                {
                    for (int j = 0; j < 3; j++)
                    {
                        markerToCamera.Set<double>(i, j, rotMat.At<double>(i, j));
                    }
                }
                // 填充平移部分
                markerToCamera.Set<double>(0, 3, tvec.Get<double>(0));
                markerToCamera.Set<double>(1, 3, tvec.Get<double>(1));
                markerToCamera.Set<double>(2, 3, tvec.Get<double>(2));

                // 2. 获取该Marker到世界坐标系的逆变换
                Mat worldToMarker = markerTransforms[markerId].transformMatrix;

                // 3. 创建相机到世界坐标系的变换
                Mat cameraToWorld = CreateCamera2ToWorldMatrix();

                // 4. 计算立方体在世界坐标系中的位姿
                // 变换链: 世界 <- 相机 <- Marker <- 立方体
                Mat worldToCube = worldToMarker * markerToCamera.Inv() * cameraToWorld.Inv();
                Mat cubeToWorld = worldToCube.Inv();

                // 5. 从变换矩阵中提取位置
                double xWorld = cubeToWorld.At<double>(0, 3);
                double yWorld = cubeToWorld.At<double>(1, 3);
                double zWorld = cubeToWorld.At<double>(2, 3);

                // 6. 从变换矩阵中提取欧拉角
                Mat rotationMatrix = new Mat(3, 3, MatType.CV_64F);
                for (int i = 0; i < 3; i++)
                {
                    for (int j = 0; j < 3; j++)
                    {
                        rotationMatrix.Set<double>(i, j, cubeToWorld.At<double>(i, j));
                    }
                }

                double roll = Math.Atan2(rotationMatrix.At<double>(2, 1), rotationMatrix.At<double>(2, 2));
                double pitch = Math.Atan2(-rotationMatrix.At<double>(2, 0),
                    Math.Sqrt(rotationMatrix.At<double>(2, 1) * rotationMatrix.At<double>(2, 1) +
                             rotationMatrix.At<double>(2, 2) * rotationMatrix.At<double>(2, 2)));
                double yaw = Math.Atan2(rotationMatrix.At<double>(1, 0), rotationMatrix.At<double>(0, 0));

                // 转换角度到度数
                roll = roll * 180.0 / Math.PI;
                pitch = pitch * 180.0 / Math.PI;
                yaw = yaw * 180.0 / Math.PI;

                // 清理资源
                rotMat.Dispose();
                markerToCamera.Dispose();
                rotationMatrix.Dispose();

                return (xWorld, yWorld, zWorld, roll, pitch, yaw);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error in EstimateCubePoseFromMarker2: {ex.Message}");
                return (0, 0, 0, 0, 0, 0);
            }
        }
        // 辅助方法：将角度标准化到 -180 到 180 度范围
        private double NormalizeAngle(double angle)
        {
            angle = angle % 360;
            if (angle > 180)
                angle -= 360;
            else if (angle < -180)
                angle += 360;
            return angle;
        }

        private double FuseAngles(double angle1, double angle2)
        {
            // 确保两个角度都在-180到180度范围内
            angle1 = NormalizeAngle(angle1);
            angle2 = NormalizeAngle(angle2);

            // 计算角度差
            double diff = angle2 - angle1;

            // 如果角度差大于180度，需要调整
            if (diff > 180)
                angle2 -= 360;
            else if (diff < -180)
                angle2 += 360;

            // 计算平均值并标准化
            return NormalizeAngle((angle1 + angle2) / 2);
        }


        // 新增的 ArUco 检测相关代码
        private Mat ProcessImage1(Mat image, out Mat grayImage,
            out float X, out float Y, out float Z,
            out float Roll, out float Pitch, out float Yaw,
            out int selectedMarkerId)
        {
            X = 0; Y = 0; Z = 0;  // 初始化
            Roll = 0; Pitch = 0; Yaw = 0;
            selectedMarkerId = -1;

            grayImage = new Mat();
            Cv2.CvtColor(image, grayImage, ColorConversionCodes.BGR2GRAY);
            Mat outputImage = image.Clone();
            try
            {
                var dictionary = CvAruco.GetPredefinedDictionary(PredefinedDictionaryName.Dict5X5_250);
                var parameters = new DetectorParameters();
                Point2f[][] rejectedCorners;
                CvAruco.DetectMarkers(
                    grayImage,
                    dictionary,
                    out Point2f[][] corners,
                    out int[] ids,
                    parameters,
                    out rejectedCorners
                );
                if (ids != null && ids.Length > 0)
                {
                    CvAruco.DrawDetectedMarkers(outputImage, corners, ids);
                    var markersWithArea = Enumerable.Range(0, ids.Length)
                        .Select(i => new
                        {
                            Id = ids[i],
                            Corners = corners[i],
                            Area = CalculateMarkerArea(corners[i])
                        })
                        .OrderByDescending(m => m.Area)
                        .ToList();

                    var bestMarker = markersWithArea[0];
                    selectedMarkerId = bestMarker.Id;  // 记录使用的marker ID
                    using (var rvec = new Mat())
                    using (var tvec = new Mat())
                    {
                        Point3f[] objectPoints = new Point3f[]
                        {
                    new Point3f(-MARKER_SIZE/2, MARKER_SIZE/2, 0),
                    new Point3f(MARKER_SIZE/2, MARKER_SIZE/2, 0),
                    new Point3f(MARKER_SIZE/2, -MARKER_SIZE/2, 0),
                    new Point3f(-MARKER_SIZE/2, -MARKER_SIZE/2, 0)
                        };

                        Cv2.SolvePnP(
                            InputArray.Create(objectPoints),
                            InputArray.Create(bestMarker.Corners),
                            cameraMatrix,
                            distCoeffs,
                            rvec,
                            tvec
                        );

                        // 获取立方体位姿
                        var cubePose = EstimateCubePoseFromMarker1(bestMarker.Id, rvec, tvec);

                        // 更新姿态角度
                        X = (float)cubePose.X;
                        Y = (float)cubePose.Y;
                        Z = (float)cubePose.Z;
                        Roll = (float)cubePose.Roll;
                        Pitch = (float)cubePose.Pitch;
                        Yaw = (float)cubePose.Yaw;

                    }

                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error in image processing: {ex.Message}");
            }
            return outputImage;
        }
        private Mat ProcessImage2(Mat image, out Mat grayImage,
            out float X, out float Y, out float Z,
            out float Roll, out float Pitch, out float Yaw,
            out int selectedMarkerId)
        {
            X = 0; Y = 0; Z = 0;  // 初始化
            Roll = 0; Pitch = 0; Yaw = 0;
            selectedMarkerId = -1;

            grayImage = new Mat();
            Cv2.CvtColor(image, grayImage, ColorConversionCodes.BGR2GRAY);
            Mat outputImage = image.Clone();
            try
            {
                var dictionary = CvAruco.GetPredefinedDictionary(PredefinedDictionaryName.Dict5X5_250);
                var parameters = new DetectorParameters();
                Point2f[][] rejectedCorners;
                CvAruco.DetectMarkers(
                    grayImage,
                    dictionary,
                    out Point2f[][] corners,
                    out int[] ids,
                    parameters,
                    out rejectedCorners
                );
                if (ids != null && ids.Length > 0)
                {
                    CvAruco.DrawDetectedMarkers(outputImage, corners, ids);
                    var markersWithArea = Enumerable.Range(0, ids.Length)
                        .Select(i => new
                        {
                            Id = ids[i],
                            Corners = corners[i],
                            Area = CalculateMarkerArea(corners[i])
                        })
                        .OrderByDescending(m => m.Area)
                        .ToList();

                    var bestMarker = markersWithArea[0];
                    selectedMarkerId = bestMarker.Id;  // 记录使用的marker ID

                    using (var rvec = new Mat())
                    using (var tvec = new Mat())
                    {
                        Point3f[] objectPoints = new Point3f[]
                        {
                    new Point3f(-MARKER_SIZE/2, MARKER_SIZE/2, 0),
                    new Point3f(MARKER_SIZE/2, MARKER_SIZE/2, 0),
                    new Point3f(MARKER_SIZE/2, -MARKER_SIZE/2, 0),
                    new Point3f(-MARKER_SIZE/2, -MARKER_SIZE/2, 0)
                        };

                        Cv2.SolvePnP(
                            InputArray.Create(objectPoints),
                            InputArray.Create(bestMarker.Corners),
                            cameraMatrix,
                            distCoeffs,
                            rvec,
                            tvec
                        );

                        // 获取立方体位姿
                        var cubePose = EstimateCubePoseFromMarker2(bestMarker.Id, rvec, tvec);

                        // 更新姿态角度
                        X = (float)cubePose.X;
                        Y = (float)cubePose.Y;
                        Z = (float)cubePose.Z;
                        Roll = (float)cubePose.Roll;
                        Pitch = (float)cubePose.Pitch;
                        Yaw = (float)cubePose.Yaw;

                    }
                    /*
                    if (X != 0 || Y != 0 || Z != 0)  // 检测到有效位姿
                    {
                        Vector3 worldPosition = new Vector3(X, Y, Z);
                        Matrix4x4 worldRotation = Matrix4x4.CreateFromYawPitchRoll(
                            Yaw * (float)Math.PI / 180.0f,
                            Pitch * (float)Math.PI / 180.0f,
                            Roll * (float)Math.PI / 180.0f
                        );

                        DrawCubeCoordinateSystem(
                            processedImage,
                            worldPosition,
                            worldRotation
                        );
                    }
                    */
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error in image processing: {ex.Message}");
            }
            return outputImage;
        }

        // 异步图像处理相关方法

        private void ProcessAndDisplayImageAsync1(Mat mat)
        {
            Task.Run(() =>
            {
                Mat grayImage;
                float X, Y, Z;
                float Roll, Pitch, Yaw;
                int selectedMarkerId;
                Mat processedImage = ProcessImage1(mat, out grayImage,
                    out X, out Y, out Z,
                    out Roll, out Pitch, out Yaw,
                    out selectedMarkerId);

                lock (syncLock)
                {
                    camera1Pose = (X, Y, Z, Roll, Pitch, Yaw);

                    if (camera1Pose.HasValue && camera2Pose.HasValue)
                    {
                        ProcessCubeCenters(camera1Pose.Value, camera2Pose.Value);
                        camera1Pose = null;
                        camera2Pose = null;
                    }
                }


                this.Invoke((Action)(() =>
                {
                    string info =
                        $"Camera 1  \n" +
                        $"Marker ID: {selectedMarkerId}    \n" +
                        $"Position:     \n" +
                        $"X = {X:F2}    \n" +
                        $"Y = {Y:F2}    \n" +
                        $"Z = {Z:F2}    \n" +
                        $"Rotation:     \n" +
                        $"Roll = {Roll:F2}  \n" +
                        $"Pitch = {Pitch:F2}    \n" +
                        $"Yaw = {Yaw:F2}";
                    txt_Test.Text = info;
                    pictureBox2.Image = OpenCvSharp.Extensions.BitmapConverter.ToBitmap(processedImage);
                }));
            });
        }


        private void ProcessAndDisplayImageAsync2(Mat mat)
        {
            Task.Run(() =>
            {
                Mat grayImage;
                float X, Y, Z;
                float Roll, Pitch, Yaw;
                int selectedMarkerId;
                Mat processedImage = ProcessImage2(mat, out grayImage,
                    out X, out Y, out Z,
                    out Roll, out Pitch, out Yaw,
                    out selectedMarkerId);

                lock (syncLock)
                {
                    camera2Pose = (X, Y, Z, Roll, Pitch, Yaw);

                    if (camera1Pose.HasValue && camera2Pose.HasValue)
                    {
                        ProcessCubeCenters(camera1Pose.Value, camera2Pose.Value);
                        camera1Pose = null;
                        camera2Pose = null;
                    }
                }

                this.Invoke((Action)(() =>
                {
                    string info =
                        $"Camera 2  \n" +
                        $"Marker ID: {selectedMarkerId}     \n" +
                        $"Position:     \n" +
                        $"X = {X:F2}    \n" +
                        $"Y = {Y:F2}    \n" +
                        $"Z = {Z:F2}    \n" +
                        $"Rotation:     \n" +
                        $"Roll = {Roll:F2}  \n" +
                        $"Pitch = {Pitch:F2}    \n" +
                        $"Yaw = {Yaw:F2}";
                    txt_Test2.Text = info;
                    pictureBox4.Image = OpenCvSharp.Extensions.BitmapConverter.ToBitmap(processedImage);
                }));
            });
        }
        private void ProcessCubeCenters(
            (double X, double Y, double Z, double Roll, double Pitch, double Yaw) pose1,
            (double X, double Y, double Z, double Roll, double Pitch, double Yaw) pose2)
        {
            // 位置融合
            // 相机1（12点方向）提供Y和Z信息，相机2（3点方向）提供X和Z信息
            // Z值取两个相机的平均值，因为两个相机都能提供相对可靠的Z信息
            var fusedPose = (
                X: pose2.X,            // 从相机2获取X（相机2的X轴方向更可靠）
                Y: pose1.Y,            // 从相机1获取Y（相机1的X轴方向更可靠）
                Z: (pose1.Z + pose2.Z) / 2,  // Z取平均值

                // 姿态角度直接取平均
                Roll: -FuseAngles(pose1.Roll, pose2.Roll),
                Pitch: FuseAngles(pose1.Pitch, pose2.Pitch),
                Yaw: -FuseAngles(pose1.Yaw, pose2.Yaw)
               );

            // 更新显示
            string positionText =
                $"Fused Cube Pose:  \n" +
                $"Position (mm):    \n" +
                $"X = {fusedPose.X:F2} (get from Camera2)   \n" +
                $"Y = {fusedPose.Y:F2} (get from Camera1)   \n" +
                $"Z = {fusedPose.Z:F2} (averaged)   \n" +
                $"Rotation (deg):   \n" +
                $"Roll = {fusedPose.Roll:F2}    \n" +
                $"Pitch = {fusedPose.Pitch:F2}  \n" +
                $"Yaw = {fusedPose.Yaw:F2}";

            UpdateTextBox3(positionText);
        }

        // 触发模式相关方法
        private void bnContinuesMode_CheckedChanged(object sender, EventArgs e)
        {
            if (bnContinuesMode.Checked)
            {
                m_MyCamera.MV_CC_SetEnumValue_NET("TriggerMode", (uint)MyCamera.MV_CAM_TRIGGER_MODE.MV_TRIGGER_MODE_OFF);
                cbSoftTrigger.Enabled = false;
                bnTriggerExec.Enabled = false;
            }
        }

        private void bnTriggerMode_CheckedChanged(object sender, EventArgs e)
        {
            if (bnTriggerMode.Checked)
            {
                m_MyCamera.MV_CC_SetEnumValue_NET("TriggerMode", (uint)MyCamera.MV_CAM_TRIGGER_MODE.MV_TRIGGER_MODE_ON);

                if (cbSoftTrigger.Checked)
                {
                    m_MyCamera.MV_CC_SetEnumValue_NET("TriggerSource", (uint)MyCamera.MV_CAM_TRIGGER_SOURCE.MV_TRIGGER_SOURCE_SOFTWARE);
                    if (m_bGrabbing)
                    {
                        bnTriggerExec.Enabled = true;
                    }
                }
                else
                {
                    m_MyCamera.MV_CC_SetEnumValue_NET("TriggerSource", (uint)MyCamera.MV_CAM_TRIGGER_SOURCE.MV_TRIGGER_SOURCE_LINE0);
                }
                cbSoftTrigger.Enabled = true;
            }
        }

        // 软触发相关功能
        private void btn_Trigger_Click(object sender, EventArgs e)
        {
            int nRet = m_MyCamera.MV_CC_SetCommandValue_NET("TriggerSoftware");
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("Trigger Software Fail!", nRet);
            }
            int nRet2 = m_MyCamera2.MV_CC_SetCommandValue_NET("TriggerSoftware");
            if (MyCamera.MV_OK != nRet2)
            {
                ShowErrorMsg("Trigger Software Fail!", nRet2);
            }
        }

        private void SoftTrigger()
        {
            while (IsTrigger)
            {
                int nRet = m_MyCamera.MV_CC_SetCommandValue_NET("TriggerSoftware");
                if (MyCamera.MV_OK != nRet)
                {
                    ShowErrorMsg("Trigger Software Fail!", nRet);
                }
                int nRet2 = m_MyCamera2.MV_CC_SetCommandValue_NET("TriggerSoftware");
                if (MyCamera.MV_OK != nRet2)
                {
                    ShowErrorMsg("Trigger Software Fail!", nRet2);
                }

                Thread.Sleep(100);
            }
        }

        // UI更新相关方法
        private void UpdateTextBox(string text)
        {
            if (txt_Test.InvokeRequired)
            {
                txt_Test.Invoke(new Action<string>(UpdateTextBox), text);
            }
            else
            {
                txt_Test.AppendText(text + Environment.NewLine);
                txt_Test.SelectionStart = txt_Test.Text.Length;
                txt_Test.ScrollToCaret();
            }
        }

        private void UpdateTextBox2(string text)
        {
            if (txt_Test2.InvokeRequired)
            {
                txt_Test2.Invoke(new Action<string>(UpdateTextBox2), text);
            }
            else
            {
                txt_Test2.AppendText(text + Environment.NewLine);
                txt_Test2.SelectionStart = txt_Test2.Text.Length;
                txt_Test2.ScrollToCaret();
            }
        }

        private void UpdateTextBox3(string text)
        {
            if (txt_Test3.InvokeRequired)
            {
                txt_Test3.Invoke(new Action<string>(UpdateTextBox3), text);
            }
            else
            {
                txt_Test3.AppendText(text + Environment.NewLine);
                txt_Test3.SelectionStart = txt_Test3.Text.Length;
                txt_Test3.ScrollToCaret();
            }
        }

        // 资源释放
        protected override void OnFormClosing(FormClosingEventArgs e)
        {
            base.OnFormClosing(e);

            // 释放OpenCV相关资源
            cameraMatrix?.Dispose();
            distCoeffs?.Dispose();

            // 释放世界变换矩阵资源
            foreach (var item in markerTransforms.Values)
            {
                item.transformMatrix?.Dispose();
            }

            // 关闭相机
            if (m_MyCamera != null)
            {
                m_MyCamera.MV_CC_CloseDevice_NET();
                m_MyCamera.MV_CC_DestroyDevice_NET();
            }

            if (m_MyCamera2 != null)
            {
                m_MyCamera2.MV_CC_CloseDevice_NET();
                m_MyCamera2.MV_CC_DestroyDevice_NET();
            }
        }

        // 图像处理标志位相关
        private void cbImageProcess_CheckedChanged(object sender, EventArgs e)
        {
            IsImageProceee = cbImageProcess.Checked;
        }

        private void cbImageProcess2_CheckedChanged(object sender, EventArgs e)
        {
            IsImageProceee2 = cbImageProcess2.Checked;
        }

        // 软触发相关
        private void bnTriggerExec_Click(object sender, EventArgs e)
        {
            int nRet = m_MyCamera.MV_CC_SetCommandValue_NET("TriggerSoftware");
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("触发软件失败!", nRet);
            }
        }

        private void bnTriggerExec2_Click(object sender, EventArgs e)
        {
            int nRet = m_MyCamera2.MV_CC_SetCommandValue_NET("TriggerSoftware");
            if (MyCamera.MV_OK != nRet)
            {
                ShowErrorMsg("触发软件失败!", nRet);
            }
        }

        // 软触发选项变更
        private void cbSoftTrigger_CheckedChanged(object sender, EventArgs e)
        {
            if (cbSoftTrigger.Checked)
            {
                m_MyCamera.MV_CC_SetEnumValue_NET("TriggerSource", (uint)MyCamera.MV_CAM_TRIGGER_SOURCE.MV_TRIGGER_SOURCE_SOFTWARE);
                if (m_bGrabbing && bnTriggerMode.Checked)
                {
                    bnTriggerExec.Enabled = true;
                    btn_Trigger.Enabled = true;
                    button1.Enabled = true;
                    button2.Enabled = true;
                }
            }
            else
            {
                m_MyCamera.MV_CC_SetEnumValue_NET("TriggerSource", (uint)MyCamera.MV_CAM_TRIGGER_SOURCE.MV_TRIGGER_SOURCE_LINE0);
                bnTriggerExec.Enabled = false;
                btn_Trigger.Enabled = false;
                button1.Enabled = false;
                button2.Enabled = false;
            }
        }

        private void cbSoftTrigger2_CheckedChanged(object sender, EventArgs e)
        {
            if (cbSoftTrigger2.Checked)
            {
                m_MyCamera2.MV_CC_SetEnumValue_NET("TriggerSource", (uint)MyCamera.MV_CAM_TRIGGER_SOURCE.MV_TRIGGER_SOURCE_SOFTWARE);
                if (m_bGrabbing2 && bnTriggerMode2.Checked)
                {
                    bnTriggerExec2.Enabled = true;
                }
            }
            else
            {
                m_MyCamera2.MV_CC_SetEnumValue_NET("TriggerSource", (uint)MyCamera.MV_CAM_TRIGGER_SOURCE.MV_TRIGGER_SOURCE_LINE0);
                bnTriggerExec2.Enabled = false;
            }
        }

        // 触发模式变更
        private void bnTriggerMode2_CheckedChanged(object sender, EventArgs e)
        {
            if (bnTriggerMode2.Checked)
            {
                m_MyCamera2.MV_CC_SetEnumValue_NET("TriggerMode", (uint)MyCamera.MV_CAM_TRIGGER_MODE.MV_TRIGGER_MODE_ON);
                cbSoftTrigger2.Enabled = true;
                if (cbSoftTrigger2.Checked)
                {
                    m_MyCamera2.MV_CC_SetEnumValue_NET("TriggerSource", (uint)MyCamera.MV_CAM_TRIGGER_SOURCE.MV_TRIGGER_SOURCE_SOFTWARE);
                    if (m_bGrabbing2)
                    {
                        bnTriggerExec2.Enabled = true;
                    }
                }
            }
        }

        // 连续模式变更
        private void bnContinuesMode2_CheckedChanged(object sender, EventArgs e)
        {
            if (bnContinuesMode2.Checked)
            {
                m_MyCamera2.MV_CC_SetEnumValue_NET("TriggerMode", (uint)MyCamera.MV_CAM_TRIGGER_MODE.MV_TRIGGER_MODE_OFF);
                cbSoftTrigger2.Enabled = false;
                bnTriggerExec2.Enabled = false;
            }
        }

        // 文本框相关
        private void txt_Test_TextChanged(object sender, EventArgs e)
        {
        }

        private void txt_Test2_TextChanged(object sender, EventArgs e)
        {
        }

        // 按钮事件
        private void btn_Tset_Click(object sender, EventArgs e)
        {
            // 测试按钮功能实现  
        }

        private void button1_Click(object sender, EventArgs e)
        {
            // 开启持续软触发
            IsTrigger = true;
            TriggerThread = new Thread(SoftTrigger);
            TriggerThread.Start();
        }

        private void button2_Click(object sender, EventArgs e)
        {
            // 关闭持续软触发
            IsTrigger = false;
            TriggerThread.Join();
        }

        private void txt_Test2_TextChanged_1(object sender, EventArgs e)
        {

        }

        private void pictureBox2_Click(object sender, EventArgs e)
        {

        }

        private void pictureBox4_Click(object sender, EventArgs e)
        {

        }
    } // class Form1 结束


} // namespace 结束                                                                                                                                                                                 
